<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>Shell Tutorial | I'LL TAKE YOU TO THE MOON</title><meta name="keywords" content="2022春季,Linux,Shell"><meta name="author" content="Eren Zhao"><meta name="copyright" content="Eren Zhao"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="The most important criteria must be a clear, readable layout...">
<meta property="og:type" content="article">
<meta property="og:title" content="Shell Tutorial">
<meta property="og:url" content="http://example.com/2022/03/17/CS/others/shell_script/index.html">
<meta property="og:site_name" content="I&#39;LL TAKE YOU TO THE MOON">
<meta property="og:description" content="The most important criteria must be a clear, readable layout...">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://raw.githubusercontent.com/zhaochenyang20/ivue_wallpaper/main/ivue_desktop/Photo by Evan Smogor (q-VVjt78_3o).jpg">
<meta property="article:published_time" content="2022-03-17T01:00:37.686Z">
<meta property="article:modified_time" content="2022-08-26T15:29:54.282Z">
<meta property="article:author" content="Eren Zhao">
<meta property="article:tag" content="2022春季">
<meta property="article:tag" content="Linux">
<meta property="article:tag" content="Shell">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://raw.githubusercontent.com/zhaochenyang20/ivue_wallpaper/main/ivue_desktop/Photo by Evan Smogor (q-VVjt78_3o).jpg"><link rel="shortcut icon" href="/img/favicon.ico"><link rel="canonical" href="http://example.com/2022/03/17/CS/others/shell_script/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"麻了，找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: true,
  islazyload: false,
  isAnchor: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Shell Tutorial',
  isPost: true,
  isHome: false,
  isHighlightShrink: true,
  isToc: true,
  postUpdate: '2022-08-26 23:29:54'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          const now = new Date()
          const hour = now.getHours()
          const isNight = hour <= 6 || hour >= 18
          if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
          else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/mouse.css"><meta name="generator" content="Hexo 6.0.0"><link rel="alternate" href="/atom.xml" title="I'LL TAKE YOU TO THE MOON" type="application/atom+xml">
<style>.darkmode--activated{--body-bg-color:#282828;--content-bg-color:#333;--card-bg-color:#555;--text-color:#ccc;--blockquote-color:#bbb;--link-color:#ccc;--link-hover-color:#eee;--brand-color:#ddd;--brand-hover-color:#ddd;--table-row-odd-bg-color:#282828;--table-row-hover-bg-color:#363636;--menu-item-bg-color:#555;--btn-default-bg:#222;--btn-default-color:#ccc;--btn-default-border-color:#555;--btn-default-hover-bg:#666;--btn-default-hover-color:#ccc;--btn-default-hover-border-color:#666;--highlight-background:#282b2e;--highlight-foreground:#a9b7c6;--highlight-gutter-background:#34393d;--highlight-gutter-foreground:#9ca9b6}.darkmode--activated img{opacity:.75}.darkmode--activated img:hover{opacity:.9}.darkmode--activated code{color:#69dbdc;background:0 0}button.darkmode-toggle{z-index:9999}.darkmode-ignore,img{display:flex!important}</style></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/avatar.jpeg" onerror="onerror=null;src='/img/friend.jpg'" alt="avatar"/></div><div class="site-data is-center"><div class="data-item"><a href="/archives/"><div class="headline">文章</div><div class="length-num">193</div></a></div><div class="data-item"><a href="/tags/"><div class="headline">标签</div><div class="length-num">52</div></a></div><div class="data-item"><a href="/categories/"><div class="headline">分类</div><div class="length-num">31</div></a></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/list-100/"><i class="fa-fw fas fa-music"></i><span> TODO</span></a></div><div class="menus_item"><a class="site-page" href="/projects/"><i class="fa-fw fas fa-video"></i><span> Projects</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://raw.githubusercontent.com/zhaochenyang20/ivue_wallpaper/main/ivue_desktop/Photo by Evan Smogor (q-VVjt78_3o).jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">I'LL TAKE YOU TO THE MOON</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/list-100/"><i class="fa-fw fas fa-music"></i><span> TODO</span></a></div><div class="menus_item"><a class="site-page" href="/projects/"><i class="fa-fw fas fa-video"></i><span> Projects</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Shell Tutorial</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-03-17T01:00:37.686Z" title="发表于 2022-03-17 09:00:37">2022-03-17</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-08-26T15:29:54.282Z" title="更新于 2022-08-26 23:29:54">2022-08-26</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/CS/">CS</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/CS/Linux/">Linux</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">11.9k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>74分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Shell Tutorial"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="Philosophy"><a href="#Philosophy" class="headerlink" title="Philosophy"></a>Philosophy</h1><p>There are a number of factors which can go into good, clean, quick, shell scripts.</p>
<ul>
<li>The most important criteria must be a clear, readable layout.</li>
<li>Second is avoiding unnecessary commands.</li>
</ul>
<h2 id="A-clear-layout"><a href="#A-clear-layout" class="headerlink" title="A clear layout"></a><strong>A clear layout</strong></h2><p><strong>A clear layout</strong> makes the difference between a shell script appearing as “black magic” and one which is easily maintained and understood.<br>You may be forgiven for thinking that with a simple script, this is not too significant a problem, but two things here are worth bearing in mind.</p>
<ol>
<li>First, a simple script will, more often than anticipated, grow into a large, complex one.</li>
<li>Secondly, if nobody else can understand how it works, you will be lumbered with maintaining it yourself for the rest of your life!</li>
</ol>
<p>Something about shell scripts seems to make them particularly likely to be badly indented, and since the main control structures are if/then/else and loops, indentation is critical for understanding what a script does.</p>
<h2 id="avoiding-unnecessary-commands"><a href="#avoiding-unnecessary-commands" class="headerlink" title="avoiding unnecessary commands"></a>avoiding unnecessary commands</h2><p>One weakness in many shell scripts is lines such as:</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">cat /tmp/myfile | grep <span class="string">&quot;mystring&quot;</span></span><br></pre></td></tr></table></figure>
<p>which would run much faster as:</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">grep <span class="string">&quot;mystring&quot;</span> /tmp/myfile</span><br></pre></td></tr></table></figure>
<p>Not much, you may consider; the OS has to load up the <code>/bin/grep</code> executable, which is a reasonably small 75600 bytes on my system, open a <code>pipe</code> in memory for the transfer, load and run the <code>/bin/cat</code> executable, which is an even smaller 9528 bytes on my system, attach it to the input of the pipe, and let it run.</p>
<p>Of course, this kind of thing is what the OS is there for, and it’s normally pretty efficient at doing it. But if this command were in a loop being run many times over, the saving of not locating and loading the <code>cat</code> executable, setting up and releasing the pipe, can make some difference, especially in, say, a CGI environment where there are enough other factors to slow things down without the script itself being too much of a hurdle.</p>
<p>Some Unices are more efficient than others at what they call “building up and tearing down processes” - i.e., loading them up, executing them, and clearing them away again. But however good your flavour of Unix is at doing this, it’d rather not have to do it at all.</p>
<p>Which leads me nicely on to something else: Don’t <em>ever</em> feel too close to your own shell scripts; by their nature, the source cannot be closed. If you supply a customer with a shell script, s/he can inspect it quite easily. So you might as well accept that it will be inspected by anyone you pass it to; use this to your advantage with the <a target="_blank" rel="noopener" href="http://www.gnu.org/copyleft/gpl.html">GPL</a> - encourage people to give you feedback and bugfixes for free!</p>
<h1 id="A-First-Script"><a href="#A-First-Script" class="headerlink" title="A First Script"></a>A First Script</h1><p><a target="_blank" rel="noopener" href="https://www.shellscript.sh/eg/first.sh.txt">first.sh</a></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"><span class="comment"># This is a comment!</span></span><br><span class="line"><span class="built_in">echo</span> Hello World        <span class="comment"># This is a comment, too!</span></span><br></pre></td></tr></table></figure>
<p>The first line tells Unix that the file is to be executed by /bin/sh. This is the standard location of the Bourne shell on just about every Unix system. If you’re using GNU/Linux, /bin/sh is normally a symbolic link to bash (or, more recently, dash).</p>
<p>The second line begins with a special symbol: <code>#</code>. This marks the line as a comment, and it is ignored completely by the shell.</p>
<p>The only exception is when the <em>very first</em> line of the file starts with <code>#!</code> - as ours does. </p>
<p>This is a special directive which Unix treats specially. It means that even if you are using csh, ksh, or anything else as your interactive shell, that what follows should be interpreted by the Bourne shell.</p>
<p>Similarly, a Perl script may start with the line <code>#!/usr/bin/perl</code>to tell your interactive shell that the program which follows should be executed by perl. For Bourne shell programming, we shall stick to `#!/bin/sh.</p>
<p>The third line runs a command: echo, with two parameters, or arguments - the first is “Hello”; the second is “World”.</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; <span class="built_in">echo</span> hello world</span><br><span class="line">hello world</span><br><span class="line">&gt; <span class="built_in">echo</span> hello world zhaochen20</span><br><span class="line">hello world zhaochen20</span><br></pre></td></tr></table></figure>
<p>Note that echo will automatically put a single space between its parameters.<br>The # symbol still marks a comment; the # and anything following it is ignored by the shell.</p>
<p>now run <code>chmod 755 first.sh</code> to make the text file executable, and run <code>./first.sh</code>.<br>Your screen should then look like this:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ chmod 755 first.sh</span><br><span class="line">$ ./first.sh</span><br><span class="line">Hello World</span><br></pre></td></tr></table></figure>
<p>Now let’s make a few changes.</p>
<p>First, note that <code>echo</code> puts ONE space between its parameters. Put a few spaces between “Hello” and “World”. What do you expect the output to be? What about putting a TAB character between them?</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; <span class="built_in">echo</span> hello       world zhaochen20</span><br><span class="line">hello world zhaochen20</span><br></pre></td></tr></table></figure>
<p>As always with shell programming, try it and see.</p>
<p>The output is exactly the same! We are calling the <code>echo</code> program with two arguments; it doesn’t care any more than <code>cp</code> does about the gaps in between them. Now modify the code again:</p>
<p>This time it works. You probably expected that, too, if you have experience of other programming languages. But the key to understanding what is going on with more complex command and shell script, is to understand and be able to explain: WHY?</p>
<p><code>echo</code> has now been called with just ONE argument - the string “Hello  World”. It prints this out exactly.</p>
<p>The point to understand here is that the shell parses the arguments BEFORE passing them on to the program being called. In this case, it strips the quotes but passes the string as one argument.</p>
<p>As a final example, type in the following script. Try to predict the outcome before you run it:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">``` first2.sh</span><br><span class="line"><span class="comment">#!/bin/sh</span></span><br><span class="line"><span class="comment"># This is a comment!</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Hello      World&quot;</span>       <span class="comment"># This is a comment, too!</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Hello World&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Hello * World&quot;</span></span><br><span class="line"><span class="built_in">echo</span> Hello * World</span><br><span class="line"><span class="built_in">echo</span> Hello      World</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Hello&quot;</span> World</span><br><span class="line"><span class="built_in">echo</span> Hello <span class="string">&quot;     &quot;</span> World</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Hello &quot;</span>*<span class="string">&quot; World&quot;</span></span><br><span class="line"><span class="built_in">echo</span> `hello` world</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;hello&#x27;</span> world</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; ./first.sh</span><br><span class="line">Hello      World</span><br><span class="line">Hello World</span><br><span class="line">Hello * World</span><br><span class="line">Hello first.sh World</span><br><span class="line">Hello World</span><br><span class="line">Hello World</span><br><span class="line">Hello       World</span><br><span class="line">Hello * World</span><br><span class="line">./first.sh: line 11: hello: <span class="built_in">command</span> not found</span><br><span class="line">world</span><br><span class="line">hello world</span><br></pre></td></tr></table></figure>
<p>Damn, I also don’t know.</p>
<p>Is everything as you expected? If not, don’t worry! These are just some of the things we will be covering in this tutorial … and yes, we will be using more powerful commands than <code>echo</code>!</p>
<h1 id="Variables-Part-I"><a href="#Variables-Part-I" class="headerlink" title="Variables - Part I"></a>Variables - Part I</h1><p>Just about every programming language in existence has the concept of <em>variables</em> - a symbolic name for a chunk of memory to which we can assign values, read and manipulate its contents. </p>
<p>The Bourne shell is no exception, and this section introduces that idea. This is taken further in <a target="_blank" rel="noopener" href="https://www.shellscript.sh/variables2.html">Variables - Part II</a> which looks into variables which are set for us by the environment.</p>
<p>Let’s look back at our first Hello World example. This could be done using variables (though it’s such a simple example that it doesn’t really warrant it!)</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">``` var.sh</span><br><span class="line"><span class="comment">#!/bin/sh</span></span><br><span class="line">MY_MESSAGE=<span class="string">&quot;Hello World&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$MY_MESSAGE</span></span><br></pre></td></tr></table></figure>
<p>Note that there must be no spaces around the “=” sign: <code>VAR=value</code> works; <code>VAR = value</code> doesn’t work. In the first case, the shell sees the “=” symbol and treats the command as a variable assignment. In the second case, the shell assumes that VAR must be the name of a command and tries to execute it.</p>
<p>This assigns the string “Hello World” to the variable <code>MY_MESSAGE</code> then <code>echo</code>es out the value of the variable.</p>
<p>Note that we need the quotes around the string Hello World. Whereas we could get away with <code>echo Hello World</code> because echo will take any number of parameters, a variable can only hold one value, so a string with spaces must be quoted so that the shell knows to treat it all as one. Otherwise, the shell will try to execute the command <code>World</code> after assigning <code>MY_MESSAGE=Hello</code></p>
<p>The shell does not care about types of variables; they may store strings, integers, real numbers - anything you like.</p>
<p>People used to Perl may be quite happy with this; if you’ve grown up with C, Pascal, or worse yet Ada, this may seem quite strange.</p>
<p>In truth, these are all stored as strings, but routines which expect a number can treat them as such.</p>
<p>If you assign a string to a variable then try to add 1 to it, you will not get away with it:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ x=<span class="string">&quot;hello&quot;</span></span><br><span class="line">$ expr <span class="variable">$x</span> + 1</span><br><span class="line">expr: non-numeric argument</span><br><span class="line"></span><br><span class="line">&gt; <span class="variable">$x</span> + 1</span><br><span class="line">The program <span class="string">&#x27;hello&#x27;</span> can be found <span class="keyword">in</span> the following formulae:</span><br><span class="line">  * hello</span><br><span class="line">  * perkeep</span><br><span class="line">Try: brew install &lt;selected formula&gt;</span><br><span class="line"></span><br><span class="line">&gt; x=<span class="string">&quot;echo&quot;</span></span><br><span class="line">&gt; <span class="variable">$x</span> 1</span><br><span class="line">1</span><br></pre></td></tr></table></figure>
<p>This is because the external program <code>expr</code> only expects numbers. But there is no syntactic difference between:</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">MY_MESSAGE=<span class="string">&quot;Hello World&quot;</span></span><br><span class="line">MY_SHORT_MESSAGE=hi</span><br><span class="line">MY_NUMBER=1</span><br><span class="line">MY_PI=3.142</span><br><span class="line">MY_OTHER_PI=<span class="string">&quot;3.142&quot;</span></span><br><span class="line">MY_MIXED=123abc</span><br></pre></td></tr></table></figure>
<p>Note though that special characters must be properly escaped to avoid interpretation by the shell.</p>
<p>This is discussed further in Chapter 6, <a target="_blank" rel="noopener" href="https://www.shellscript.sh/escape.html">Escape Characters</a>.</p>
<p>We can interactively set variable names using the <code>read</code> command; the following script asks you for your name then greets you personally:</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">```var2.sh</span><br><span class="line"><span class="comment">#!/bin/sh</span></span><br><span class="line"><span class="built_in">echo</span> What is your name?</span><br><span class="line"><span class="built_in">read</span> MY_NAME</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Hello <span class="variable">$MY_NAME</span> - hope you&#x27;re well.&quot;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">&gt; ./first.sh</span><br><span class="line">What is your name?</span><br><span class="line">zhaochen20</span><br><span class="line">Hello zhaochen20 - hope you<span class="string">&#x27;re well.</span></span><br></pre></td></tr></table></figure>
<p>Mario Bacinsky kindly pointed out to me that I had originally missed out the double-quotes in line 3, which meant that the single-quote in the word “you’re” was unmatched, causing an error. It is this kind of thing which can drive a shell programmer crazy, so watch out for them!</p>
<p>This is using the shell-builtin command <code>read</code> which reads a line from standard input into the variable supplied.</p>
<p>Note that even if you give it your full name and don’t use double quotes around the <code>echo</code> command, it still outputs correctly. How is this done? With the <code>MY_MESSAGE</code> variable earlier we had to put double quotes around it to set it.</p>
<p>What happens, is that the <code>read</code> command automatically places quotes around its input, so that spaces are treated correctly. (You will need to quote the output, of course - e.g. <code>echo &quot;$MY_MESSAGE&quot;</code>).</p>
<h2 id="Scope-of-Variables"><a href="#Scope-of-Variables" class="headerlink" title="Scope of Variables"></a>Scope of Variables</h2><p>Variables in the Bourne shell do not have to be declared, as they do in languages like C. But if you try to read an undeclared variable, the result is the empty string. You get no warnings or errors. This can cause some subtle bugs - if you assign <code>MY_OBFUSCATED_VARIABLE=Hello</code> and then <code>echo $MY_OSFUCATED_VARIABLE</code> Then you will get nothing (as the second OBFUSCATED is mis-spelled).</p>
<p>There is a command called <code>export</code> which has a fundamental effect on the scope of variables. In order to really know what’s going on with your variables, you will need to understand something about how this is used.</p>
<p>Create a small shell script, <code>myvar2.sh</code>:</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;MYVAR is: <span class="variable">$MYVAR</span>&quot;</span></span><br><span class="line">MYVAR=<span class="string">&quot;hi there&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;MYVAR is: <span class="variable">$MYVAR</span>&quot;</span></span><br></pre></td></tr></table></figure>
<p>Now run the script:</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ ./myvar2.sh</span><br><span class="line">MYVAR is:</span><br><span class="line">MYVAR is: hi there</span><br></pre></td></tr></table></figure>
<p>MYVAR hasn’t been set to any value, so it’s blank. Then we give it a value, and it has the expected result.</p>
<p>Now run:</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ MYVAR=hello</span><br><span class="line">$ ./myvar2.sh</span><br><span class="line">MYVAR is:</span><br><span class="line">MYVAR is: hi there</span><br></pre></td></tr></table></figure>
<p>It’s still not been set! What’s going on?!</p>
<p>When you call <code>myvar2.sh</code> from your interactive shell, a new shell is spawned to run the script. This is partly because of the <code>#!/bin/sh</code> line at the start of the script, which we discussed <a target="_blank" rel="noopener" href="https://www.shellscript.sh/first.html">earlier</a>.</p>
<p>We need to <code>export</code> the variable for it to be inherited by another program - including a shell script. Type:</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">export</span> MYVAR</span><br><span class="line">$ ./myvar2.sh</span><br><span class="line">MYVAR is: hello</span><br><span class="line">MYVAR is: hi there</span><br></pre></td></tr></table></figure>
<p>Now look at line 3 of the script: this is changing the value of <code>MYVAR</code>. But there is no way that this will be passed back to your interactive shell. Try reading the value of <code>MYVAR</code>:</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="variable">$MYVAR</span></span><br><span class="line">hello</span><br><span class="line">$</span><br></pre></td></tr></table></figure>
<p>Once the shell script exits, its environment is destroyed. But <code>MYVAR</code> keeps its value of <code>hello</code> within your interactive shell.</p>
<p>In order to receive environment changes back from the script, we must <em>source</em> the script - this effectively runs the script within our own interactive shell, instead of spawning another shell to run it.</p>
<p>We can source a script via the “.” (dot) command:</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ MYVAR=hello</span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">$MYVAR</span></span><br><span class="line">hello</span><br><span class="line">$ . ./myvar2.sh</span><br><span class="line">MYVAR is: hello</span><br><span class="line">MYVAR is: hi there</span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">$MYVAR</span></span><br><span class="line">hi there</span><br></pre></td></tr></table></figure>
<p>The change has now made it out into our shell again! This is how your <code>.profile</code> or <code>.bash_profile</code> file works, for example.</p>
<p>Note that in this case, we don’t need to <code>export MYVAR</code>.</p>
<p>Thanks to <em>sway</em> for pointing out that I’d originally said <code>echo MYVAR</code> above, not <code>echo $MYVAR</code> as it should be. Another example of an easy mistake to make with shell scripts. One other thing worth mentioning at this point about variables is to consider the following shell script:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt; . ./first.sh</span><br><span class="line">MYVAR is:</span><br><span class="line">MYVAR is: hi there</span><br><span class="line">&gt; MYVAR=1</span><br><span class="line">&gt; . ./first.sh</span><br><span class="line">MYVAR is: 1</span><br><span class="line">MYVAR is: hi there</span><br><span class="line">&gt; echo &quot;$MYVAR&quot;</span><br><span class="line">hi there</span><br></pre></td></tr></table></figure>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">&gt; ./first.sh</span><br><span class="line">MYVAR is:</span><br><span class="line">MYVAR is: hi there</span><br><span class="line">&gt; MYVAR=1</span><br><span class="line">&gt; ./first.sh</span><br><span class="line">MYVAR is:</span><br><span class="line">MYVAR is: hi there</span><br><span class="line">&gt; <span class="built_in">export</span> MYVAR</span><br><span class="line">&gt; ./first.sh</span><br><span class="line">MYVAR is: 1</span><br><span class="line">MYVAR is: hi there</span><br><span class="line">&gt; <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$MYVAR</span>&quot;</span></span><br><span class="line">1</span><br></pre></td></tr></table></figure>
<p>Yeah, we can find that the tiny difference between <code>export var</code> and “.” (dot) command.</p>
<p>This is how your <code>.profile</code> or <code>.bash_profile</code> file works, for example.<br>Note that in this case, we don’t need to <code>export MYVAR</code>.</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;What is your name?&quot;</span></span><br><span class="line"><span class="built_in">read</span> USER_NAME</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Hello <span class="variable">$USER_NAME</span>&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;I will create you a file called <span class="variable">$&#123;USER_NAME&#125;</span>_file&quot;</span></span><br><span class="line">touch <span class="string">&quot;<span class="variable">$&#123;USER_NAME&#125;</span>_file&quot;</span></span><br></pre></td></tr></table></figure>
<p>So much like f-string in Python.</p>
<p>The shell now knows that we are referring to the variable <code>USER_NAME</code> and that we want it suffixed with “<code>_file</code>“. This can be the downfall of many a new shell script programmer, as the source of the problem can be difficult to track down.</p>
<p>Also, note the quotes around <code>&quot;$&#123;USER_NAME&#125;_file&quot;</code> - if the user entered “Steve Parker” (note the space) then without the quotes, the arguments passed to <code>touch</code> would be <code>Steve</code> and <code>Parker_file</code> - that is, we’d effectively be saying <code>touch Steve Parker_file</code>, which is two files to be <code>touch</code>ed, not one. The quotes avoid this. Thanks to Chris for highlighting this.</p>
<h1 id="Wildcards"><a href="#Wildcards" class="headerlink" title="Wildcards"></a>Wildcards</h1><p>Wildcards are really nothing new if you have used Unix at all before.</p>
<p>It is not necessarily obvious how they are useful in shell scripts though. This section is really just to get the old grey cells thinking how things look when you’re in a shell script - predicting what the effect of using different syntaxes are. This will be used later on, particularly in the <a target="_blank" rel="noopener" href="https://www.shellscript.sh/loops.html">Loops</a> section.</p>
<p>Think first how you would copy all the files from <code>/tmp/a</code> into <code>/tmp/b</code>. All the .txt files? All the .html files?<br>Hopefully you will have come up with:</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ cp /tmp/a/* /tmp/b/</span><br><span class="line">$ cp /tmp/a/*.txt /tmp/b/</span><br><span class="line">$ cp /tmp/a/*.html /tmp/b/</span><br></pre></td></tr></table></figure>
<p>Now how would you list the files in <code>/tmp/a/</code> without using <code>ls /tmp/a/</code>?<br>How about <code>echo /tmp/a/*</code>? What are the two key differences between this and the <code>ls</code> output? How can this be useful? Or a hinderance?<br>How could you rename all .txt files to .bak? Note that</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ mv *.txt *.bak</span><br></pre></td></tr></table></figure>
<p>will not have the desired effect; think about how this gets expanded by the shell before it is passed to <code>mv</code>. Try this using <code>echo</code> instead of <code>mv</code> if this helps.</p>
<p>We will look into this further later on, as it uses a few concepts not yet covered.</p>
<h1 id="Escape-Characters"><a href="#Escape-Characters" class="headerlink" title="Escape Characters"></a>Escape Characters</h1><p>Certain characters are significant to the shell; we have seen, for example, that the use of double quotes (“) characters affect how spaces and TAB characters are treated, for example:</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> Hello       World</span><br><span class="line">Hello World</span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">&quot;Hello       World&quot;</span></span><br><span class="line">Hello     World</span><br></pre></td></tr></table></figure>
<p>So how do we display: <code>Hello  &quot;World&quot;</code> ?</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Hello   \&quot;World\&quot;&quot;</span></span><br></pre></td></tr></table></figure>
<p>The first and last “ characters wrap the whole lot into one parameter passed to <code>echo</code> so that the spacing between the two words is kept as is. But the code:</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Hello   &quot;</span> World <span class="string">&quot;&quot;</span></span><br></pre></td></tr></table></figure>
<p>would be interpreted as three parameters:</p>
<ol>
<li>“Hello  “</li>
<li>World</li>
<li>“”</li>
</ol>
<p>So the output would be</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">Hello    World</span><br></pre></td></tr></table></figure>
<p>Note that we lose the quotes entirely. This is because the first and second quotes mark off the Hello and following spaces; the second argument is an unquoted “World” and the third argument is the empty string; “”.</p>
<p>Thanks to Patrick for pointing out that this:</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="string">&quot;Hello   &quot;</span>World<span class="string">&quot;&quot;</span></span><br></pre></td></tr></table></figure>
<p>is actually only one parameter (no spaces between the quoted parameters), and that you can test this by replacing the <code>echo</code> command with (for example) <code>ls</code>.</p>
<p>Most characters (<code>*</code>, <code>&#39;</code>, etc) are not interpreted (ie, they are taken literally) by means of placing them in double quotes (“”). They are taken as is and passed on to the command being called. An example using the asterisk (*) goes:</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> *</span><br><span class="line">case.shtml escape.shtml first.shtml </span><br><span class="line">functions.shtml hints.shtml index.shtml </span><br><span class="line">ip-primer.txt raid1+0.txt</span><br><span class="line">$ <span class="built_in">echo</span> *txt</span><br><span class="line">ip-primer.txt raid1+0.txt</span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">&quot;*&quot;</span></span><br><span class="line">*</span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">&quot;*txt&quot;</span></span><br><span class="line">*txt</span><br></pre></td></tr></table></figure>
<p>In the first example, * is expanded to mean all files in the current directory.</p>
<p>In the second example, *txt means all files ending in <code>txt</code>.</p>
<p>In the third, we put the * in double quotes, and it is interpreted literally.</p>
<p>In the fourth example, the same applies, but we have appended <code>txt</code> to the string.</p>
<p>However, <code>&quot;</code>, <code>$</code>, <code>``, and</code>` are still interpreted by the shell, even when they’re in double quotes.</p>
<p>The backslash <code>\</code> character is used to mark these special characters so that they are not interpreted by the shell, but passed on to the command being run (for example, <code>echo</code>).</p>
<p>So to output the string: (Assuming that the value of <code>$X</code> is 5):</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">A quote is <span class="string">&quot;, backslash is \, backtick is `.</span></span><br><span class="line"><span class="string">A few spaces are    and dollar is $. <span class="variable">$X</span> is 5.</span></span><br></pre></td></tr></table></figure>
<p>we would have to write:</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="string">&quot;A quote is \&quot;, backslash is \\, backtick is \`.&quot;</span></span><br><span class="line">A quote is <span class="string">&quot;, backslash is \, backtick is `.</span></span><br><span class="line"><span class="string">$ echo &quot;</span>A few spaces are    and dollar is \$. \<span class="variable">$X</span> is <span class="variable">$&#123;X&#125;</span>.<span class="string">&quot;</span></span><br><span class="line"><span class="string">A few spaces are    and dollar is $. <span class="variable">$X</span> is 5.</span></span><br></pre></td></tr></table></figure>
<p>We have seen why the “ is special for preserving spacing. Dollar (<code>$</code>) is special because it marks a variable, so <code>$X</code> is replaced by the shell with the contents of the variable <code>X</code>. Backslash (<code>\</code>) is special because it is itself used to mark other characters off; we need the following options for a complete shell:</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="string">&quot;This is \\ a backslash&quot;</span></span><br><span class="line">This is \ a backslash</span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">&quot;This is \&quot; a quote and this is \\ a backslash&quot;</span></span><br><span class="line">This is <span class="string">&quot; a quote and this is \ a backslash</span></span><br></pre></td></tr></table></figure>
<p>So backslash itself must be escaped to show that it is to be taken literally. The other special character, the backtick, is discussed later in Chapter 12, <a target="_blank" rel="noopener" href="https://www.shellscript.sh/external.html">External Programs</a>.</p>
<h1 id="Loops"><a href="#Loops" class="headerlink" title="Loops"></a>Loops</h1><p>Most languages have the concept of loops: If we want to repeat a task twenty times, we don’t want to have to type in the code twenty times, with maybe a slight change each time.<br>As a result, we have <code>for</code> and <code>while</code> loops in the Bourne shell. This is somewhat fewer features than other languages, but nobody claimed that shell programming has the power of C.</p>
<h2 id="For-Loops"><a href="#For-Loops" class="headerlink" title="For Loops"></a>For Loops</h2><p><code>for</code> loops iterate through a set of values until the list is exhausted:</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> 1 2 3 4 5</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;Looping ... number <span class="variable">$i</span>&quot;</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>
<p>Try this code and see what it does. Note that the values can be anything at all:</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> hello 1 * 2 goodbye </span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;Looping ... i is set to <span class="variable">$i</span>&quot;</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">&gt; ./first.sh</span><br><span class="line">Looping ... i is <span class="built_in">set</span> to hello</span><br><span class="line">Looping ... i is <span class="built_in">set</span> to 1</span><br><span class="line">Looping ... i is <span class="built_in">set</span> to first.sh</span><br><span class="line">Looping ... i is <span class="built_in">set</span> to zcy.md</span><br><span class="line">Looping ... i is <span class="built_in">set</span> to 2</span><br><span class="line">Looping ... i is <span class="built_in">set</span> to goodbye</span><br></pre></td></tr></table></figure>
<p>This is well worth trying. Make sure that you understand what is happening here. Try it without the <code>*</code> and grasp the idea, then re-read the <a target="_blank" rel="noopener" href="https://www.shellscript.sh/wildcards.html">Wildcards</a> section and try it again with the <code>*</code> in place. Try it also in different directories, and with the <code>*</code> surrounded by double quotes, and try it preceded by a backslash (<code>\*</code>)</p>
<p>In case you don’t have access to a shell at the moment (it is very useful to have a shell to hand whilst reading this tutorial), the results of the above two scripts are:</p>
<h2 id="While-Loops"><a href="#While-Loops" class="headerlink" title="While Loops"></a>While Loops</h2><p><code>while</code> loops can be much more fun! (depending on your idea of fun, and how often you get out of the house… )</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line">INPUT_STRING=hello</span><br><span class="line"><span class="keyword">while</span> [ <span class="string">&quot;<span class="variable">$INPUT_STRING</span>&quot;</span> != <span class="string">&quot;bye&quot;</span> ]</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;Please type something in (bye to quit)&quot;</span></span><br><span class="line">  <span class="built_in">read</span> INPUT_STRING</span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;You typed: <span class="variable">$INPUT_STRING</span>&quot;</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>
<p>What happens here, is that the echo and read statements will run indefinitely until you type “bye” when prompted.</p>
<p>Review <a target="_blank" rel="noopener" href="https://www.shellscript.sh/variables1.html">Variables - Part I</a> to see why we set <code>INPUT_STRING=hello</code> before testing it. This makes it a repeat loop, not a traditional while loop.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt; ./first.sh</span><br><span class="line">Please type something in (bye to quit)</span><br><span class="line">zhaochen20</span><br><span class="line">You typed: zhaochen20</span><br><span class="line">Please type something in (bye to quit)</span><br><span class="line">acy</span><br><span class="line">You typed: acy</span><br><span class="line">Please type something in (bye to quit)</span><br><span class="line">wwqswez</span><br><span class="line">You typed: wwqswez</span><br><span class="line">Please type something in (bye to quit)</span><br><span class="line">bye</span><br><span class="line">You typed: bye</span><br></pre></td></tr></table></figure>
<p>What happens here, is that the echo and read statements will run indefinitely until you type “bye” when prompted.</p>
<p>Review <a target="_blank" rel="noopener" href="https://www.shellscript.sh/variables1.html">Variables - Part I</a> to see why we set <code>INPUT_STRING=hello</code> before testing it. This makes it a repeat loop, not a traditional while loop.</p>
<p>The colon (<code>:</code>) always evaluates to true; whilst using this can be necessary sometimes, it is often preferable to use a real exit condition. Compare quitting the above loop with the one below; see which is the more elegant. Also think of some situations in which each one would be more useful than the other:</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"><span class="keyword">while</span> :</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;Please type something in (^C to quit)&quot;</span></span><br><span class="line">  <span class="built_in">read</span> INPUT_STRING</span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;You typed: <span class="variable">$INPUT_STRING</span>&quot;</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">&gt; ./first.sh</span><br><span class="line">Please <span class="built_in">type</span> something <span class="keyword">in</span> (^C to quit)</span><br><span class="line">zhaochen20</span><br><span class="line">You typed: zhaochen20</span><br><span class="line">Please <span class="built_in">type</span> something <span class="keyword">in</span> (^C to quit)</span><br><span class="line">^C</span><br></pre></td></tr></table></figure>
<p>Another useful trick is the <code>while read</code> loop. This example uses the <a target="_blank" rel="noopener" href="https://www.shellscript.sh/case.html">case</a> statement, which we’ll cover later. It reads from the file <code>myfile.txt</code>, and for each line, tells you what language it thinks is being used.</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"><span class="keyword">while</span> <span class="built_in">read</span> input_text</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">  <span class="keyword">case</span> <span class="variable">$input_text</span> <span class="keyword">in</span></span><br><span class="line">        hello)          <span class="built_in">echo</span> English    ;;</span><br><span class="line">        howdy)          <span class="built_in">echo</span> American   ;;</span><br><span class="line">        gday)           <span class="built_in">echo</span> Australian ;;</span><br><span class="line">        bonjour)        <span class="built_in">echo</span> French     ;;</span><br><span class="line">        <span class="string">&quot;guten tag&quot;</span>)    <span class="built_in">echo</span> German     ;;</span><br><span class="line">        *)              <span class="built_in">echo</span> Unknown Language: <span class="variable">$input_text</span></span><br><span class="line">                ;;</span><br><span class="line">   <span class="keyword">esac</span></span><br><span class="line"><span class="keyword">done</span> &lt; myfile.txt</span><br></pre></td></tr></table></figure>
<p>(note: Each line must end with a LF (newline) - if <code>cat myfile.txt</code> doesn’t end with a blank line, that final line will not be processed.)</p>
<p>his reads the file “<code>myfile.txt</code>“, one line at a time, into the variable “<code>$input_text</code>“. The <a target="_blank" rel="noopener" href="https://www.shellscript.sh/case.html">case</a> statement then checks the value of <code>$input_text</code>. If the word that was read from <code>myfile.txt</code> was “hello” then it <code>echo</code>es the word “English”. If it was “gday” then it will <code>echo Australian</code>. If the word (or words) read from a line of <code>myfile.txt</code> don’t match any of the provided patterns, then the catch-all “*” default will display the message “Unknown Language: $input_text” - where of course “$input_text” is the value of the line that it read in from <code>myfile.txt</code>.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">this file is called myfile.txt and we are using it as an example input.</span><br><span class="line">hello</span><br><span class="line">gday</span><br><span class="line">bonjour</span><br><span class="line">hola</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>A handy Bash (but not Bourne Shell) tip I learned recently from the <a target="_blank" rel="noopener" href="http://www.linuxfromscratch.org/">Linux From Scratch</a> project is:</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">mkdir rc&#123;0,1,2,3,4,5,6,S&#125;.d</span><br></pre></td></tr></table></figure>
<p>instead of the more cumbersome:</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> runlevel <span class="keyword">in</span> 0 1 2 3 4 5 6 S</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">  mkdir rc<span class="variable">$&#123;runlevel&#125;</span>.d</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>
<p>And this can be done recursively, too:</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> /</span><br><span class="line">$ ls -ld &#123;,usr,usr/<span class="built_in">local</span>&#125;/&#123;bin,sbin,lib&#125;</span><br><span class="line">drwxr-xr-x    2 root     root         4096 Oct 26 01:00 /bin</span><br><span class="line">drwxr-xr-x    6 root     root         4096 Jan 16 17:09 /lib</span><br><span class="line">drwxr-xr-x    2 root     root         4096 Oct 27 00:02 /sbin</span><br><span class="line">drwxr-xr-x    2 root     root        40960 Jan 16 19:35 usr/bin</span><br><span class="line">drwxr-xr-x   83 root     root        49152 Jan 16 17:23 usr/lib</span><br><span class="line">drwxr-xr-x    2 root     root         4096 Jan 16 22:22 usr/<span class="built_in">local</span>/bin</span><br><span class="line">drwxr-xr-x    3 root     root         4096 Jan 16 19:17 usr/<span class="built_in">local</span>/lib</span><br><span class="line">drwxr-xr-x    2 root     root         4096 Dec 28 00:44 usr/<span class="built_in">local</span>/sbin</span><br><span class="line">drwxr-xr-x    2 root     root         8192 Dec 27 02:10 usr/sbin</span><br></pre></td></tr></table></figure>
<h1 id="Test"><a href="#Test" class="headerlink" title="Test"></a>Test</h1><p>Test is used by virtually every shell script written. It may not seem that way, because <code>test</code> is not often called directly. <code>test</code> is more frequently called as <code>[</code>. <code>[</code> is a symbolic link to <code>test</code>, just to make shell programs more readable. It is also normally a shell builtin (which means that the shell itself will interpret <code>[</code> as meaning <code>test</code>, even if your Unix environment is set up differently):</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">type</span> [</span><br><span class="line">[ is a shell <span class="built_in">builtin</span></span><br><span class="line">$ <span class="built_in">which</span> [</span><br><span class="line">/usr/bin/[</span><br><span class="line">$ ls -l /usr/bin/[</span><br><span class="line">lrwxrwxrwx 1 root root 4 Mar 27 2000 /usr/bin/[ -&gt; <span class="built_in">test</span></span><br><span class="line">$ ls -l /usr/bin/<span class="built_in">test</span></span><br><span class="line">-rwxr-xr-x 1 root root 35368 Mar 27  2000 /usr/bin/<span class="built_in">test</span></span><br></pre></td></tr></table></figure>
<p>This means that ‘<code>[</code>‘ is actually a program, just like <code>ls</code> and other programs, so it must be surrounded by spaces:</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> [<span class="variable">$foo</span> = <span class="string">&quot;bar&quot;</span> ]</span><br></pre></td></tr></table></figure>
<p>will not work; it is interpreted as <code>if test$foo = &quot;bar&quot; ]</code>, which is a ‘<code>]</code>‘ without a beginning ‘<code>[</code>‘. Put spaces around all your operators. I’ve highlighted the mandatory spaces with the word ‘SPACE’ - replace ‘SPACE’ with an actual space; if there isn’t a space there, it won’t work:</p>
<p>Note: Some shells also accept “<code>==</code>“ for string comparison; this is not portable, a single “<code>=</code>“ should be used for strings, or “<code>-eq</code>“ for integers.</p>
<p>Test is a simple but powerful comparison utility. For full details, run <code>man test</code> on your system, but here are some usages and typical examples.</p>
<p>Test is most often invoked indirectly via the <code>if</code> and <code>while</code> statements. It is also the reason you will come into difficulties if you create a program called <code>test</code> and try to run it, as this shell builtin will be called instead of your program!</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">&gt; foo=1</span><br><span class="line">&gt; <span class="keyword">if</span> [ <span class="variable">$foo</span> = 1 ]</span><br><span class="line"><span class="keyword">then</span> <span class="built_in">echo</span> 1</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line">1</span><br></pre></td></tr></table></figure>
<p>The syntax for <code>if...then...else...</code> is:</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> [ ... ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">  <span class="comment"># if-code</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  <span class="comment"># else-code</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>
<p>Note that <code>fi</code> is <code>if</code> backwards! This is used again later with <a target="_blank" rel="noopener" href="https://www.shellscript.sh/case.html">case</a> and <code>esac</code>.<br>Also, be aware of the syntax - the “<code>if [ ... ]</code>“ and the “<code>then</code>“ commands must be on different lines. Alternatively, the semicolon “<code>;</code>“ can separate them:</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> [ ... ]; <span class="keyword">then</span></span><br><span class="line">  <span class="comment"># do something</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>
<p>You can also use the <code>elif</code>, like this:</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>  [ something ]; <span class="keyword">then</span></span><br><span class="line"> <span class="built_in">echo</span> <span class="string">&quot;Something&quot;</span></span><br><span class="line"> <span class="keyword">elif</span> [ something_else ]; <span class="keyword">then</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">&quot;Something else&quot;</span></span><br><span class="line"> <span class="keyword">else</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">&quot;None of the above&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>
<p>This will <code>echo &quot;Something&quot;</code> if the <code>[ something ]</code> test succeeds, otherwise it will test <code>[ something_else ]</code>, and <code>echo &quot;Something else&quot;</code> if that succeeds. If all else fails, it will <code>echo &quot;None of the above&quot;</code>.</p>
<p>Try the following code snippet, before running it set the variable X to various values (try -1, 0, 1, hello, bye, etc). You can do this as follows (thanks to Dave for pointing out the need to export the variable, as noted in <a target="_blank" rel="noopener" href="https://www.shellscript.sh/variables1.html">Variables - Part I</a>.):</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$X</span>&quot;</span> -lt <span class="string">&quot;0&quot;</span> ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;X is less than zero&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$X</span>&quot;</span> -gt <span class="string">&quot;0&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;X is more than zero&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line">[ <span class="string">&quot;<span class="variable">$X</span>&quot;</span> -le <span class="string">&quot;0&quot;</span> ] &amp;&amp; \</span><br><span class="line">      <span class="built_in">echo</span> <span class="string">&quot;X is less than or equal to  zero&quot;</span></span><br><span class="line">[ <span class="string">&quot;<span class="variable">$X</span>&quot;</span> -ge <span class="string">&quot;0&quot;</span> ] &amp;&amp; \</span><br><span class="line">      <span class="built_in">echo</span> <span class="string">&quot;X is more than or equal to zero&quot;</span></span><br><span class="line">[ <span class="string">&quot;<span class="variable">$X</span>&quot;</span> = <span class="string">&quot;0&quot;</span> ] &amp;&amp; \</span><br><span class="line">      <span class="built_in">echo</span> <span class="string">&quot;X is the string or number \&quot;0\&quot;&quot;</span></span><br><span class="line">[ <span class="string">&quot;<span class="variable">$X</span>&quot;</span> = <span class="string">&quot;hello&quot;</span> ] &amp;&amp; \</span><br><span class="line">      <span class="built_in">echo</span> <span class="string">&quot;X matches the string \&quot;hello\&quot;&quot;</span></span><br><span class="line">[ <span class="string">&quot;<span class="variable">$X</span>&quot;</span> != <span class="string">&quot;hello&quot;</span> ] &amp;&amp; \</span><br><span class="line">      <span class="built_in">echo</span> <span class="string">&quot;X is not the string \&quot;hello\&quot;&quot;</span></span><br><span class="line">[ -n <span class="string">&quot;<span class="variable">$X</span>&quot;</span> ] &amp;&amp; \</span><br><span class="line">      <span class="built_in">echo</span> <span class="string">&quot;X is of nonzero length&quot;</span></span><br><span class="line">[ -f <span class="string">&quot;<span class="variable">$X</span>&quot;</span> ] &amp;&amp; \</span><br><span class="line">      <span class="built_in">echo</span> <span class="string">&quot;X is the path of a real file&quot;</span> || \</span><br><span class="line">      <span class="built_in">echo</span> <span class="string">&quot;No such file: <span class="variable">$X</span>&quot;</span></span><br><span class="line">[ -x <span class="string">&quot;<span class="variable">$X</span>&quot;</span> ] &amp;&amp; \</span><br><span class="line">      <span class="built_in">echo</span> <span class="string">&quot;X is the path of an executable file&quot;</span></span><br><span class="line">[ <span class="string">&quot;<span class="variable">$X</span>&quot;</span> -nt <span class="string">&quot;/etc/passwd&quot;</span> ] &amp;&amp; \</span><br><span class="line">      <span class="built_in">echo</span> <span class="string">&quot;X is a file which is newer than /etc/passwd&quot;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ X=5</span><br><span class="line">$ <span class="built_in">export</span> X</span><br><span class="line">$ ./test.sh</span><br><span class="line">  ... output of test.sh ...</span><br><span class="line">$ X=hello</span><br><span class="line">$ ./test.sh</span><br><span class="line">  ... output of test.sh ...</span><br><span class="line">$ X=test.sh</span><br><span class="line">$ ./test.sh</span><br><span class="line">  ... output of test.sh ...</span><br></pre></td></tr></table></figure>
<p>Then try it again, with <code>$X</code> as the name of an existing file, such as <code>/etc/hosts</code>.</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">&gt; X=1</span><br><span class="line">&gt; <span class="built_in">export</span> X</span><br><span class="line">&gt; ./first.sh</span><br><span class="line">X is more than zero</span><br><span class="line">X is more than or equal to zero</span><br><span class="line">X is not the string <span class="string">&quot;hello&quot;</span></span><br><span class="line">X is of nonzero length</span><br><span class="line">No such file: 1</span><br><span class="line">&gt; X=/Users/zhaochen20/THU_CST/2022_spring/linux/lab</span><br><span class="line">&gt; <span class="built_in">export</span> X</span><br><span class="line">&gt; ./first.sh</span><br><span class="line">./first.sh: line 2: [: /Users/zhaochen20/THU_CST/2022_spring/linux/lab: <span class="built_in">integer</span> expression expected</span><br><span class="line">./first.sh: line 6: [: /Users/zhaochen20/THU_CST/2022_spring/linux/lab: <span class="built_in">integer</span> expression expected</span><br><span class="line">./first.sh: line 9: [: /Users/zhaochen20/THU_CST/2022_spring/linux/lab: <span class="built_in">integer</span> expression expected</span><br><span class="line">./first.sh: line 11: [: /Users/zhaochen20/THU_CST/2022_spring/linux/lab: <span class="built_in">integer</span> expression expected</span><br><span class="line">X is not the string <span class="string">&quot;hello&quot;</span></span><br><span class="line">X is of nonzero length</span><br><span class="line">No such file: /Users/zhaochen20/THU_CST/2022_spring/linux/lab</span><br><span class="line">X is the path of an executable file</span><br><span class="line">X is a file <span class="built_in">which</span> is newer than /etc/passwd</span><br></pre></td></tr></table></figure>
<p>Note that we can use the semicolon (<code>;</code>) to join two lines together. This is often done to save a bit of space in simple <code>if</code> statements.</p>
<p>The backslash (<code>\</code>) serves a similar, but opposite purpose: it tells the shell that this is not the end of the line, but that the following line should be treated as part of the current line. This is useful for readability. It is customary to indent the following line after a backslash (<code>\</code>) or semicolon (<code>;</code>).</p>
<p>For example, the semicolon (<code>;</code>) is often used like this to join the <code>if</code> and <code>then</code> keywords:</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$X</span>&quot;</span> -nt <span class="string">&quot;/etc/passwd&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">      <span class="built_in">echo</span> <span class="string">&quot;X is a file which is newer than /etc/passwd&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>
<p>whilst the backslash (<code>\</code>) is used to split the single-line command across two lines in the shell script file, for readability purposes:</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[ <span class="string">&quot;<span class="variable">$X</span>&quot;</span> -nt <span class="string">&quot;/etc/passwd&quot;</span> ] &amp;&amp; \</span><br><span class="line">      <span class="built_in">echo</span> <span class="string">&quot;X is a file which is newer than /etc/passwd&quot;</span></span><br></pre></td></tr></table></figure>
<p>As we see from these examples, <code>test</code> can perform many tests on numbers, strings, and filenames.</p>
<p>Thanks to Aaron for pointing out that <code>-a</code>, <code>-e</code> (both meaning “file exists”), <code>-S</code> (file is a Socket), <code>-nt</code> (file is newer than), <code>-ot</code> (file is older than), <code>-ef</code> (paths refer to the same file) and <code>-O</code> (file is owned by the user running the test) are not available in the traditional Bourne shell (eg, /bin/sh on Solaris, AIX, HPUX, etc).</p>
<p>There is a simpler way of writing <code>if</code> statements: The <code>&amp;&amp;</code> and <code>||</code> commands give code to run if the result is true, or false, respectively.</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line">[ <span class="variable">$X</span> -ne 0 ] &amp;&amp; <span class="built_in">echo</span> <span class="string">&quot;X isn&#x27;t zero&quot;</span> || <span class="built_in">echo</span> <span class="string">&quot;X is zero&quot;</span></span><br><span class="line">[ -f <span class="variable">$X</span> ] &amp;&amp; <span class="built_in">echo</span> <span class="string">&quot;X is a file&quot;</span> || <span class="built_in">echo</span> <span class="string">&quot;X is not a file&quot;</span></span><br><span class="line">[ -n <span class="variable">$X</span> ] &amp;&amp; <span class="built_in">echo</span> <span class="string">&quot;X is of non-zero length&quot;</span> || \</span><br><span class="line">      <span class="built_in">echo</span> <span class="string">&quot;X is of zero length&quot;</span></span><br></pre></td></tr></table></figure>
<p>This syntax is possible because there is a file (or shell-builtin) called <code>[</code> which is linked to <code>test</code>. Be careful using this construct, though, as overuse can lead to very hard-to-read code. The <code>if...then...else...</code> structure is much more readable. Use of the <code>[...]</code> construct is recommended for while loops and trivial sanity checks with which you do not want to overly distract the reader.</p>
<p>Note that when you set X to a non-numeric value, the first few comparisons result in the message:</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">test.sh: [: <span class="built_in">integer</span> expression expected before -lt</span><br><span class="line">test.sh: [: <span class="built_in">integer</span> expression expected before -gt</span><br><span class="line">test.sh: [: <span class="built_in">integer</span> expression expected before -le</span><br><span class="line">test.sh: [: <span class="built_in">integer</span> expression expected before -ge</span><br></pre></td></tr></table></figure>
<p>This is because the -lt, -gt, -le and -ge comparisons are only designed for integers, and do not work on strings. The string comparisons, such as <code>!=</code> will happily treat “5” as a string, but there is no sensible way of treating “Hello” as an integer, so the integer comparisons complain.</p>
<p>If you want your shell script to behave more gracefully, you will have to check the contents of the variable before you test it - maybe something like this:</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> -en <span class="string">&quot;Please guess the magic number: &quot;</span></span><br><span class="line"><span class="built_in">read</span> X</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$X</span> | grep <span class="string">&quot;[^0-9]&quot;</span> &gt; /dev/null 2&gt;&amp;1</span><br><span class="line"><span class="keyword">if</span> [ <span class="string">&quot;$?&quot;</span> -eq <span class="string">&quot;0&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">  <span class="comment"># If the grep found something other than 0-9</span></span><br><span class="line">  <span class="comment"># then it&#x27;s not an integer.</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;Sorry, wanted a number&quot;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  <span class="comment"># The grep found only 0-9, so it&#x27;s an integer. </span></span><br><span class="line">  <span class="comment"># We can safely do a test on it.</span></span><br><span class="line">  <span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$X</span>&quot;</span> -eq <span class="string">&quot;7&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;You entered the magic number!&quot;</span></span><br><span class="line">  <span class="keyword">fi</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>
<p>In this way you can <code>echo</code> a more meaningful message to the user, and exit gracefully. The <code>$?</code> variable is explained in <a target="_blank" rel="noopener" href="https://www.shellscript.sh/variables2.html">Variables - Part II</a>, and <code>grep</code> is a complicated beast, so here goes: <code>grep [0-9]</code> finds lines of text which contain digits (0-9) and possibly other characters, so the caret (<code>^</code>) in <code>grep [^0-9]</code> finds only those lines which don’t consist only of numbers. We can then take the opposite (by acting on failure, not success). Okay? The <code>&gt;/dev/null 2&gt;&amp;1</code> directs any output or errors to the special “null” device, instead of going to the user’s screen.<br>Many thanks to Paul Schermerhorn for correcting me - this page used to claim that <code>grep -v [0-9]</code> would work, but this is clearly far too simplistic.</p>
<p>We can use test in while loops as follows:</p>
<p>We can use test in while loops as follows:</p>
<hr>
<p><a target="_blank" rel="noopener" href="https://www.shellscript.sh/eg/test2.sh.txt">test2.sh</a></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line">X=0</span><br><span class="line"><span class="keyword">while</span> [ -n <span class="string">&quot;<span class="variable">$X</span>&quot;</span> ]</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;Enter some text (RETURN to quit)&quot;</span></span><br><span class="line">  <span class="built_in">read</span> X</span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;You said: <span class="variable">$X</span>&quot;</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>
<hr>
<p>This code will keep asking for input until you hit RETURN (X is zero length). Thanks to Justin Heath for pointing out that the script didn’t work - I’d missed out the quotes around $X in the <code>while [ -n &quot;$X&quot; ]</code>. Without those quotes, there is nothing to test when $X is empty.<br>Alexander Weber has pointed out that running this script will end untidily:</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ ./test2.sh</span><br><span class="line">Enter some text (RETURN to quit)</span><br><span class="line">fred</span><br><span class="line">You said: fred</span><br><span class="line">Enter some text (RETURN to quit)</span><br><span class="line">wilma</span><br><span class="line">You said: wilma</span><br><span class="line">Enter some text (RETURN to quit)</span><br><span class="line"></span><br><span class="line">You said:</span><br><span class="line">$ </span><br></pre></td></tr></table></figure>
<p>This can be tidied up with another test within the loop:</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line">X=0</span><br><span class="line"><span class="keyword">while</span> [ -n <span class="string">&quot;<span class="variable">$X</span>&quot;</span> ]</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;Enter some text (RETURN to quit)&quot;</span></span><br><span class="line">  <span class="built_in">read</span> X</span><br><span class="line">  <span class="keyword">if</span> [ -n <span class="string">&quot;<span class="variable">$X</span>&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;You said: <span class="variable">$X</span>&quot;</span></span><br><span class="line">  <span class="keyword">fi</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>
<p>Note also that I’ve used two different syntaxes for <code>if</code> statements on this page. These are:</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$X</span>&quot;</span> -lt <span class="string">&quot;0&quot;</span> ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;X is less than zero&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">..........  and  ........</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ -n <span class="string">&quot;<span class="variable">$X</span>&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;You said: <span class="variable">$X</span>&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>
<p>You must have a break between the <code>if</code> statement and the <code>then</code> construct. This can be a semicolon or a newline, it doesn’t matter which, but there must be one or the other between the <code>if</code> and the <code>then</code>. It would be nice to just say:</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> [ -n <span class="string">&quot;<span class="variable">$X</span>&quot;</span> ]</span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;You said: <span class="variable">$X</span>&quot;</span></span><br></pre></td></tr></table></figure>
<p>but the <code>then</code> and <code>fi</code> are absolutely required.</p>
<h1 id="Summary-of-special-symbols"><a href="#Summary-of-special-symbols" class="headerlink" title="Summary of special symbols"></a>Summary of special symbols</h1><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/kevingrace/p/5896386.html">See this!</a></p>
<h1 id="Case"><a href="#Case" class="headerlink" title="Case"></a>Case</h1><p>The <code>case</code> statement saves going through a whole set of <code>if .. then .. else</code> statements. Its syntax is really quite simple:</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Please talk to me ...&quot;</span></span><br><span class="line"><span class="keyword">while</span> :</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">  <span class="built_in">read</span> INPUT_STRING</span><br><span class="line">  <span class="keyword">case</span> <span class="variable">$INPUT_STRING</span> <span class="keyword">in</span></span><br><span class="line">	hello)</span><br><span class="line">		<span class="built_in">echo</span> <span class="string">&quot;Hello yourself!&quot;</span></span><br><span class="line">		;;</span><br><span class="line">	<span class="built_in">bye</span>)</span><br><span class="line">		<span class="built_in">echo</span> <span class="string">&quot;See you again!&quot;</span></span><br><span class="line">		<span class="built_in">break</span></span><br><span class="line">		;;</span><br><span class="line">	*)</span><br><span class="line">		<span class="built_in">echo</span> <span class="string">&quot;Sorry, I don&#x27;t understand&quot;</span></span><br><span class="line">		;;</span><br><span class="line">  <span class="keyword">esac</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"><span class="built_in">echo</span> </span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;That&#x27;s all folks!&quot;</span></span><br></pre></td></tr></table></figure>
<p>Okay, so it’s not the best conversationalist in the world; it’s only an example!</p>
<p>Try running it and check how it works…</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ ./talk.sh</span><br><span class="line">Please talk to me ...</span><br><span class="line">hello</span><br><span class="line">Hello yourself!</span><br><span class="line">What <span class="keyword">do</span> you think of politics?</span><br><span class="line">Sorry, I don<span class="string">&#x27;t understand</span></span><br><span class="line"><span class="string">bye</span></span><br><span class="line"><span class="string">See you again!</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">That&#x27;</span>s all folks!</span><br></pre></td></tr></table></figure>
<p>The syntax is quite simple:</p>
<p>The <code>case</code> line itself is always of the same format, and it means that we are testing the value of the variable <code>INPUT_STRING</code>.</p>
<p>The options we understand are then listed and followed by a right bracket, as <code>hello)</code> and <code>bye)</code>.</p>
<p>This means that if <code>INPUT_STRING</code> matches <code>hello</code> then that section of code is executed, up to the double semicolon.</p>
<p>If <code>INPUT_STRING</code> matches <code>bye</code> then the goodbye message is printed and the loop exits. Note that if we wanted to exit the script completely then we would use the command <code>exit</code> instead of <code>break</code>.<br>The third option here, the <code>*)</code>, is the default catch-all condition; it is not required but is often useful for debugging purposes even if we think we know what values the test variable will have.</p>
<p>The whole case statement is ended with <code>esac</code> (case backwards!) then we end the while loop with a <code>done</code>.</p>
<p>That’s about as complicated as <code>case</code> conditions get, but they can be a very useful and powerful tool. They are often used to parse the parameters passed to a shell script, amongst other uses.</p>
<h1 id="Variables-Part-II"><a href="#Variables-Part-II" class="headerlink" title="Variables - Part II"></a>Variables - Part II</h1><p>There are a set of variables which are set for you already, and most of these cannot have values assigned to them.<br>These can contain useful information, which can be used by the script to know about the environment in which it is running.</p>
<p>The first set of variables we will look at are <code>$0 .. $9</code> and <code>$#</code>.</p>
<p>The variable <code>$0</code> is the <em>basename</em> of the program as it was called.</p>
<p><code>$1 .. $9</code> are the first 9 additional parameters the script was called with.</p>
<p>The variable <code>$@</code> is all parameters <code>$1 ..</code> whatever. The variable <code>$*</code>, is similar, but does not preserve any whitespace, and quoting, so “File with spaces” becomes “File” “with” “spaces”. This is similar to the <code>echo</code> stuff we looked at in <a target="_blank" rel="noopener" href="https://www.shellscript.sh/first.html">A First Script</a>. As a general rule, use <code>$@</code> and avoid <code>$*</code>.</p>
<p><code>$#</code> is the number of parameters the script was called with.</p>
<p>Let’s take an example script:</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;I was called with <span class="variable">$#</span> parameters&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;My name is <span class="variable">$0</span>&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;My first parameter is <span class="variable">$1</span>&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;My second parameter is <span class="variable">$2</span>&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;All parameters are <span class="variable">$@</span>&quot;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ /home/steve/var3.sh</span><br><span class="line">I was called with 0 parameters</span><br><span class="line">My name is /home/steve/var3.sh</span><br><span class="line">My first parameter is</span><br><span class="line">My second parameter is    </span><br><span class="line">All parameters are </span><br><span class="line">$</span><br><span class="line">$ ./var3.sh hello world earth</span><br><span class="line">I was called with 3 parameters</span><br><span class="line">My name is ./var3.sh</span><br><span class="line">My first parameter is hello</span><br><span class="line">My second parameter is world</span><br><span class="line">All parameters are hello world earth</span><br></pre></td></tr></table></figure>
<p>Note that the value of <code>$0</code> changes depending on how the script was called. The external utility <code>basename</code> can help tidy this up:</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;My name is `basename <span class="variable">$0</span>`&quot;</span></span><br></pre></td></tr></table></figure>
<p><code>$#</code> and <code>$1 .. $9</code> are set automatically by the shell.</p>
<p>We can take more than 9 parameters by using the <code>shift</code> command; look at the script below:</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"><span class="keyword">while</span> [ <span class="string">&quot;<span class="variable">$#</span>&quot;</span> -gt <span class="string">&quot;0&quot;</span> ]</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;\$1 is <span class="variable">$1</span>&quot;</span></span><br><span class="line">  <span class="built_in">shift</span></span><br><span class="line"><span class="keyword">done</span>  </span><br></pre></td></tr></table></figure>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">&gt; ./first.sh a b c d f e r t y u i o g gh h s d gh g</span><br><span class="line"><span class="variable">$1</span> is a</span><br><span class="line"><span class="variable">$1</span> is b</span><br><span class="line"><span class="variable">$1</span> is c</span><br><span class="line"><span class="variable">$1</span> is d</span><br><span class="line"><span class="variable">$1</span> is f</span><br><span class="line"><span class="variable">$1</span> is e</span><br><span class="line"><span class="variable">$1</span> is r</span><br><span class="line"><span class="variable">$1</span> is t</span><br><span class="line"><span class="variable">$1</span> is y</span><br><span class="line"><span class="variable">$1</span> is u</span><br><span class="line"><span class="variable">$1</span> is i</span><br><span class="line"><span class="variable">$1</span> is o</span><br><span class="line"><span class="variable">$1</span> is g</span><br><span class="line"><span class="variable">$1</span> is gh</span><br><span class="line"><span class="variable">$1</span> is h</span><br><span class="line"><span class="variable">$1</span> is s</span><br><span class="line"><span class="variable">$1</span> is d</span><br><span class="line"><span class="variable">$1</span> is gh</span><br><span class="line"><span class="variable">$1</span> is g</span><br></pre></td></tr></table></figure>
<p>This script keeps on using <code>shift</code> until <code>$#</code> is down to zero, at which point the list is empty.</p>
<p>Another special variable is <code>$?</code>. This contains the exit value of the last run command. So the code:</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line">/usr/<span class="built_in">local</span>/bin/my-command</span><br><span class="line"><span class="keyword">if</span> [ <span class="string">&quot;$?&quot;</span> -ne <span class="string">&quot;0&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;Sorry, we had a problem there!&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>
<p>will attempt to run <code>/usr/local/bin/my-command</code> which should exit with a value of zero if all went well, or a nonzero value on failure. We can then handle this by checking the value of <code>$?</code> after calling the command. This helps make scripts robust and more intelligent.</p>
<p>Well-behaved applications should return zero on success. Hence the quote:</p>
<blockquote>
<p> One of the main causes of the fall of the Roman Empire was that,  lacking zero, they had no way to indicate successful termination of their C Programs. (Robert Firth)</p>
</blockquote>
<p>The other two main variables set for you by the environment are <code>$$</code> and <code>$!</code>. These are both process numbers.</p>
<p>The <code>$$</code> variable is the PID (Process IDentifier) of the currently running shell. This can be useful for creating temporary files, such as <code>/tmp/my-script.$$</code> which is useful if many instances of the script could be run at the same time, and they all need their own temporary files.</p>
<p>The <code>$!</code> variable is the PID of the last run background process. This is useful to keep track of the process as it gets on with its job.</p>
<p>Another interesting variable is <code>IFS</code>. This is the <em>Internal Field Separator</em>. The default value is <code>SPACE TAB NEWLINE</code>, but if you are changing it, it’s easier to take a copy, as shown:</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line">old_IFS=<span class="string">&quot;<span class="variable">$IFS</span>&quot;</span></span><br><span class="line">IFS=:</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Please input some data separated by colons ...&quot;</span></span><br><span class="line"><span class="built_in">read</span> x y z</span><br><span class="line">IFS=<span class="variable">$old_IFS</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;x is <span class="variable">$x</span> y is <span class="variable">$y</span> z is <span class="variable">$z</span>&quot;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ ./ifs.sh</span><br><span class="line">Please input some data separated by colons ...</span><br><span class="line">hello:how are you:today</span><br><span class="line">x is hello y is how are you z is today</span><br></pre></td></tr></table></figure>
<p>Note that if you enter: “hello:how are you:today:my:friend” then the output would be:</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ ./ifs.sh</span><br><span class="line">Please input some data separated by colons ...</span><br><span class="line">hello:how are you:today:my:friend</span><br><span class="line">x is hello y is how are you z is today:my:friend</span><br></pre></td></tr></table></figure>
<p>It is important when dealing with IFS in particular (but any variable not entirely under your control) to realise that it could contain spaces, newlines and other “uncontrollable” characters. It is therefore a very good idea to use double-quotes around it, ie: <code>old_IFS=&quot;$IFS&quot;</code> instead of <code>old_IFS=$IFS</code>.</p>
<h1 id="Variables-Part-III"><a href="#Variables-Part-III" class="headerlink" title="Variables - Part III"></a>Variables - Part III</h1><p>As we mentioned in <a target="_blank" rel="noopener" href="https://www.shellscript.sh/variables1.html">Variables - Part I</a>, curly brackets around a variable avoid confusion:</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">foo=sun</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$fooshine</span>     <span class="comment"># $fooshine is undefined</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;foo&#125;</span>shine   <span class="comment"># displays the word &quot;sunshine&quot;</span></span><br></pre></td></tr></table></figure>
<p>That’s not all, though - these fancy brackets have a another, much more powerful use. We can deal with issues of variables being undefined or null (in the shell, there’s not much difference between undefined and null).</p>
<h4 id="Using-Default-Values"><a href="#Using-Default-Values" class="headerlink" title="Using Default Values"></a>Using Default Values</h4><p>Consider the following code snippet which prompts the user for input, but accepts defaults:</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"><span class="built_in">echo</span> -en <span class="string">&quot;What is your name [ `whoami` ] &quot;</span></span><br><span class="line"><span class="built_in">read</span> myname</span><br><span class="line"><span class="keyword">if</span> [ -z <span class="string">&quot;<span class="variable">$myname</span>&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">  myname=`whoami`</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Your name is : <span class="variable">$myname</span>&quot;</span></span><br></pre></td></tr></table></figure>
<p>Passing the “<code>-en</code>“ to echo tells it not to add a linebreak (for bash and csh). For Dash, Bourne and other compliant shells, you use a “<code>\c</code>“ at the end of the line, instead. Ksh understands both forms. (note: see <a target="_blank" rel="noopener" href="https://www.shellscript.sh/echo.html">/echo.html</a> for a note on different implementations - particularly Dash/Bourne vs Bash)</p>
<p>This script runs like this if you accept the default by pressing “RETURN”:</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">&gt; ./first.sh</span><br><span class="line">-en What is your name [ zhaochen20 ]</span><br><span class="line">zcy</span><br><span class="line">Your name is : zcy</span><br><span class="line">&gt; ./first.sh</span><br><span class="line">-en What is your name [ zhaochen20 ]</span><br><span class="line"></span><br><span class="line">Your name is : zhaochen20</span><br></pre></td></tr></table></figure>
<p>This could be done better using a shell variable feature. By using curly braces and the special “:-“ usage, you can specify a default value to use if the variable is unset:</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> -en <span class="string">&quot;What is your name [ `whoami` ] &quot;</span></span><br><span class="line"><span class="built_in">read</span> myname</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Your name is : <span class="variable">$&#123;myname:-`whoami`&#125;</span>&quot;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">&gt; ./first.sh</span><br><span class="line">-en What is your name [ zhaochen20 ]</span><br><span class="line"></span><br><span class="line">Your name is : zhaochen20</span><br><span class="line">&gt; ./first.sh</span><br><span class="line">-en What is your name [ zhaochen20 ]</span><br><span class="line">willson</span><br><span class="line">Your name is : willson</span><br></pre></td></tr></table></figure>
<p>This could be considered a special case - we’re using the output of the whoami command, which prints your login name (UID). The more canonical example is to use fixed text, like this:</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Your name is : <span class="variable">$&#123;myname:-John Doe&#125;</span>&quot;</span></span><br></pre></td></tr></table></figure>
<p>As with other use of the backticks, <code>whoami</code> runs in a subshell, so any <code>cd</code> commands, or setting any other variables, within the backticks, will not affect the currently-running shell.</p>
<h4 id="Using-and-Setting-Default-Values"><a href="#Using-and-Setting-Default-Values" class="headerlink" title="Using and Setting Default Values"></a>Using and Setting Default Values</h4><p>There is another syntax, “:=”, which sets the variable to the default if it is undefined:</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Your name is : <span class="variable">$&#123;myname:=John Doe&#125;</span>&quot;</span></span><br></pre></td></tr></table></figure>
<p>This technique means that any subsequent access to the <code>$myname</code> variable will always get a value, either entered by the user, or “John Doe” otherwise.</p>
<h1 id="External-Programs"><a href="#External-Programs" class="headerlink" title="External Programs"></a>External Programs</h1><p>External programs are often used within shell scripts; there are a few builtin commands (<code>echo</code>, <code>which</code>, and <code>test</code> are commonly builtin), but many useful commands are actually Unix utilities, such as <code>tr</code>, <code>grep</code>, <code>expr</code> and <code>cut</code>.</p>
<p>The backtick (`)is also often associated with external commands. Because of this, we will discuss the backtick first.<br>The backtick is used to indicate that the enclosed text is to be executed as a command. This is quite simple to understand. First, use an interactive shell to read your full name from <code>/etc/passwd</code>:</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ grep <span class="string">&quot;^<span class="variable">$&#123;USER&#125;</span>:&quot;</span> /etc/passwd | cut -d: -f5</span><br><span class="line">Steve Parker</span><br></pre></td></tr></table></figure>
<p>Now we will grab this output into a variable which we can manipulate more easily:</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ MYNAME=`grep <span class="string">&quot;^<span class="variable">$&#123;USER&#125;</span>:&quot;</span> /etc/passwd | cut -d: -f5`</span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">$MYNAME</span></span><br><span class="line">Steve Parker</span><br></pre></td></tr></table></figure>
<p>So we see that the backtick simply catches the standard output from any command or set of commands we choose to run. It can also improve performance if you want to run a slow command or set of commands and parse various bits of its output:</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line">find / -name <span class="string">&quot;*.html&quot;</span> -<span class="built_in">print</span> | grep <span class="string">&quot;/index.html$&quot;</span></span><br><span class="line">find / -name <span class="string">&quot;*.html&quot;</span> -<span class="built_in">print</span> | grep <span class="string">&quot;/contents.html$&quot;</span></span><br></pre></td></tr></table></figure>
<hr>
<p>This code could take a long time to run, and we are doing it twice!<br>A better solution is:</p>
<hr>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line">HTML_FILES=`find / -name <span class="string">&quot;*.html&quot;</span> -<span class="built_in">print</span>`</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$HTML_FILES</span>&quot;</span> | grep <span class="string">&quot;/index.html$&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$HTML_FILES</span>&quot;</span> | grep <span class="string">&quot;/contents.html$&quot;</span></span><br></pre></td></tr></table></figure>
<p>Note: the quotes around <code>$HTML_FILES</code> are essential to preserve the newlines between each file listed. Otherwise, <code>grep</code> will see one huge long line of text, and not one line per file.</p>
<p>This way, we are only running the slow <code>find</code> once, roughly halving the execution time of the script.</p>
<p>We discuss specific examples further in the <a target="_blank" rel="noopener" href="https://www.shellscript.sh/hints.html">Hints and Tips</a> section of this tutorial.</p>
<h1 id="Functions"><a href="#Functions" class="headerlink" title="Functions"></a>Functions</h1><p>One often-overlooked feature of Bourne shell script programming is that you can easily write functions for use within your script. This is generally done in one of two ways; with a simple script, the function is simply declared in the same file as it is called.<br>However, when writing a suite of scripts, it is often easier to write a “library” of useful functions, and source that file at the start of the other scripts which use the functions. This will be shown <a target="_blank" rel="noopener" href="https://www.shellscript.sh/functions.html#libraries">later</a>.<br>The method is the same however it is done; we will primarily be using the first way here. The second (library) method is basically the same, except that the command</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">. ./library.sh</span><br></pre></td></tr></table></figure>
<p>goes at the start of the script.</p>
<p>There could be some confusion about whether to call shell functions <em>procedures</em> or <em>functions</em>; the definition of a function is traditionally that it returns a single value, and does not output anything. A procedure, on the other hand, does not return a value, but may produce output. A shell function may do neither, either or both. It is generally accepted that in shell scripts they are called functions.</p>
<p>A function may return a value in one of four different ways:</p>
<ul>
<li>Change the state of a variable or variables</li>
<li>Use the <code>exit</code> command to end the shell script</li>
<li>Use the <code>return</code> command to end the function, and return the supplied value to the calling section of the shell script</li>
<li>echo output to stdout, which will be caught by the caller just as c=<code>expr $a + $b</code> is caught</li>
</ul>
<p>This is rather like C, in that <code>exit</code> stops the program, and <code>return</code> returns control to the caller. The difference is that a shell function cannot change its parameters, though it can change global parameters.</p>
<p>A simple script using a function would look like this:</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"><span class="comment"># A simple script with a function...</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">add_a_user</span></span>()</span><br><span class="line">&#123;</span><br><span class="line">  USER=<span class="variable">$1</span></span><br><span class="line">  PASSWORD=<span class="variable">$2</span></span><br><span class="line">  <span class="built_in">shift</span>; <span class="built_in">shift</span>;</span><br><span class="line">  <span class="comment"># Having shifted twice, the rest is now comments ...</span></span><br><span class="line">  COMMENTS=<span class="variable">$@</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;Adding user <span class="variable">$USER</span> ...&quot;</span></span><br><span class="line">  <span class="built_in">echo</span> useradd -c <span class="string">&quot;<span class="variable">$COMMENTS</span>&quot;</span> <span class="variable">$USER</span></span><br><span class="line">  <span class="built_in">echo</span> passwd <span class="variable">$USER</span> <span class="variable">$PASSWORD</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;Added user <span class="variable">$USER</span> (<span class="variable">$COMMENTS</span>) with pass <span class="variable">$PASSWORD</span>&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">###</span></span><br><span class="line"><span class="comment"># Main body of script starts here</span></span><br><span class="line"><span class="comment">###</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Start of script...&quot;</span></span><br><span class="line">add_a_user bob letmein Bob Holness the presenter</span><br><span class="line">add_a_user fred badpassword Fred Durst the singer</span><br><span class="line">add_a_user bilko worsepassword Sgt. Bilko the role model</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;End of script...&quot;</span></span><br></pre></td></tr></table></figure>
<p>Line 4 identifies itself as a function declaration by ending in (). This is followed by <code>&#123;</code>, and everything following to the matching <code>&#125;</code> is taken to be the code of that function.<br>This code is <em>not executed</em> until the function is called. Functions are read in, but basically ignored until they are actually called.</p>
<p>Note that for this example the <code>useradd</code> and <code>passwd</code> commands have been prefixed with <code>echo</code> - this is a useful debugging technique to check that the right commands would be executed. It also means that you can run the script without being root or adding dodgy user accounts to your system!</p>
<p>We have been used to the idea that a shell script is executed sequentially. This is not so with functions.</p>
<p>In this case, the function <code>add_a_user</code> is read in and checked for syntax, but not executed until it is explicitly called. This is where the <a target="_blank" rel="noopener" href="http://steve-parker.org/articles/shellshock/">Shellshock</a> bug of 2014 comes into play. Other commands after the function definition were executed, even though they were not part of the function itself. See <a target="_blank" rel="noopener" href="http://steve-parker.org/articles/shellshock/">http://steve-parker.org/articles/shellshock/</a> for more information on this.</p>
<p>Execution starts with the <code>echo</code> statement “Start of script…”. The next line, <code>add_a_user bob letmein Bob Holness</code> is recognised as a function call so the <code>add_a_user</code> function is entered and starts executing with certain additions to the environment:</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="variable">$1</span>=bob</span><br><span class="line"><span class="variable">$2</span>=letmein</span><br><span class="line"><span class="variable">$3</span>=Bob</span><br><span class="line"><span class="variable">$4</span>=Holness</span><br><span class="line"><span class="variable">$5</span>=the</span><br><span class="line"><span class="variable">$6</span>=presenter</span><br></pre></td></tr></table></figure>
<p>So within that function, <code>$1</code> is set to <code>bob</code>, regardless of what <code>$1</code> may be set to outside of the function.<br>So if we want to refer to the “original” $1 <em>inside</em> the function, we have to assign a name to it - such as: <code>A=$1</code> before we call the function. Then, within the function, we can refer to <code>$A</code>.<br>We use the <code>shift</code> command again to get the <code>$3</code> and onwards parameters into <code>$@</code>. The function then adds the user and sets their password. It <code>echo</code>es a comment to that effect, and returns control to the next line of the main code.</p>
<h2 id="Scope-of-Variables-1"><a href="#Scope-of-Variables-1" class="headerlink" title="Scope of Variables"></a>Scope of Variables</h2><p>Programmers used to other languages may be surprised at the scope rules for shell functions. Basically, there is no scoping, other than the parameters (<code>$1</code>, <code>$2</code>, <code>$@</code>, etc).<br>Taking the following simple code segment:</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">myfunc</span></span>()</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;I was called as : <span class="variable">$@</span>&quot;</span></span><br><span class="line">  x=2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">### Main script starts here </span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Script was called with <span class="variable">$@</span>&quot;</span></span><br><span class="line">x=1</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;x is <span class="variable">$x</span>&quot;</span></span><br><span class="line">myfunc 1 2 3</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;x is <span class="variable">$x</span>&quot;</span></span><br></pre></td></tr></table></figure>
<p>The script, when called as <code>scope.sh a b c</code>, gives the following output:</p>
<hr>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">Script was called with a b c</span><br><span class="line">x is 1</span><br><span class="line">I was called as : 1 2 3</span><br><span class="line">x is 2</span><br></pre></td></tr></table></figure>
<p>The <code>$@</code> parameters are changed within the function to reflect how the function was called. The variable <code>x</code>, however, is effectively a global variable - <code>myfunc</code> changed it, and that change is still effective when control returns to the main script.</p>
<p>A function will be called in a sub-shell if its output is piped somewhere else - that is, “<code>myfunc 1 2 3 | tee out.log</code>“ will still say “x is 1” the second time around. This is because a new shell process is called to pipe <code>myfunc()</code>. This can make debugging very frustrating; Astrid had a script which suddenly failed when the “<code>| tee</code>“ was added, and it is not immediately obvious why this must be. The <code>tee</code> has to be started up before the function to the left of the pipe; with the simple example of “<code>ls | grep foo</code>“, then <code>grep</code> has to be started first, with its <code>stdin</code> then tied to the <code>stdout</code> of <code>ls</code> once <code>ls</code> starts. In the shell script, the shell has already been started before we even knew we were going to pipe through <code>tee</code>, so the operating system has to start <code>tee</code>, then start a new shell to call <code>myfunc()</code>. This is frustrating, but well worth being aware of.</p>
<p>Functions cannot change the values they have been called with, either - this must be done by changing the variables themselves, not the parameters as passed to the script.</p>
<p>An example shows this more clearly:</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">myfunc</span></span>()</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;\$1 is <span class="variable">$1</span>&quot;</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;\$2 is <span class="variable">$2</span>&quot;</span></span><br><span class="line">  <span class="comment"># cannot change $1 - we&#x27;d have to say:</span></span><br><span class="line">  <span class="comment"># 1=&quot;Goodbye Cruel&quot;</span></span><br><span class="line">  <span class="comment"># which is not a valid syntax. However, we can</span></span><br><span class="line">  <span class="comment"># change $a:</span></span><br><span class="line">  a=<span class="string">&quot;Goodbye Cruel&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">### Main script starts here </span></span><br><span class="line"></span><br><span class="line">a=Hello</span><br><span class="line">b=World</span><br><span class="line">myfunc <span class="variable">$a</span> <span class="variable">$b</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;a is <span class="variable">$a</span>&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;b is <span class="variable">$b</span>&quot;</span></span><br></pre></td></tr></table></figure>
<p>This rather cynical function changes $a, so the message “Hello World” becomes “Goodbye Cruel World”.</p>
<h2 id="Recursion"><a href="#Recursion" class="headerlink" title="Recursion"></a>Recursion</h2><p>Functions can be recursive - here’s a simple example of a factorial function:</p>
<hr>
<p><a target="_blank" rel="noopener" href="https://www.shellscript.sh/eg/factorial.sh.txt">factorial.sh</a></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">factorial</span></span>()</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$1</span>&quot;</span> -gt <span class="string">&quot;1&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">    i=`expr <span class="variable">$1</span> - 1`</span><br><span class="line">    j=`factorial <span class="variable">$i</span>`</span><br><span class="line">    k=`expr <span class="variable">$1</span> \* <span class="variable">$j</span>`</span><br><span class="line">    <span class="built_in">echo</span> <span class="variable">$k</span></span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="built_in">echo</span> 1</span><br><span class="line">  <span class="keyword">fi</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> :</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;Enter a number:&quot;</span></span><br><span class="line">  <span class="built_in">read</span> x</span><br><span class="line">  factorial <span class="variable">$x</span></span><br><span class="line"><span class="keyword">done</span>                      </span><br></pre></td></tr></table></figure>
<hr>
<p>As promised, we will now briefly discuss using libraries between shell scripts. These can also be used to define common variables, as we shall see.</p>
<hr>
<p><a target="_blank" rel="noopener" href="https://www.shellscript.sh/eg/common.lib.txt">common.lib</a></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># common.lib</span></span><br><span class="line"><span class="comment"># Note no #!/bin/sh as this should not spawn </span></span><br><span class="line"><span class="comment"># an extra shell. It&#x27;s not the end of the world </span></span><br><span class="line"><span class="comment"># to have one, but clearer not to.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">STD_MSG=<span class="string">&quot;About to rename some files...&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">rename</span></span>()</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment"># expects to be called as: rename .txt .bak </span></span><br><span class="line">  FROM=<span class="variable">$1</span></span><br><span class="line">  TO=<span class="variable">$2</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> i <span class="keyword">in</span> *<span class="variable">$FROM</span></span><br><span class="line">  <span class="keyword">do</span></span><br><span class="line">    j=`basename <span class="variable">$i</span> <span class="variable">$FROM</span>`</span><br><span class="line">    mv <span class="variable">$i</span> <span class="variable">$&#123;j&#125;</span><span class="variable">$TO</span></span><br><span class="line">  <span class="keyword">done</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p><a target="_blank" rel="noopener" href="https://www.shellscript.sh/eg/function2.sh.txt">function2.sh</a></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"><span class="comment"># function2.sh</span></span><br><span class="line">. ./common.lib</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$STD_MSG</span></span><br><span class="line">rename .txt .bak</span><br></pre></td></tr></table></figure>
<hr>
<p><a target="_blank" rel="noopener" href="https://www.shellscript.sh/eg/function3.sh.txt">function3.sh</a></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"><span class="comment"># function3.sh</span></span><br><span class="line">. ./common.lib</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$STD_MSG</span></span><br><span class="line">rename .html .html-bak</span><br></pre></td></tr></table></figure>
<hr>
<p>Here we see two user shell scripts, <code>function2.sh</code> and <code>function3.sh</code>, each <em>source</em>ing the common library file <code>common.lib</code>, and using variables and functions declared in that file.</p>
<p>This is nothing too earth-shattering, just an example of how code reuse can be done in shell programming.</p>
<h2 id="Return-Codes"><a href="#Return-Codes" class="headerlink" title="Return Codes"></a>Return Codes</h2><p>For details about exit codes, see the <a target="_blank" rel="noopener" href="https://www.shellscript.sh/exitcodes.html">Exit Codes</a> part of the <a target="_blank" rel="noopener" href="https://www.shellscript.sh/hints.html">Hints and Tips</a> section of the tutorial. For now, though we shall briefly look at the <code>return</code> call.</p>
<hr>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">adduser</span></span>()</span><br><span class="line">&#123;</span><br><span class="line">  USER=<span class="variable">$1</span></span><br><span class="line">  PASSWORD=<span class="variable">$2</span></span><br><span class="line">  <span class="built_in">shift</span> ; <span class="built_in">shift</span></span><br><span class="line">  COMMENTS=<span class="variable">$@</span></span><br><span class="line">  useradd -c <span class="string">&quot;<span class="variable">$&#123;COMMENTS&#125;</span>&quot;</span> <span class="variable">$USER</span></span><br><span class="line">  <span class="keyword">if</span> [ <span class="string">&quot;$?&quot;</span> -ne <span class="string">&quot;0&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;Useradd failed&quot;</span></span><br><span class="line">    <span class="built_in">return</span> 1</span><br><span class="line">  <span class="keyword">fi</span></span><br><span class="line">  passwd <span class="variable">$USER</span> <span class="variable">$PASSWORD</span></span><br><span class="line">  <span class="keyword">if</span> [ <span class="string">&quot;$?&quot;</span> -ne <span class="string">&quot;0&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;Setting password failed&quot;</span></span><br><span class="line">    <span class="built_in">return</span> 2</span><br><span class="line">  <span class="keyword">fi</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;Added user <span class="variable">$USER</span> (<span class="variable">$COMMENTS</span>) with pass <span class="variable">$PASSWORD</span>&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">## Main script starts here</span></span><br><span class="line"></span><br><span class="line">adduser bob letmein Bob Holness from Blockbusters</span><br><span class="line">ADDUSER_RETURN_CODE=$?</span><br><span class="line"><span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$ADDUSER_RETURN_CODE</span>&quot;</span> -eq <span class="string">&quot;1&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;Something went wrong with useradd&quot;</span></span><br><span class="line"><span class="keyword">elif</span> [ <span class="string">&quot;<span class="variable">$ADDUSER_RETURN_CODE</span>&quot;</span> -eq <span class="string">&quot;2&quot;</span> ]; <span class="keyword">then</span> </span><br><span class="line">   <span class="built_in">echo</span> <span class="string">&quot;Something went wrong with passwd&quot;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;Bob Holness added to the system.&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>
<hr>
<p>This script checks the two external calls it makes (<code>useradd</code> and <code>passwd</code>), and lets the user know if they fail. The function then defines a return code of 1 to indicate any problem with <code>useradd</code>, and 2 to indicate any problem with <code>passwd</code>. That way, the calling script knows where the problem lay.</p>
<p>For a long time, this tutorial checked “$?” both times, rather than setting <code>ADDUSER_RETURN_CODE=$?</code>, and then looking at the value of <code>ADDUSER_RETURN_CODE</code> each time. This was a bug (thanks to Elyza for pointing it out). You have to save <code>$?</code>, because as soon as you run another command, such as <code>if</code>, its value will be replaced. That is why we save the <code>adduser</code> return value in the <code>$ADDUSER_RETURN_CODE</code> variable, before acting on its content. <code>$ADDUSER_RETURN_CODE</code> is certain to remain the same; <code>$?</code> will change with every command that is executed.</p>
<h1 id="Hints-and-Tips"><a href="#Hints-and-Tips" class="headerlink" title="Hints and Tips"></a>Hints and Tips</h1><hr>
<p>Check out <a target="_blank" rel="noopener" href="https://www.shellscript.sh/tips/">www.shellscript.sh/tips/</a> for some more up-to-date tips and hints</p>
<p>The content below is, to be honest, rather outdated. <a target="_blank" rel="noopener" href="https://www.shellscript.sh/tips/">the /tips part of this website has more, and more usable, tips.</a></p>
<hr>
<p>Unix is full of text manipulating utilities, some of the more powerful of which we will now discuss in this section of this tutorial. The significance of this, is that virtually everything under Unix <em>is</em> text. Virtually anything you can think of is controlled by either a text file, or by a command-line-interface (CLI). The only thing you can’t automate using a shell script is a GUI-only utility or feature. And under Unix, there aren’t too many of them!</p>
<p>You may have heard it said, that, with *nix, “everything is a file” - it’s true.</p>
<p>We have a few subsections here … what follows is general advice, hints and tips.</p>
<p><a target="_blank" rel="noopener" href="https://www.shellscript.sh/cgi.html">CGI Scripting</a></p>
<p><a target="_blank" rel="noopener" href="https://www.shellscript.sh/exitcodes.html">Exit Codes and flow control</a></p>
<p><a target="_blank" rel="noopener" href="https://www.shellscript.sh/expect.html">Simple <em>Expect</em> replacement</a></p>
<p><a target="_blank" rel="noopener" href="https://www.shellscript.sh/trap.html">Using <em>trap</em></a> to know when you’ve been interrupted - such as a CTRL-C, etc.</p>
<p><a target="_blank" rel="noopener" href="https://www.shellscript.sh/echo.html">Workaround for the ‘echo -n’ vs ‘echo \c’ dichotomy</a></p>
<p><a target="_blank" rel="noopener" href="https://www.shellscript.sh/speedtouchconf.html">Documented Example</a> of a real-life script I wrote - it helps users configure a SpeedTouch modem, and is available at <a target="_blank" rel="noopener" href="http://speedtouchconf.sourceforge.net/">http://speedtouchconf.sourceforge.net/</a>.</p>
<p>We have already shown above a use of the simple but effective <code>cut</code> command. We shall discuss a few examples here some of the more common external programs to be used.</p>
<p><code>grep</code> is an extremely useful utility for the shell script programmer.<br>An example of grep would be:</p>
<hr>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line">steves=`grep -i steve /etc/passwd | cut -d: -f1`</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;All users with the word \&quot;steve\&quot; in their passwd&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Entries are: <span class="variable">$steves</span>&quot;</span></span><br></pre></td></tr></table></figure>
<hr>
<p>This script looks fine if there’s only one match. However, if there are two lines in /etc/passwd with the word “steve” in them, then the interactive shell will display:</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$&gt; grep -i steve /etc/passwd </span><br><span class="line">steve:x:5062:509:Steve Parker:/home/steve:/bin/bash</span><br><span class="line">fred:x:5068:512:Fred Stevens:/home/fred:/bin/bash</span><br><span class="line">$&gt; grep -i steve /etc/passwd |cut -d: -f1</span><br><span class="line">steve</span><br><span class="line">fred</span><br></pre></td></tr></table></figure>
<p>But the script will display:</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">Entries are: steve fred</span><br></pre></td></tr></table></figure>
<p>By putting the result into a variable we have changed the NEWLINEs into spaces; the <code>sh</code> manpage tells us that the first character in <code>$IFS</code> will be used for this purpose. IFS is <space><tab><cr> by default. Maybe though we wanted to keep the NEWLINEs: It could look better if we made the spaces into NEWLINEs…. This is a job for <code>tr</code>:</p>
<hr>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line">steves=`grep -i steve /etc/passwd | cut -d: -f1`</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;All users with the word \&quot;steve\&quot; in their passwd&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Entries are: &quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$steves</span>&quot;</span> | tr <span class="string">&#x27; &#x27;</span> <span class="string">&#x27;\012&#x27;</span></span><br></pre></td></tr></table></figure>
<hr>
<p>Note that <code>tr</code> translated the spaces into octal character 012 (NEWLINE).<br>Another common use of <code>tr</code> is its use of range… it can convert text to upper or lower case, for example:</p>
<hr>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line">steves=`grep -i steve /etc/passwd | cut -d: -f1`</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;All users with the word &quot;</span>steve<span class="string">&quot; in their passwd&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Entries are: &quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$steves</span>&quot;</span> | tr <span class="string">&#x27; &#x27;</span> <span class="string">&#x27;\012&#x27;</span> | tr <span class="string">&#x27;[a-z]&#x27;</span> <span class="string">&#x27;[A-Z]&#x27;</span></span><br></pre></td></tr></table></figure>
<hr>
<p>Here we have added a translation of [a-z] to [A-Z]. Note that there are exactly the same number of values in the range a-z as A-Z. This can then translate any character falling into the ASCII range a-z into A-Z … in other words, converting lowercase letters into uppercase. <code>tr</code> is actually cleverer than this: <code>tr [:lower:] [:upper:]</code> would do the job just as well, and possibly more readably. It’s also not as portable; not every <code>tr</code> can do this.</p>
<h2 id="Cheating"><a href="#Cheating" class="headerlink" title="Cheating"></a>Cheating</h2><p>Those who can’t … cheat</p>
<p>There is nothing wrong with cheating! Some things the shell just isn’t very good at. Two useful tools are <code>sed</code> and <code>awk</code>. Whilst these are two hugely powerful utilities, which can be used as mini- programming languages in their own right, they are often used in shell scripts for very simple, specific reasons.</p>
<p>Whilst this means that the system has to load a largeish executable (52k for <code>sed</code> and 110k for <code>awk</code>), which is a nasty thing to do, the reason a good workman doesn’t blame his tools, is that a good workman uses the <em>right</em> tools in the first place.<br>So let me introduce these two, with very simple uses.</p>
<h4 id="Cheating-with-awk"><a href="#Cheating-with-awk" class="headerlink" title="Cheating with awk"></a>Cheating with awk</h4><p>Consider <code>wc</code>, which counts the number of characters, lines, and words in a text file. Its output is:</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ wc hex2env.c</span><br><span class="line">	102	189	2306	hex2env.c</span><br></pre></td></tr></table></figure>
<p>If we want to get the number of lines into a variable, simply using:</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">NO_LINES=`wc -l file`</span><br></pre></td></tr></table></figure>
<p>which would read in the whole line.<br>Because the output is space-padded, we can’t reliably get the number <code>102</code> into the string. Instead, we use the fact that <code>awk</code> works similarly to <code>scanf</code> in C - it strips unwanted whitespace. It puts these into variables <code>$1 $2 $3</code> etc. So we use this construct:</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">NO_LINES=`wc -l file | awk <span class="string">&#x27;&#123; print $1 &#125;&#x27;</span>`</span><br></pre></td></tr></table></figure>
<p>The variable NO_LINES is now 102.</p>
<h4 id="Cheating-with-sed"><a href="#Cheating-with-sed" class="headerlink" title="Cheating with sed"></a>Cheating with sed</h4><p>Another handy utility is sed - the <em>stream editor</em>. Perl is very good at dealing with regular expressions, the shell isn’t. So we can quickly use the <code>s/from/to/g</code> construct by invoking <code>sed</code>.For example:</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sed s/eth0/eth1/g file1 &gt;  file2</span><br></pre></td></tr></table></figure>
<p>changes every instance of <code>eth0</code> in file1 to <code>eth1</code> in file2.<br>If we were only changing a single character, <code>tr</code> would be the tool to use, being smaller and therefore faster to load.<br>Another thing that <code>tr</code> can’t do, is remove characters from a file:</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;SOMETHING&#125;</span> | sed s/<span class="string">&quot;bad word&quot;</span>//g</span><br></pre></td></tr></table></figure>
<p>This removes the phrase “bad word” from the variable <code>$&#123;SOMETHING&#125;</code>. It may be tempting to say, “But <code>grep</code> can do that!” - grep only deals with whole lines. Consider the file:</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">This line is okay.</span><br><span class="line">This line contains a bad word. Treat with care.</span><br><span class="line">This line is fine, too.</span><br></pre></td></tr></table></figure>
<p>Grep would remove the whole second line, leaving only a two-line file; sed would change the file to read:</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">This line is okay.</span><br><span class="line">This line contains a . Treat with care.</span><br><span class="line">This line is fine, too.</span><br></pre></td></tr></table></figure>
<h2 id="Telnet-hint"><a href="#Telnet-hint" class="headerlink" title="Telnet hint"></a>Telnet hint</h2><p>This is a useful technique that I picked up from Sun’s Explorer utility. Although telnet is not used on servers any longer, it is still used by some network devices, such as terminal concentrators and the like. By creating a script such as this, your own script, or from a command line, you can run:</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ ./telnet1.sh | telnet</span><br></pre></td></tr></table></figure>
<p>I have had a few people ask me about this, and have tended to point them towards the expect suite of code, which is pretty complex and bulky; this code should be pretty portable amongst systems (so long as they’ve got egrep). If it doesn’t work on your system, try using GNU grep with the -q switch, or a proprietary grep and direct to /dev/null. Still a lot easier than installing expect, though.</p>
<hr>
<p><a target="_blank" rel="noopener" href="https://www.shellscript.sh/eg/telnet1.txt">telnet1.sh</a></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line">host=127.0.0.1</span><br><span class="line">port=23</span><br><span class="line">login=steve</span><br><span class="line">passwd=hellothere</span><br><span class="line">cmd=<span class="string">&quot;ls /tmp&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> open <span class="variable">$&#123;host&#125;</span> <span class="variable">$&#123;port&#125;</span></span><br><span class="line">sleep 1</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;login&#125;</span></span><br><span class="line">sleep 1</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;passwd&#125;</span></span><br><span class="line">sleep 1</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;cmd&#125;</span></span><br><span class="line">sleep 1</span><br><span class="line"><span class="built_in">echo</span> <span class="built_in">exit</span></span><br></pre></td></tr></table></figure>
<hr>
<p>However, Sun add some clever error-checking code (note that the variables you could set and export from your current shell or shell script, to avoid storing passwords in readable files):</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ ./telnet2.sh | telnet &gt; file1</span><br></pre></td></tr></table></figure>
<hr>
<p><a target="_blank" rel="noopener" href="https://www.shellscript.sh/eg/telnet2.txt">telnet2.sh</a></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"><span class="comment"># telnet2.sh | telnet &gt; FILE1 </span></span><br><span class="line">host=127.0.0.1</span><br><span class="line">port=23</span><br><span class="line">login=steve</span><br><span class="line">passwd=hellothere</span><br><span class="line">cmd=<span class="string">&quot;ls /tmp&quot;</span></span><br><span class="line">timeout=3</span><br><span class="line">file=file1</span><br><span class="line">prompt=<span class="string">&quot;$&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> open <span class="variable">$&#123;host&#125;</span> <span class="variable">$&#123;port&#125;</span></span><br><span class="line">sleep 1</span><br><span class="line">tout=<span class="variable">$&#123;timeout&#125;</span></span><br><span class="line"><span class="keyword">while</span> [ <span class="string">&quot;<span class="variable">$&#123;tout&#125;</span>&quot;</span> -ge 0 ]</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="keyword">if</span> tail -1 <span class="string">&quot;<span class="variable">$&#123;file&#125;</span>&quot;</span> 2&gt;/dev/null | egrep -e <span class="string">&quot;login:&quot;</span> &gt; /dev/null</span><br><span class="line">    <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$&#123;login&#125;</span>&quot;</span></span><br><span class="line">        sleep 1</span><br><span class="line">        tout=-5</span><br><span class="line">        <span class="built_in">continue</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        sleep 1</span><br><span class="line">        tout=`expr <span class="variable">$&#123;tout&#125;</span> - 1`</span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$&#123;tout&#125;</span>&quot;</span> -ne <span class="string">&quot;-5&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">  <span class="built_in">exit</span> 1</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">tout=<span class="variable">$&#123;timeout&#125;</span></span><br><span class="line"><span class="keyword">while</span> [ <span class="string">&quot;<span class="variable">$&#123;tout&#125;</span>&quot;</span> -ge 0 ]</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="keyword">if</span> tail -1 <span class="string">&quot;<span class="variable">$&#123;file&#125;</span>&quot;</span> 2&gt;/dev/null | egrep -e <span class="string">&quot;Password:&quot;</span> &gt; /dev/null</span><br><span class="line">    <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$&#123;passwd&#125;</span>&quot;</span></span><br><span class="line">        sleep 1</span><br><span class="line">        tout=-5</span><br><span class="line">        <span class="built_in">continue</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="keyword">if</span> tail -1 <span class="string">&quot;<span class="variable">$&#123;file&#125;</span>&quot;</span> 2&gt;/dev/null | egrep -e <span class="string">&quot;<span class="variable">$&#123;prompt&#125;</span>&quot;</span> &gt; /dev/null</span><br><span class="line">      <span class="keyword">then</span></span><br><span class="line">        tout=-5</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        sleep 1</span><br><span class="line">        tout=`expr <span class="variable">$&#123;tout&#125;</span> - 1`</span><br><span class="line">      <span class="keyword">fi</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$&#123;tout&#125;</span>&quot;</span> -ne <span class="string">&quot;-5&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">  <span class="built_in">exit</span> 1</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">&gt; <span class="variable">$&#123;file&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;cmd&#125;</span></span><br><span class="line">sleep 1</span><br><span class="line"><span class="built_in">echo</span> <span class="built_in">exit</span></span><br></pre></td></tr></table></figure>
<hr>
<p>Note that with this version, the output is grabbed to <code>file1</code>, and that this file is actually used by the script to check on its progress. I have added <code>&quot;&gt; $&#123;file&#125;&quot;</code> so that the output received into the file is just the output of the command, not the logging-in process too.</p>
<h1 id="Quick-Reference"><a href="#Quick-Reference" class="headerlink" title="Quick Reference"></a>Quick Reference</h1><p>This is a quick reference guide to the meaning of some of the less easily guessed commands and codes of shell scripts. By their nature, they are also quite difficult to find using search engines. These examples include <strong>process management</strong>, <strong>shell scripts arguments</strong>, and <strong>shell script <code>test</code> conditions</strong>.</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">Command</th>
<th style="text-align:left">Description</th>
<th style="text-align:left">Example</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">&amp;</td>
<td style="text-align:left">Run the previous command in the background</td>
<td style="text-align:left"><code>ls &amp;</code></td>
</tr>
<tr>
<td style="text-align:left">&amp;&amp;</td>
<td style="text-align:left">Logical AND</td>
<td style="text-align:left"><code>if [ &quot;$foo&quot; -ge &quot;0&quot; ] &amp;&amp; [ &quot;$foo&quot; -le &quot;9&quot;]</code></td>
</tr>
<tr>
<td style="text-align:left">\</td>
<td style="text-align:left">\</td>
<td style="text-align:left"></td>
<td>Logical OR</td>
<td>`if [ “$foo” -lt “0” ]</td>
<td></td>
<td>[ “$foo” -gt “9” ]`</td>
</tr>
<tr>
<td style="text-align:left">^</td>
<td style="text-align:left">Start of line</td>
<td style="text-align:left"><code>grep &quot;^foo&quot;</code></td>
</tr>
<tr>
<td style="text-align:left">$</td>
<td style="text-align:left">End of line</td>
<td style="text-align:left"><code>grep &quot;foo$&quot;</code></td>
</tr>
<tr>
<td style="text-align:left">=</td>
<td style="text-align:left">String equality (cf. -eq)</td>
<td style="text-align:left"><code>if [ &quot;$foo&quot; = &quot;bar&quot; ]</code></td>
</tr>
<tr>
<td style="text-align:left">!</td>
<td style="text-align:left">Logical NOT</td>
<td style="text-align:left"><code>if [ &quot;$foo&quot; != &quot;bar&quot; ]</code></td>
</tr>
<tr>
<td style="text-align:left">$$</td>
<td style="text-align:left">PID of current shell</td>
<td style="text-align:left"><code>echo &quot;my PID = $$&quot;</code></td>
</tr>
<tr>
<td style="text-align:left">$!</td>
<td style="text-align:left">PID of last background command</td>
<td style="text-align:left"><code>ls &amp; echo &quot;PID of ls = $!&quot;</code></td>
</tr>
<tr>
<td style="text-align:left">$?</td>
<td style="text-align:left">exit status of last command</td>
<td style="text-align:left"><code>ls ; echo &quot;ls returned code $?&quot;</code></td>
</tr>
<tr>
<td style="text-align:left">$0</td>
<td style="text-align:left">Name of current command (as called)</td>
<td style="text-align:left"><code>echo &quot;I am $0&quot;</code></td>
</tr>
<tr>
<td style="text-align:left">$1</td>
<td style="text-align:left">Name of current command’s first parameter</td>
<td style="text-align:left"><code>echo &quot;My first argument is $1&quot;</code></td>
</tr>
<tr>
<td style="text-align:left">$9</td>
<td style="text-align:left">Name of current command’s ninth parameter</td>
<td style="text-align:left"><code>echo &quot;My ninth argument is $9&quot;</code></td>
</tr>
<tr>
<td style="text-align:left">$@</td>
<td style="text-align:left">All of current command’s parameters (preserving whitespace and quoting)</td>
<td style="text-align:left"><code>echo &quot;My arguments are $@&quot;</code></td>
</tr>
<tr>
<td style="text-align:left">$*</td>
<td style="text-align:left">All of current command’s parameters (not preserving whitespace and quoting)</td>
<td style="text-align:left"><code>echo &quot;My arguments are $*&quot;</code></td>
</tr>
<tr>
<td style="text-align:left">-eq</td>
<td style="text-align:left">Numeric Equality</td>
<td style="text-align:left"><code>if [ &quot;$foo&quot; -eq &quot;9&quot; ]</code></td>
</tr>
<tr>
<td style="text-align:left">-ne</td>
<td style="text-align:left">Numeric Inquality</td>
<td style="text-align:left"><code>if [ &quot;$foo&quot; -ne &quot;9&quot; ]</code></td>
</tr>
<tr>
<td style="text-align:left">-lt</td>
<td style="text-align:left">Less Than</td>
<td style="text-align:left"><code>if [ &quot;$foo&quot; -lt &quot;9&quot; ]</code></td>
</tr>
<tr>
<td style="text-align:left">-le</td>
<td style="text-align:left">Less Than or Equal</td>
<td style="text-align:left"><code>if [ &quot;$foo&quot; -le &quot;9&quot; ]</code></td>
</tr>
<tr>
<td style="text-align:left">-gt</td>
<td style="text-align:left">Greater Than</td>
<td style="text-align:left"><code>if [ &quot;$foo&quot; -gt &quot;9&quot; ]</code></td>
</tr>
<tr>
<td style="text-align:left">-ge</td>
<td style="text-align:left">Greater Than or Equal</td>
<td style="text-align:left"><code>if [ &quot;$foo&quot; -ge &quot;9&quot; ]</code></td>
</tr>
<tr>
<td style="text-align:left">-z</td>
<td style="text-align:left">String is zero length</td>
<td style="text-align:left"><code>if [ -z &quot;$foo&quot; ]</code></td>
</tr>
<tr>
<td style="text-align:left">-n</td>
<td style="text-align:left">String is not zero length</td>
<td style="text-align:left"><code>if [ -n &quot;$foo&quot; ]</code></td>
</tr>
<tr>
<td style="text-align:left">-nt</td>
<td style="text-align:left">Newer Than</td>
<td style="text-align:left"><code>if [ &quot;$file1&quot; -nt &quot;$file2&quot; ]</code></td>
</tr>
<tr>
<td style="text-align:left">-d</td>
<td style="text-align:left">Is a Directory</td>
<td style="text-align:left"><code>if [ -d /bin ]</code></td>
</tr>
<tr>
<td style="text-align:left">-f</td>
<td style="text-align:left">Is a File</td>
<td style="text-align:left"><code>if [ -f /bin/ls ]</code></td>
</tr>
<tr>
<td style="text-align:left">-r</td>
<td style="text-align:left">Is a readable file</td>
<td style="text-align:left"><code>if [ -r /bin/ls ]</code></td>
</tr>
<tr>
<td style="text-align:left">-w</td>
<td style="text-align:left">Is a writable file</td>
<td style="text-align:left"><code>if [ -w /bin/ls ]</code></td>
</tr>
<tr>
<td style="text-align:left">-x</td>
<td style="text-align:left">Is an executable file</td>
<td style="text-align:left"><code>if [ -x /bin/ls ]</code></td>
</tr>
<tr>
<td style="text-align:left">( … )</td>
<td style="text-align:left">Function definition</td>
<td style="text-align:left"><code>function myfunc() &#123; echo hello &#125;</code></td>
</tr>
</tbody>
</table>
</div>
<h1 id="Interactive-Shell"><a href="#Interactive-Shell" class="headerlink" title="Interactive Shell"></a>Interactive Shell</h1><p>Here are a few quick hints for using the UNIX or Linux shell interactively. Personally I recommend the bash shell for most interactive use; it is available on just about every *nix flavour, and very pleasant to use as a login shell. However the root shell should always be /bin/sh, whether that points to bash or Bourne shell.</p>
<h1 id="bash"><a href="#bash" class="headerlink" title="bash"></a>bash</h1><p>bash has some very handy history-searching tools; the up and down arrow keys will scroll through the history of previous commands. More usefully, Ctrl+r will do a reverse-search, matching any part of the command line. Hit ESC and the selected command will be pasted into the current shell for you to edit as required.</p>
<p>If you want to repeat a command you ran before, and you know what characters it started with, you can do this:</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">bash$ ls /tmp</span><br><span class="line">(list of files <span class="keyword">in</span> /tmp)</span><br><span class="line">bash$ touch /tmp/foo</span><br><span class="line">bash$ !l</span><br><span class="line">ls /tmp</span><br><span class="line">(list of files <span class="keyword">in</span> /tmp, now including /tmp/foo)</span><br></pre></td></tr></table></figure>
<p>As well as the arrow keys, you can use PageUp and PageDn to navigate to the start and end of the command line.</p>
<h1 id="ksh"><a href="#ksh" class="headerlink" title="ksh"></a>ksh</h1><p>You can make ksh more usable by adding history commands, either in <code>vi</code> or <code>emacs</code> mode. There are a number of ways to do this, depending on the exact circumstances. <code>set -o vi</code>, <code>ksh -o vi</code>, or <code>exec ksh -o vi</code> (where “vi” could be replaced by “emacs” if you prefer emacs mode).</p>
<p>If you want to start a ksh session from another interactive shell, you can just call ksh like this:</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">csh% <span class="comment"># oh no, it&#x27;s csh!</span></span><br><span class="line">csh% ksh</span><br><span class="line">ksh$ <span class="comment"># phew, that&#x27;s better</span></span><br><span class="line">ksh$ <span class="comment"># do some stuff under ksh</span></span><br><span class="line">ksh$ <span class="comment"># then leave it back at the csh prompt:</span></span><br><span class="line">ksh$ <span class="built_in">exit</span></span><br><span class="line">csh%</span><br></pre></td></tr></table></figure>
<p>This will start a new ksh session, which you can exit from and return to the previous shell. Alternatively, you could replace the csh (or whatever shell) with a ksh shell, with the <code>exec</code> command:</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">csh% <span class="comment"># oh no, it&#x27;s csh!</span></span><br><span class="line">csh% <span class="built_in">exec</span> ksh</span><br><span class="line">ksh$ <span class="comment"># do some stuff under ksh</span></span><br><span class="line">ksh$ <span class="built_in">exit</span></span><br><span class="line"></span><br><span class="line">login:</span><br></pre></td></tr></table></figure>
<p>The difference here is that you don’t get the csh session back.</p>
<p>The good stuff is the history:</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">csh% ksh</span><br><span class="line">ksh$ <span class="built_in">set</span> -o vi</span><br><span class="line">ksh$ <span class="comment"># You can now edit the history with vi-like commands, </span></span><br><span class="line">  <span class="comment"># and use ESC-k to access the history.</span></span><br></pre></td></tr></table></figure>
<p>If you hit <code>ESC</code> then <code>k</code>, then by repeatedly hitting <code>k</code> you scroll backwards through the command history. You can use vi command-mode and entry-mode commands to edit the commands, like this:</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">ksh$ touch foo</span><br><span class="line">  ESC-k (enter vi mode, brings up the previous <span class="built_in">command</span>)</span><br><span class="line">  w (skip to the next word, to go from <span class="string">&quot;touch&quot;</span> to <span class="string">&quot;foo&quot;</span></span><br><span class="line">  cw (change word) bar (change <span class="string">&quot;foo&quot;</span> to <span class="string">&quot;bar&quot;</span>)</span><br><span class="line">ksh$ touch bar</span><br></pre></td></tr></table></figure>
</article><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/2022%E6%98%A5%E5%AD%A3/">2022春季</a><a class="post-meta__tags" href="/tags/Linux/">Linux</a><a class="post-meta__tags" href="/tags/Shell/">Shell</a></div><div class="post_share"><div class="addthis_inline_share_toolbox"></div><script src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-62b11572b25ab3ab" async="async"></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/03/19/%E9%9A%8F%E7%AC%94/%E5%8D%9A%E6%96%87/%E6%AF%8F%E6%AC%A1%E8%B5%B7%E9%A3%9E%E9%83%BD%E6%98%AF%E6%B0%B8%E5%88%AB/"><img class="prev-cover" src="https://raw.githubusercontent.com/zhaochenyang20/ivue_wallpaper/main/ivue_desktop/Photo by v2osk (JE01L3hB0GQ).jpg" onerror="onerror=null;src='https://raw.githubusercontent.com/zhaochenyang20/ivue_wallpaper/main/ivue_desktop/Photo by Oscar Rodrigo Hernandez Panczenko (P0GQ95huhBo).jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">每次起飞都是永别</div></div></a></div><div class="next-post pull-right"><a href="/2022/03/17/%E9%9A%8F%E7%AC%94/%E5%8D%9A%E6%96%87/%E6%B8%85%E6%99%A8%E4%B8%80%E5%B0%8F%E6%97%B6%EF%BC%8C%E7%B4%AB%E4%B9%9D%E7%81%AB%E7%81%BE%E7%BA%AA%E5%AE%9E/"><img class="next-cover" src="https://raw.githubusercontent.com/zhaochenyang20/ivue_wallpaper/main/ivue_desktop/Photo by Aaron Burden (MSRRAkkLi9U).jpg" onerror="onerror=null;src='https://raw.githubusercontent.com/zhaochenyang20/ivue_wallpaper/main/ivue_desktop/Photo by Oscar Rodrigo Hernandez Panczenko (P0GQ95huhBo).jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">清晨一小时：紫荆公寓火情纪实</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2022/02/22/CS/others/Tsing_answer_analysis/" title="答疑坊数据统计"><img class="cover" src="https://raw.githubusercontent.com/zhaochenyang20/ivue_wallpaper/main/ivue_desktop/Photo by Ron Whitaker (NrqEf4wauXM).jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-02-22</div><div class="title">答疑坊数据统计</div></div></a></div><div><a href="/2022/05/25/%E9%9A%8F%E7%AC%94/%E6%B8%85%E5%8D%8E%E5%9B%AD%E6%97%A5%E8%AE%B0/%E6%B8%85%E5%8D%8E%E5%9B%AD%E6%97%A5%E8%AE%B0--%E7%AC%AC%E4%BA%94%E9%83%A8/" title="清华园日记——第五部"><img class="cover" src="https://zhaochenyang20.github.io/pic/embed/5_31_1.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-05-25</div><div class="title">清华园日记——第五部</div></div></a></div><div><a href="/2022/05/17/Lecture/2022%20Spring/binaryDivdence/" title="深度学习基础"><img class="cover" src="https://raw.githubusercontent.com/zhaochenyang20/ivue_wallpaper/main/ivue_desktop/Photo by John O'Nolan (6f_ANCcbj3o).jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-05-17</div><div class="title">深度学习基础</div></div></a></div><div><a href="/2022/03/15/Lecture/2022%20Spring/Introduction_to_AI/" title="Introduction to Artificial Intelligence"><img class="cover" src="https://raw.githubusercontent.com/zhaochenyang20/ivue_wallpaper/main/ivue_desktop/Photo by Alexander Slattery (LI748t0BK8w).jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-03-15</div><div class="title">Introduction to Artificial Intelligence</div></div></a></div><div><a href="/2022/05/24/Lecture/2022%20Spring/Reinforcement/" title="重力四子棋"><img class="cover" src="https://raw.githubusercontent.com/zhaochenyang20/ivue_wallpaper/main/ivue_desktop/Photo by JD X (y0qwRko4r9w).jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-05-24</div><div class="title">重力四子棋</div></div></a></div><div><a href="/2022/06/06/Lecture/2022%20Spring/deep_learning/" title="Segement Me If U Can"><img class="cover" src="https://pic.imgdb.cn/item/61ed14292ab3f51d911d280f.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-06-06</div><div class="title">Segement Me If U Can</div></div></a></div><div><a href="/2022/03/31/%E5%87%BA%E5%9B%BD/%E9%A1%B9%E8%84%8A%E8%BD%A9%E5%BF%97/" title="临别项脊轩"><img class="cover" src="https://raw.githubusercontent.com/zhaochenyang20/ivue_wallpaper/main/ivue_desktop/Photo by Will Swann (-hMgQqhiyos).jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-03-31</div><div class="title">临别项脊轩</div></div></a></div><div><a href="/2022/02/08/%E9%9A%8F%E7%AC%94/%E6%80%BB%E7%BB%93/Say%20Something%20for%20Spring%202022/" title="Say Something for Spring 2022"><img class="cover" src="https://pic.imgdb.cn/item/620540f92ab3f51d91b65009.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-02-08</div><div class="title">Say Something for Spring 2022</div></div></a></div><div><a href="/2022/04/02/%E9%9A%8F%E7%AC%94/%E6%B8%85%E5%8D%8E%E5%9B%AD%E6%97%A5%E8%AE%B0/%E6%B8%85%E5%8D%8E%E5%9B%AD%E6%97%A5%E8%AE%B0--%E7%AC%AC%E4%B8%89%E9%83%A8/" title="清华园日记——第三部"><img class="cover" src="https://raw.githubusercontent.com/zhaochenyang20/ivue_wallpaper/main/ivue_desktop/Photo by v2osk (biUw5Nf4Ex8).jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-04-02</div><div class="title">清华园日记——第三部</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="gitalk-container"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Philosophy"><span class="toc-number">1.</span> <span class="toc-text">Philosophy</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#A-clear-layout"><span class="toc-number">1.1.</span> <span class="toc-text">A clear layout</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#avoiding-unnecessary-commands"><span class="toc-number">1.2.</span> <span class="toc-text">avoiding unnecessary commands</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#A-First-Script"><span class="toc-number">2.</span> <span class="toc-text">A First Script</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Variables-Part-I"><span class="toc-number">3.</span> <span class="toc-text">Variables - Part I</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Scope-of-Variables"><span class="toc-number">3.1.</span> <span class="toc-text">Scope of Variables</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Wildcards"><span class="toc-number">4.</span> <span class="toc-text">Wildcards</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Escape-Characters"><span class="toc-number">5.</span> <span class="toc-text">Escape Characters</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Loops"><span class="toc-number">6.</span> <span class="toc-text">Loops</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#For-Loops"><span class="toc-number">6.1.</span> <span class="toc-text">For Loops</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#While-Loops"><span class="toc-number">6.2.</span> <span class="toc-text">While Loops</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Test"><span class="toc-number">7.</span> <span class="toc-text">Test</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Summary-of-special-symbols"><span class="toc-number">8.</span> <span class="toc-text">Summary of special symbols</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Case"><span class="toc-number">9.</span> <span class="toc-text">Case</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Variables-Part-II"><span class="toc-number">10.</span> <span class="toc-text">Variables - Part II</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Variables-Part-III"><span class="toc-number">11.</span> <span class="toc-text">Variables - Part III</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Using-Default-Values"><span class="toc-number">11.0.0.1.</span> <span class="toc-text">Using Default Values</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Using-and-Setting-Default-Values"><span class="toc-number">11.0.0.2.</span> <span class="toc-text">Using and Setting Default Values</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#External-Programs"><span class="toc-number">12.</span> <span class="toc-text">External Programs</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Functions"><span class="toc-number">13.</span> <span class="toc-text">Functions</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Scope-of-Variables-1"><span class="toc-number">13.1.</span> <span class="toc-text">Scope of Variables</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Recursion"><span class="toc-number">13.2.</span> <span class="toc-text">Recursion</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Return-Codes"><span class="toc-number">13.3.</span> <span class="toc-text">Return Codes</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Hints-and-Tips"><span class="toc-number">14.</span> <span class="toc-text">Hints and Tips</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Cheating"><span class="toc-number">14.1.</span> <span class="toc-text">Cheating</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Cheating-with-awk"><span class="toc-number">14.1.0.1.</span> <span class="toc-text">Cheating with awk</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Cheating-with-sed"><span class="toc-number">14.1.0.2.</span> <span class="toc-text">Cheating with sed</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Telnet-hint"><span class="toc-number">14.2.</span> <span class="toc-text">Telnet hint</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Quick-Reference"><span class="toc-number">15.</span> <span class="toc-text">Quick Reference</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Interactive-Shell"><span class="toc-number">16.</span> <span class="toc-text">Interactive Shell</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#bash"><span class="toc-number">17.</span> <span class="toc-text">bash</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#ksh"><span class="toc-number">18.</span> <span class="toc-text">ksh</span></a></li></ol></div></div></div></div></main><footer id="footer" style="background: ＃0096FF"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2022 By Eren Zhao</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div><script type="text/javascript" id="maid-script" src="https://unpkg.com/mermaid@undefined/dist/mermaid.min.js?v=undefined"></script><script>if (window.mermaid) {
  var options = JSON.parse(document.getElementById('maid-script').getAttribute('mermaidoptioins'));
  mermaid.initialize(options);
}</script></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="chat_btn" type="button" title="rightside.chat_btn"><i class="fas fa-sms"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">本地搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库正在艰难运行</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [ ['$','$'], ["\\(","\\)"]],
      tags: 'ams'
    },
    chtml: {
      scale: 1.2
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, ''],
        insertScript: [200, () => {
          document.querySelectorAll('mjx-container:not\([display]\)').forEach(node => {
            const target = node.parentNode
            if (target.nodeName.toLowerCase() === 'li') {
              target.parentNode.classList.add('has-jax')
            } else {
              target.classList.add('has-jax')
            }
          });
        }, '', false]
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typeset()
}</script><script>(() => {
  const $mermaidWrap = document.querySelectorAll('#article-container .mermaid-wrap')
  if ($mermaidWrap.length) {
    window.runMermaid = () => {
      window.loadMermaid = true
      const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

      Array.from($mermaidWrap).forEach((item, index) => {
        const mermaidSrc = item.firstElementChild
        const mermaidThemeConfig = '%%{init:{ \'theme\':\'' + theme + '\'}}%%\n'
        const mermaidID = 'mermaid-' + index
        const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent
        mermaid.mermaidAPI.render(mermaidID, mermaidDefinition, (svgCode) => {
          mermaidSrc.insertAdjacentHTML('afterend', svgCode)
        })
      })
    }

    const loadMermaid = () => {
      window.loadMermaid ? runMermaid() : getScript('https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js').then(runMermaid)
    }

    window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
  }
})()</script><script>function addGitalkSource () {
  const ele = document.createElement('link')
  ele.rel = 'stylesheet'
  ele.href= 'https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css'
  document.getElementsByTagName('head')[0].appendChild(ele)
}

function loadGitalk () {
  function initGitalk () {
    var gitalk = new Gitalk(Object.assign({
      clientID: '978121c7b834efdd76be',
      clientSecret: '59b40e8f39a1c33db5a2c891771086164b9575c4',
      repo: 'zhaochenyang20.github.io',
      owner: 'zhaochenyang20',
      admin: ['zhaochenyang20'],
      id: '99f9897b054d3fdf86070f59dc45950c',
      updateCountCallback: commentCount
    },null))

    gitalk.render('gitalk-container')
  }

  if (typeof Gitalk === 'function') initGitalk()
  else {
    addGitalkSource()
    getScript('https://cdn.jsdelivr.net/npm/gitalk@latest/dist/gitalk.min.js').then(initGitalk)
  }
}

function commentCount(n){
  let isCommentCount = document.querySelector('#post-meta .gitalk-comment-count')
  if (isCommentCount) {
    isCommentCount.innerHTML= n
  }
}

if ('Gitalk' === 'Gitalk' || !true) {
  if (true) btf.loadComment(document.getElementById('gitalk-container'), loadGitalk)
  else loadGitalk()
} else {
  function loadOtherComment () {
    loadGitalk()
  }
}</script></div><canvas class="fireworks" mobile="true"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/fireworks.min.js"></script><script defer="defer" id="fluttering_ribbon" mobile="true" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-fluttering-ribbon.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = false;
POWERMODE.mobile = true;
document.body.addEventListener('input', POWERMODE);
</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/tororo.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":true},"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/"});</script></body></html>