<!DOCTYPE html><html lang="en-US" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>oop笔记  L6  引用与复制 | La vida sola viviras</title><meta name="keywords" content="跪系的普通学生"><meta name="author" content="Eren Zhao"><meta name="copyright" content="Eren Zhao"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="禁用返回值优化...">
<meta property="og:type" content="article">
<meta property="og:title" content="oop笔记  L6  引用与复制">
<meta property="og:url" content="http://example.com/2022/01/12/Lecture/%E4%BB%8E%E5%89%8D%E7%9A%84%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/OOP/L6%20%E5%BC%95%E7%94%A8%E4%B8%8E%E5%A4%8D%E5%88%B6/index.html">
<meta property="og:site_name" content="La vida sola viviras">
<meta property="og:description" content="禁用返回值优化...">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://pic.imgdb.cn/item/623475d95baa1a80ab3b102b.jpg">
<meta property="article:published_time" content="2022-01-12T08:33:22.000Z">
<meta property="article:modified_time" content="2022-01-12T08:44:09.673Z">
<meta property="article:author" content="Eren Zhao">
<meta property="article:tag" content="跪系的普通学生">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://pic.imgdb.cn/item/623475d95baa1a80ab3b102b.jpg"><link rel="shortcut icon" href="/img/favicon.ico"><link rel="canonical" href="http://example.com/2022/01/12/Lecture/%E4%BB%8E%E5%89%8D%E7%9A%84%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/OOP/L6%20%E5%BC%95%E7%94%A8%E4%B8%8E%E5%A4%8D%E5%88%B6/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"We didn't find any results for the search: ${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: 'Just',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'oop笔记  L6  引用与复制',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-01-12 16:44:09'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.0.0"><style>.darkmode--activated{--body-bg-color:#282828;--content-bg-color:#333;--card-bg-color:#555;--text-color:#ccc;--blockquote-color:#bbb;--link-color:#ccc;--link-hover-color:#eee;--brand-color:#ddd;--brand-hover-color:#ddd;--table-row-odd-bg-color:#282828;--table-row-hover-bg-color:#363636;--menu-item-bg-color:#555;--btn-default-bg:#222;--btn-default-color:#ccc;--btn-default-border-color:#555;--btn-default-hover-bg:#666;--btn-default-hover-color:#ccc;--btn-default-hover-border-color:#666;--highlight-background:#282b2e;--highlight-foreground:#a9b7c6;--highlight-gutter-background:#34393d;--highlight-gutter-foreground:#9ca9b6}.darkmode--activated img{opacity:.75}.darkmode--activated img:hover{opacity:.9}.darkmode--activated code{color:#69dbdc;background:0 0}button.darkmode-toggle{z-index:9999}.darkmode-ignore,img{display:flex!important}</style></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/avatar.jpeg" onerror="onerror=null;src='/img/friend.jpg'" alt="avatar"/></div><div class="site-data is-center"><div class="data-item"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">166</div></a></div><div class="data-item"><a href="/tags/"><div class="headline">Tags</div><div class="length-num">53</div></a></div><div class="data-item"><a href="/categories/"><div class="headline">Categories</div><div class="length-num">12</div></a></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://pic.imgdb.cn/item/623475d95baa1a80ab3b102b.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">La vida sola viviras</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> Search</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">oop笔记  L6  引用与复制</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2022-01-12T08:33:22.000Z" title="Created 2022-01-12 16:33:22">2022-01-12</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2022-01-12T08:44:09.673Z" title="Updated 2022-01-12 16:44:09">2022-01-12</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/oop/">oop</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">Word count:</span><span class="word-count">11.8k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">Reading time:</span><span>46min</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="oop笔记  L6  引用与复制"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post View:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="l6-引用与复制">L6 引用与复制</h1>
<blockquote>
<p>如果阅读时间不够充足，建议阅读课堂的扩展部分。</p>
<ul>
<li>2.4.2 默认生成移动构造函数</li>
<li>3.2.3 例二：完整定义所有函数但禁用返回值优化后的执行顺序</li>
<li>结合第三次作业第二题讨论返回值优化</li>
<li>结合第三次作业第三题讨论delete与检测</li>
<li>结合第三次作业第三题讨论move与类型转换</li>
<li>结合第三次作业第三题讨论置空操作</li>
<li>9.3 类型转换的实例详述</li>
</ul>
</blockquote>
<hr />
<h1 id="一常量引用">一、常量引用</h1>
<h2 id="常量引用的意义">1.1 常量引用的意义</h2>
<p>按照最小特权原则：给函数足够的权限去完成相应的任务，但不要给予他任何多余的权限。例如函数void add(int&amp; a, int&amp; b)，如果将参数类型定义为int&amp;，则给予该函数在函数体内修改a和b的值的权限。</p>
<p>如果我们不想给予函数修改权限，则可以在参数中使用常量/常量引用<code>void add(const int&amp; a, const int&amp; b)</code>。此时函数中仅能读取a和b的值，无法对a, b进行任何修改操作。</p>
<h1 id="二拷贝构造函数">二、拷贝构造函数</h1>
<h2 id="定义与语法规则">2.1 定义与语法规则</h2>
<p>拷贝构造函数是一种特殊的构造函数，它的参数是语言规定的，是同类对象的常量引用。 作用：用参数对象的内容初始化当前对象。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Vector::<span class="built_in">Vector</span>(<span class="keyword">const</span> Vector&amp; other)</span><br><span class="line">&#123;</span><br><span class="line">    capacity = other.capacity;</span><br><span class="line">    len = other.len;</span><br><span class="line">    array = <span class="keyword">new</span> Node[other.capacity];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        array[i] =other.array[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="调用时机">2.2 调用时机</h2>
<p>拷贝构造函数被调用的三种常见情况。在这些情况下，编译器会自动调用“拷贝构造函数”，在已有对象基础上生成新对象。</p>
<p>用一个类对象定义另一个新的类对象：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Test a;<span class="function">Test <span class="title">b</span><span class="params">(a)</span></span>;</span><br><span class="line">Test c=a;</span><br></pre></td></tr></table></figure>
<p>函数调用时以类的对象为形参</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Func</span>(Test a)</span><br></pre></td></tr></table></figure>
<p>函数返回类对象（无返回值优化的情况下）</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">Test <span class="title">Func</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br></pre></td></tr></table></figure>
<h2 id="隐式拷贝构造函数">2.3 隐式拷贝构造函数</h2>
<p>类的新对象被定义后，会调用构造函数或拷贝构造函数。如果调用拷贝构造函数且当前没有给类显式定义拷贝构造函数，编译器将自动合成“隐式定义的拷贝构造函数”，其功能是调用所有数据成员的拷贝构造函数或拷贝赋值运算符。</p>
<p>对于基础类型来说，默认的拷贝方式为位拷贝(Bitwise Copy)，即直接对整块内存进行复制。</p>
<p>位拷贝原本是C中的概念。在C++中，只有基础类型（int, double等）才会进行位拷贝；对于自定义类，编译器会递归调用所有数据成员的拷贝构造函数或拷贝赋值运算符。但一些教材中仍然把这种行为称为“位拷贝”，以区别用户自定义的拷贝方法。</p>
<p>隐式定义拷贝构造函数的缺陷：隐式定义拷贝构造函数在遇到指针类型成员时可能会出错,导致多个指针类型的变量指向同一个地址。</p>
<h2 id="执行顺序">2.4 执行顺序</h2>
<h3 id="基本的执行顺序">2.4.1 基本的执行顺序</h3>
<p>以下述的func函数为例，调用该函数时，函数中各类构造函数和析构函数的执行顺序如下。</p>
<figure>
<img src="https://s2.loli.net/2022/01/11/zNMXaWyvsr35Gb7.png" alt="https://s2.loli.net/2022/01/11/zNMXaWyvsr35Gb7.png" /><figcaption aria-hidden="true">https://s2.loli.net/2022/01/11/zNMXaWyvsr35Gb7.png</figcaption>
</figure>
<p>值得一提的是，实际上在主函数体内，假设我们禁用返回值优化。<code>Myclass a= func(d);</code>这个语句内的返回值类构造调用了拷贝构造，并且相关的析构非常值得研究，下文将在移动构造函数的例子中将进一步阐述。</p>
<h3 id="例子">2.4.2 例子</h3>
<p>（编译指令g++ test.cpp --std=c++11 -fno-elide-constructors –o test）</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Test</span>() &#123; <span class="comment">//构造函数</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Test()&quot;</span> &lt;&lt; endl; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Test</span>(<span class="keyword">const</span> Test&amp; src) &#123; <span class="comment">//拷贝构造</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Test(const Test&amp;)&quot;</span> &lt;&lt; endl; </span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Test</span>() &#123; <span class="comment">//析构函数</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;~Test()&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">Test <span class="title">copyObj</span><span class="params">(Test obj)</span> </span>&#123; </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;func()...&quot;</span> &lt;&lt; endl; </span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Test</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;main()...&quot;</span> &lt;&lt; endl;</span><br><span class="line">    Test t;</span><br><span class="line">    t = <span class="built_in">copyObj</span>(t);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">输出：</span><br><span class="line"><span class="built_in">main</span>()...</span><br><span class="line"><span class="built_in">Test</span>()  <span class="comment">//main函数内初始化 Test</span></span><br><span class="line"><span class="built_in">Test</span>(<span class="keyword">const</span> Test&amp;)<span class="comment">//func参数 拷贝构造</span></span><br><span class="line"><span class="built_in">func</span>()...</span><br><span class="line"><span class="built_in">Test</span>()   <span class="comment">//初始化 Test类的对象</span></span><br><span class="line"><span class="built_in">Test</span>(<span class="keyword">const</span> Test&amp;) <span class="comment">//返回时拷贝构造</span></span><br><span class="line">~<span class="built_in">Test</span>()</span><br><span class="line">~<span class="built_in">Test</span>()</span><br><span class="line">~<span class="built_in">Test</span>()</span><br><span class="line">~<span class="built_in">Test</span>()</span><br></pre></td></tr></table></figure>
<p>对应关系并不复杂，如下图所示：</p>
<figure>
<img src="https://s2.loli.net/2022/01/11/KPIF2NO1WwmTDhS.png" alt="https://s2.loli.net/2022/01/11/KPIF2NO1WwmTDhS.png" /><figcaption aria-hidden="true">https://s2.loli.net/2022/01/11/KPIF2NO1WwmTDhS.png</figcaption>
</figure>
<p>其实最有意思的是，这里对于返回类对象的构造。</p>
<p>我们在第三次作业第二题当中学习过：</p>
<blockquote>
<p>“在禁用返回值优化的条件下，如果一个函数的返回值是某个对象，那在函数返回前需要调用拷贝构造函数构建返回值。</p>
</blockquote>
<p>即使我返回的东西就是我传进来的形参对象，返回前的这次构造仍然会发生，也就是这道题中f1的第二次构造函数调用。</p>
<p>但是对于返回值的构造调用的到底是移动构造函数，还是拷贝构造函数，对此C++11有规定：在无返回值优化的情况下，默认调用移动构造函数。”</p>
<p>按此理解，此处构造返回值理应调用移动构造，而非拷贝构造，似乎产生了矛盾。然而，当我们显式定义了拷贝构造，编译器就不会默认生成移动构造了。从而禁用了返回值优化后，在返回值的构造当中调用了拷贝构造而非移动构造，因为编译器不会默认生成移动构造，我也没有自己定义。</p>
<p>更进一步，如果我显式定义了拷贝赋值，就不会默认生成移动赋值了。如果两个都不定义，两个都会默认生成。</p>
<h2 id="拷贝构造函数的缺陷">2.5 拷贝构造函数的缺陷</h2>
<p>当类内含指针类型的成员时，拷贝构造函数会使得两个指正指向同一内存空间。在析构时，该内存空间可能被反复释放。为避免指针被重复删除，不应使用隐式定义的拷贝构造函数。</p>
<p>以及，当<strong>对象较大</strong>时，频繁的拷贝构造会造成程序<strong>效率的显著下降</strong>。</p>
<p>故而，正常情况下，应尽可能避免使用拷贝构造函数。</p>
<h2 id="解决方法">2.6 解决方法</h2>
<ul>
<li>使用引用/常量引用传参数或返回对象；</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">引用或常量引用传递参数</span><br><span class="line"><span class="built_in">func</span>(MyClass a)改为<span class="built_in">func</span>(<span class="keyword">const</span> MyClass&amp; a)</span><br><span class="line">返回值为引用</span><br><span class="line"><span class="function">MyClass <span class="title">func</span><span class="params">(…)</span>改为MyClass&amp; <span class="title">func</span><span class="params">(…)</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>将拷贝构造函数声明为private；</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="built_in">MyClass</span>(<span class="keyword">const</span> MyClass&amp;)&#123;&#125;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyClass</span>()=<span class="keyword">default</span>;</span><br><span class="line">      ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>用delete关键字让编译器不生成拷贝构造函数的隐式定义版本。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyClass</span>()=<span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="keyword">const</span> MyClass&amp;)=<span class="keyword">delete</span>;</span><br><span class="line">  ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="三移动构造函数">三、移动构造函数</h1>
<h2 id="右值与右值引用">3.1 右值与右值引用</h2>
<h3 id="左右值">3.1.1 左右值</h3>
<p>左值：可以取地址、有名字的值。 右值：不能取地址、没有名字的值;常见于常值、函数返回值、表达式。 虽然右值不能取地址也没有名字，但是右值可以运算。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> b = <span class="built_in">func</span>();</span><br><span class="line"><span class="keyword">int</span> c = a + b;</span><br></pre></td></tr></table></figure>
<p>其中a、b、c为左值，1、func函数返回值、a+b的结果为右值。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">x</span><span class="params">()</span></span>;</span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> &amp;&amp;a=<span class="built_in">x</span>()+<span class="number">1</span>;</span><br><span class="line">    cout&lt;&lt;a&lt;&lt;endl;</span><br><span class="line">    a++;</span><br><span class="line">    cout&lt;&lt;a&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">x</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> <span class="number">1</span>;&#125;</span><br><span class="line">Output：</span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure>
<p>右值可以运算，且右值引用接收右值后也可以运算。</p>
<p>左值可以取地址，并且可以被&amp;引用(左值引用)</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> *d = &amp;a;  <span class="keyword">int</span> &amp;d = a;<span class="comment">//允许</span></span><br><span class="line"><span class="keyword">int</span> *e = &amp;(a + b); <span class="keyword">int</span> &amp;e = a + b; <span class="comment">//非法</span></span><br></pre></td></tr></table></figure>
<h3 id="右值引用">3.1.2 右值引用</h3>
<p>虽然右值无法取地址，但可以被&amp;&amp;引用(右值引用)</p>
<p>右值引用可以绑定右值：<code>int &amp;&amp;e = a+b;</code></p>
<p>右值引用无法绑定左值：<code>int &amp;&amp;e=a;//该操作非法</code></p>
<p>总之，左值引用能绑定左值，右值引用能绑定右值。特例：<strong>常量左值引用能也绑定右值</strong>，因为常量左值引用不会改变内存空间的数据，故而不会影响右值。也可以实现绑定。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;e = <span class="number">3</span>; </span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;e = a*b;</span><br></pre></td></tr></table></figure>
<p>注意到，所有的引用（包括右值引用）本身都是左值，结合该规则和上表便可判断各种构造函数、赋值运算符中传递参数和取返回值的引用绑定情况。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">x</span><span class="params">()</span></span>;</span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> &amp;&amp;a=<span class="built_in">x</span>()+<span class="number">1</span>;</span><br><span class="line">    cout&lt;&lt;a&lt;&lt;endl;</span><br><span class="line">    a++;</span><br><span class="line">    cout&lt;&lt;a&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">int</span> &amp;b=a;</span><br><span class="line">    b++;</span><br><span class="line">    cout&lt;&lt;a&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">x</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> <span class="number">1</span>;&#125;</span><br><span class="line">Output：</span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br></pre></td></tr></table></figure>
<p>如此例，右值引用本身是左值，可以被取地址。</p>
<p>例一：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ref</span><span class="params">(<span class="keyword">int</span> &amp;x)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;left &quot;</span> &lt;&lt; x &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ref</span><span class="params">(<span class="keyword">int</span> &amp;&amp;x)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;right &quot;</span> &lt;&lt; x &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">ref</span>(a);</span><br><span class="line">    <span class="built_in">ref</span>(<span class="number">2</span>); <span class="comment">//2是一个常量</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">输出：</span><br><span class="line">left <span class="number">1</span></span><br><span class="line">right <span class="number">2</span></span><br></pre></td></tr></table></figure>
<p>如果没有定义 ref(int &amp;&amp;x) 函数会发生什么？</p>
<p>ref (int&amp;x)的函数参数类型是一个左值引用，而2是一个右值，不能调用ref (int&amp;x)。因此没有可供调用的函数。 [Error] invalid initialization of non-const reference of type 'int&amp;' from an rvalue of type 'int'。</p>
<p>例二：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ref</span><span class="params">(<span class="keyword">int</span> &amp;x)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;left &quot;</span> &lt;&lt; x &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ref</span><span class="params">(<span class="keyword">int</span> &amp;&amp;x)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;right &quot;</span> &lt;&lt; x &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">ref</span>(x); <span class="comment">//调用哪一个函数？</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">ref</span>(<span class="number">1</span>); <span class="comment">//1是一个常量</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//EncryptStratgy.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EncryptStrategy</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> std::string <span class="title">encode</span><span class="params">(std::string mes)</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InsertStrategy</span>:</span><span class="keyword">public</span> EncryptStrategy&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function">string <span class="title">encode</span><span class="params">(string mes)</span></span>&#123;</span><br><span class="line">		string s=<span class="string">&quot;#&quot;</span>;</span><br><span class="line">		string tmp=mes;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=tmp.<span class="built_in">size</span>();i=i+<span class="number">2</span>)&#123;</span><br><span class="line">			tmp.<span class="built_in">insert</span>(i,s);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> tmp;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InvertStrategy</span>:</span><span class="keyword">public</span> EncryptStrategy&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function">string <span class="title">encode</span><span class="params">(string mes)</span></span>&#123;</span><br><span class="line">		string temp=mes;</span><br><span class="line">		<span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i=mes.<span class="built_in">size</span>()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">			temp[cnt]=mes[i];</span><br><span class="line">			cnt++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> temp;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//verificationstrategy.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VerificationStrategy</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> std::string <span class="title">verify</span><span class="params">(std::string mes)</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PrefixStrategy</span>:</span><span class="keyword">public</span> VerificationStrategy&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function">string <span class="title">verify</span><span class="params">(string mes)</span></span>&#123;</span><br><span class="line">		string ans;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)&#123;</span><br><span class="line">			ans.<span class="built_in">push_back</span>(mes[i]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> ans;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IntervalStrategy</span>:</span><span class="keyword">public</span> VerificationStrategy&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function">string <span class="title">verify</span><span class="params">(string mes)</span></span>&#123;</span><br><span class="line">		string ans;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;mes.<span class="built_in">size</span>();i=i+<span class="number">2</span>)&#123;</span><br><span class="line">			ans.<span class="built_in">push_back</span>(mes[i]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> ans;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//userproxy.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;User.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;VerificationStrategy.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;EncryptStrategy.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserProxy</span>:</span><span class="keyword">public</span> User&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    RealUser* m_real;</span><br><span class="line">    EncryptStrategy* m_encrypt;</span><br><span class="line">    VerificationStrategy* m_veri;</span><br><span class="line">    <span class="built_in">UserProxy</span>(RealUser* r_u,EncryptStrategy* e_s,VerificationStrategy* v_s):<span class="built_in">m_real</span>(r_u),<span class="built_in">m_encrypt</span>(e_s),<span class="built_in">m_veri</span>(v_s)&#123;&#125;;</span><br><span class="line">    ~<span class="built_in">UserProxy</span>()&#123;</span><br><span class="line">        <span class="keyword">delete</span> m_real;</span><br><span class="line">        <span class="keyword">delete</span> m_encrypt;</span><br><span class="line">        <span class="keyword">delete</span> m_veri;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sendMessage</span><span class="params">(string mes)</span></span>&#123;</span><br><span class="line">        string temp=m_encrypt-&gt;<span class="built_in">encode</span>(mes);</span><br><span class="line">        m_real-&gt;<span class="built_in">sendMessage</span>(temp);</span><br><span class="line">        cout&lt;&lt;m_veri-&gt;<span class="built_in">verify</span>(mes)&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line">输出：</span><br><span class="line">right <span class="number">1</span></span><br><span class="line">left <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>如前文所述，所有引用本身都是左值，故而ref(1)首先调用ref(int &amp;&amp;x)函数，此时右值引用x为左值，因此ref(x)调用ref(int &amp;x)函数。</p>
<h2 id="移动构造函数">3.2 移动构造函数</h2>
<h3 id="定义与意义">3.2.1 定义与意义</h3>
<p>右值引用可以延续即将销毁变量的生命周期，用于构造函数可以提升处理效率，在此过程中尽可能少地进行拷贝。</p>
<p>使用右值引用作为参数的构造函数叫做移动构造函数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">ClassName</span>(ClassName&amp;&amp; VariableName);</span><br></pre></td></tr></table></figure>
<h3 id="两种构造本质区别">3.2.2 两种构造本质区别</h3>
<p>移动构造函数与拷贝构造函数最主要的差别就是类中堆内存是重新开辟并拷贝，还是直接将指针指向那块地址。对于一些即将析构的临时类，移动构造函数直接利用了原来临时对象中的堆内存，新的对象无需开辟内存，临时对象无需释放内存，从而大大提高计算效率。</p>
<h3 id="例子-1">3.2.3 例子</h3>
<p>例1：完整定义所有函数以及启用返回值优化</p>
<p>g++ test.cpp --std=c++11 -o test</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> * buf; <span class="comment">//// only for demo.</span></span><br><span class="line">    <span class="built_in">Test</span>() &#123;</span><br><span class="line">        buf = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>]; <span class="comment">//申请一块内存</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Test(): this-&gt;buf @ &quot;</span> &lt;&lt; hex &lt;&lt; buf &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Test</span>() &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;~Test(): this-&gt;buf @ &quot;</span> &lt;&lt; hex &lt;&lt; buf &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">if</span> (buf) <span class="keyword">delete</span>[] buf;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Test</span>(<span class="keyword">const</span> Test&amp; t) : <span class="built_in">buf</span>(<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>]) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++) </span><br><span class="line">            buf[i] = t.buf[i]; <span class="comment">//拷贝数据</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Test(const Test&amp;) called. this-&gt;buf @ &quot;</span></span><br><span class="line">            &lt;&lt; hex &lt;&lt; buf &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Test</span>(Test&amp;&amp; t) : <span class="built_in">buf</span>(t.buf) &#123; <span class="comment">//直接复制地址，避免拷贝</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Test(Test&amp;&amp;) called. this-&gt;buf @ &quot;</span></span><br><span class="line">            &lt;&lt; hex &lt;&lt; buf &lt;&lt; endl;</span><br><span class="line">        t.buf = <span class="literal">nullptr</span>; <span class="comment">//将t.buf改为nullptr，使其不再指向原来内存区域</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">Test <span class="title">GetTemp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Test tmp;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;GetTemp(): tmp.buf @ &quot;</span></span><br><span class="line">        &lt;&lt; hex &lt;&lt; tmp.buf &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(Test t)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;fun(Test t): t.buf @ &quot;</span></span><br><span class="line">        &lt;&lt; hex &lt;&lt; t.buf &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Test a = <span class="built_in">GetTemp</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;main() : a.buf @ &quot;</span> &lt;&lt; hex &lt;&lt; a.buf &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">fun</span>(a);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">output：</span><br><span class="line"><span class="built_in">Test</span>(): <span class="keyword">this</span>-&gt;buf @ <span class="number">0x7fa908c04b90</span></span><br><span class="line"><span class="built_in">GetTemp</span>(): tmp.buf @ <span class="number">0x7fa908c04b90</span></span><br><span class="line"><span class="built_in">main</span>() : a.buf @ <span class="number">0x7fa908c04b90</span></span><br><span class="line"><span class="built_in">Test</span>(<span class="keyword">const</span> Test&amp;) called. </span><br><span class="line">     <span class="keyword">this</span>-&gt;buf @ <span class="number">0x7fa908c04ba0</span></span><br><span class="line"><span class="built_in">fun</span>(Test t): t.buf @ <span class="number">0x7fa908c04ba0</span></span><br><span class="line">~<span class="built_in">Test</span>(): <span class="keyword">this</span>-&gt;buf @ <span class="number">0x7fa908c04ba0</span></span><br><span class="line">~<span class="built_in">Test</span>(): <span class="keyword">this</span>-&gt;buf @ <span class="number">0x7fa908c04b90</span></span><br></pre></td></tr></table></figure>
<p>没有调用移动构造函数，也少调用了几次拷贝构造函数。</p>
<p>关键点在于，返回值优化之后不会通过移动构造来构造返回值类，也不会通过移动构造来构造a，实现了直接return。</p>
<p>例2：完整定义所有函数但禁用返回值优化</p>
<p>g++ test.cpp --std=c++11 -fno-elide-constructors -o test</p>
<p>这里课件上的注释有些误导，我在rextester输出该段代码，采用的指令为g++-Wall -std=c++14 -O2 -fno-elide-constructors -o a.out source_file.cpp</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">output：</span><br><span class="line"><span class="built_in">Test</span>(): <span class="keyword">this</span>-&gt;buf @ <span class="number">0x563a2616ae70</span></span><br><span class="line"><span class="built_in">GetTemp</span>(): tmp.buf @ <span class="number">0x563a2616ae70</span></span><br><span class="line"><span class="built_in">Test</span>(Test&amp;&amp;) called. <span class="keyword">this</span>-&gt;buf @ <span class="number">0x563a2616ae70</span></span><br><span class="line">~<span class="built_in">Test</span>(): <span class="keyword">this</span>-&gt;buf @ <span class="number">0</span></span><br><span class="line"><span class="built_in">Test</span>(Test&amp;&amp;) called. <span class="keyword">this</span>-&gt;buf @ <span class="number">0x563a2616ae70</span></span><br><span class="line">~<span class="built_in">Test</span>(): <span class="keyword">this</span>-&gt;buf @ <span class="number">0</span></span><br><span class="line"><span class="built_in">main</span>() : a.buf @ <span class="number">0x563a2616ae70</span></span><br><span class="line"><span class="built_in">Test</span>(<span class="keyword">const</span> Test&amp;) called. <span class="keyword">this</span>-&gt;buf @ <span class="number">0x563a2616beb0</span></span><br><span class="line"><span class="built_in">fun</span>(Test t): t.buf @ <span class="number">0x563a2616beb0</span></span><br><span class="line">~<span class="built_in">Test</span>(): <span class="keyword">this</span>-&gt;buf @ <span class="number">0x563a2616beb0</span></span><br><span class="line">~<span class="built_in">Test</span>(): <span class="keyword">this</span>-&gt;buf @ <span class="number">0x563a2616ae70</span></span><br></pre></td></tr></table></figure>
<p>禁用返回值优化但是同时定义了移动构造函数，故而需要通过移动构造来构造返回值类。之后立刻将tmp析构(由于移动构造已经将tmp的指针置空了，故而buf地址为0)，但是没有析构返回值类GetTemp。返回值类GetTemp对a移动构造，这使得GetTemp的buf地址也为0。这一步移动构造后，马上析构了GetTemp。</p>
<p>综上所述，<code>Test a = GetTemp();</code>这一语句的执行顺序是先构造tmp，移动构造返回值类。立刻析构tmp，返回值类移动构造a，接着析构返回值类。</p>
<p>结合例子2.4.1，我们来探究下4,5和返回值类在禁用返回值优化条件下的析构顺序。测试代码如下，编译指令为g++-Wall -std=c++14 -O2 -fno-elide-constructors -o a.out source_file.cpp</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> * buf; <span class="comment">//// only for demo.</span></span><br><span class="line">    <span class="built_in">Test</span>() &#123;</span><br><span class="line">        buf = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>]; <span class="comment">//申请一块内存</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Test(): this-&gt;buf @ &quot;</span> &lt;&lt; hex &lt;&lt; buf &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Test</span>() &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;~Test(): this-&gt;buf @ &quot;</span> &lt;&lt; hex &lt;&lt; buf &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">if</span> (buf) <span class="keyword">delete</span>[] buf;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Test</span>(<span class="keyword">const</span> Test&amp; t) : <span class="built_in">buf</span>(<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>]) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++) </span><br><span class="line">            buf[i] = t.buf[i]; <span class="comment">//拷贝数据</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Test(const Test&amp;) called. this-&gt;buf @ &quot;</span></span><br><span class="line">            &lt;&lt; hex &lt;&lt; buf &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Test</span>(Test&amp;&amp; t) : <span class="built_in">buf</span>(t.buf) &#123; <span class="comment">//直接复制地址，避免拷贝</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Test(Test&amp;&amp;) called. this-&gt;buf @ &quot;</span></span><br><span class="line">            &lt;&lt; hex &lt;&lt; buf &lt;&lt; endl;</span><br><span class="line">        t.buf = <span class="literal">nullptr</span>; <span class="comment">//将t.buf改为nullptr，使其不再指向原来内存区域</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">Test <span class="title">GetTemp</span><span class="params">(Test x)</span> </span>&#123;</span><br><span class="line">    Test tmp;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;GetTemp(): tmp.buf @ &quot;</span></span><br><span class="line">        &lt;&lt; hex &lt;&lt; tmp.buf &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(Test t)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;fun(Test t): t.buf @ &quot;</span></span><br><span class="line">        &lt;&lt; hex &lt;&lt; t.buf &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Test d;</span><br><span class="line">    Test a = <span class="built_in">GetTemp</span>(d);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;main() : a.buf @ &quot;</span> &lt;&lt; hex &lt;&lt; a.buf &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">fun</span>(a);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">Output:</span><br><span class="line"><span class="built_in">Test</span>(): <span class="keyword">this</span>-&gt;buf @ <span class="number">0x5572ec8c2e70</span></span><br><span class="line"><span class="built_in">Test</span>(<span class="keyword">const</span> Test&amp;) called. <span class="keyword">this</span>-&gt;buf @ <span class="number">0x5572ec8c3eb0</span></span><br><span class="line"><span class="built_in">Test</span>(): <span class="keyword">this</span>-&gt;buf @ <span class="number">0x5572ec8c3ee0</span></span><br><span class="line"><span class="built_in">GetTemp</span>(): tmp.buf @ <span class="number">0x5572ec8c3ee0</span></span><br><span class="line"><span class="built_in">Test</span>(Test&amp;&amp;) called. <span class="keyword">this</span>-&gt;buf @ <span class="number">0x5572ec8c3ee0</span></span><br><span class="line">~<span class="built_in">Test</span>(): <span class="keyword">this</span>-&gt;buf @ <span class="number">0</span></span><br><span class="line"><span class="built_in">Test</span>(Test&amp;&amp;) called. <span class="keyword">this</span>-&gt;buf @ <span class="number">0x5572ec8c3ee0</span></span><br><span class="line">~<span class="built_in">Test</span>(): <span class="keyword">this</span>-&gt;buf @ <span class="number">0</span></span><br><span class="line">~<span class="built_in">Test</span>(): <span class="keyword">this</span>-&gt;buf @ <span class="number">0x5572ec8c3eb0</span></span><br><span class="line"><span class="built_in">main</span>() : a.buf @ <span class="number">0x5572ec8c3ee0</span></span><br><span class="line"><span class="built_in">Test</span>(<span class="keyword">const</span> Test&amp;) called. <span class="keyword">this</span>-&gt;buf @ <span class="number">0x5572ec8c3eb0</span></span><br><span class="line"><span class="built_in">fun</span>(Test t): t.buf @ <span class="number">0x5572ec8c3eb0</span></span><br><span class="line">~<span class="built_in">Test</span>(): <span class="keyword">this</span>-&gt;buf @ <span class="number">0x5572ec8c3eb0</span></span><br><span class="line">~<span class="built_in">Test</span>(): <span class="keyword">this</span>-&gt;buf @ <span class="number">0x5572ec8c3ee0</span></span><br><span class="line">~<span class="built_in">Test</span>(): <span class="keyword">this</span>-&gt;buf @ <span class="number">0x5572ec8c2e70</span></span><br></pre></td></tr></table></figure>
<p>可以发现，先拷贝构造了x，接着构造tmp，移动构造GetTemp，马上析构tmp，移动构造a，析构GetTemp，析构x。故4和5之间可能还会进行非常多的操作。</p>
<p>例3：删除移动构造函数且禁用返回值优化</p>
<p>编译指令g++-Wall -std=c++14 -O2 -fno-elide-constructors -o a.out source_file.cpp</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">int</span> * buf; <span class="comment">//// only for demo.</span></span><br><span class="line"><span class="built_in">Test</span>() &#123;</span><br><span class="line">buf = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>]; <span class="comment">//申请一块内存</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Test(): this-&gt;buf @ &quot;</span> &lt;&lt; hex &lt;&lt; buf &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">~<span class="built_in">Test</span>() &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;~Test(): this-&gt;buf @ &quot;</span> &lt;&lt; hex &lt;&lt; buf &lt;&lt; endl;</span><br><span class="line"><span class="keyword">if</span> (buf) <span class="keyword">delete</span>[] buf;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Test</span>(<span class="keyword">const</span> Test&amp; t) : <span class="built_in">buf</span>(<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>]) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++) </span><br><span class="line">buf[i] = t.buf[i]; <span class="comment">//拷贝数据</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Test(const Test&amp;) called. this-&gt;buf @ &quot;</span></span><br><span class="line">&lt;&lt; hex &lt;&lt; buf &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">Test <span class="title">GetTemp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Test tmp;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;GetTemp(): tmp.buf @ &quot;</span></span><br><span class="line">&lt;&lt; hex &lt;&lt; tmp.buf &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(Test t)</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;fun(Test t): t.buf @ &quot;</span></span><br><span class="line">&lt;&lt; hex &lt;&lt; t.buf &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Test a = <span class="built_in">GetTemp</span>();</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;main() : a.buf @ &quot;</span> &lt;&lt; hex &lt;&lt; a.buf &lt;&lt; endl;</span><br><span class="line"><span class="built_in">fun</span>(a);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">output：</span><br><span class="line"><span class="built_in">Test</span>(): <span class="keyword">this</span>-&gt;buf @ <span class="number">0x5638c49e8e70</span></span><br><span class="line"><span class="built_in">GetTemp</span>(): tmp.buf @ <span class="number">0x5638c49e8e70</span></span><br><span class="line"><span class="built_in">Test</span>(<span class="keyword">const</span> Test&amp;) called. <span class="keyword">this</span>-&gt;buf @ <span class="number">0x5638c49e9eb0</span></span><br><span class="line">~<span class="built_in">Test</span>(): <span class="keyword">this</span>-&gt;buf @ <span class="number">0x5638c49e8e70</span></span><br><span class="line"><span class="built_in">Test</span>(<span class="keyword">const</span> Test&amp;) called. <span class="keyword">this</span>-&gt;buf @ <span class="number">0x5638c49e8e70</span></span><br><span class="line">~<span class="built_in">Test</span>(): <span class="keyword">this</span>-&gt;buf @ <span class="number">0x5638c49e9eb0</span></span><br><span class="line"><span class="built_in">main</span>() : a.buf @ <span class="number">0x5638c49e8e70</span></span><br><span class="line"><span class="built_in">Test</span>(<span class="keyword">const</span> Test&amp;) called. <span class="keyword">this</span>-&gt;buf @ <span class="number">0x5638c49e9eb0</span></span><br><span class="line"><span class="built_in">fun</span>(Test t): t.buf @ <span class="number">0x5638c49e9eb0</span></span><br><span class="line">~<span class="built_in">Test</span>(): <span class="keyword">this</span>-&gt;buf @ <span class="number">0x5638c49e9eb0</span></span><br><span class="line">~<span class="built_in">Test</span>(): <span class="keyword">this</span>-&gt;buf @ <span class="number">0x5638c49e8e70</span></span><br></pre></td></tr></table></figure>
<p>这里只有拷贝构造，编译器没有默认生成移动构造。拷贝构造了返回值类后，立刻析构了tmp，释放了尾号为70的空间。注意到，空间释放之后马上就可以再次被使用，所以返回值类去拷贝构造a时，用的便是上次被析构释放出来的尾号为70的空间。接下来析构掉返回值类，释放了尾号为b0的空间，下一次fun(a)当中对形参的拷贝构造马上就利用了b0空间。</p>
<h2 id="移动语句">3.3 移动语句</h2>
<h3 id="语法与意义">3.3.1 语法与意义</h3>
<p>移动构造函数加快了右值初始化的构造速度，故而希望对左值调用移动构造函数以加快左值初始化的构造速度。</p>
<p>std::move函数 输入：左值（包括变量等，该左值一般不再使用。移动后就不能再次使用） 返回值：该左值对应的右值</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Test a;</span><br><span class="line">Test b = std::<span class="built_in">move</span>(a) </span><br><span class="line"><span class="comment">//对于上个实例中定义的Test类，该处调用移动构造函数对b进行初始化</span></span><br></pre></td></tr></table></figure>
<p>move函数本身不对对象做任何操作，<strong>仅做类型转换</strong>，即转换为右值。移动的具体操作在移动构造函数内实现。</p>
<p>右值引用结合std::move可以显著提高swap函数的性能。</p>
<p>std::move引起移动构造函数或移动赋值运算的调用。</p>
<p>例如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="built_in">swap</span>(T&amp; a, T&amp; b) &#123; </span><br><span class="line">     <span class="function">T <span class="title">tmp</span><span class="params">(a)</span></span>; <span class="comment">//copy a to tmp </span></span><br><span class="line">     a = b; <span class="comment">//copy b to a </span></span><br><span class="line">     b = tmp; <span class="comment">//copy tmp to b </span></span><br><span class="line">&#125;</span><br><span class="line">改写为：</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="built_in">swap</span>(T&amp; a, T&amp; b) &#123; </span><br><span class="line">     <span class="function">T <span class="title">tmp</span><span class="params">(std::move(a))</span></span>;</span><br><span class="line">     a = std::<span class="built_in">move</span>(b);</span><br><span class="line">     b = std::<span class="built_in">move</span>(tmp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>避免3次不必要的拷贝操作</p>
<h3 id="例子-2">3.3.2 例子</h3>
<p>禁用返回值优化</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Test</span>() &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Test()\n&quot;</span>);</span><br><span class="line">    &#125; <span class="comment">//默认构造函数</span></span><br><span class="line">    ~<span class="built_in">Test</span>() &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;~Test()\n&quot;</span>);</span><br><span class="line">    &#125; <span class="comment">//析构函数</span></span><br><span class="line">    <span class="built_in">Test</span>(<span class="keyword">const</span> Test &amp;con) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Test(const Test &amp;con)\n&quot;</span>);</span><br><span class="line">    &#125; <span class="comment">//拷贝构造函数  </span></span><br><span class="line"><span class="function">Test <span class="title">func</span><span class="params">(Test a)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Test</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Test a;</span><br><span class="line">  Test b = <span class="built_in">func</span>(a);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//我们用(1+)和(1-)这样的形式来对应类的构造和析构。</span></span><br><span class="line">output:</span><br><span class="line"><span class="built_in">Test</span>()                  <span class="comment">//(1+) 执行Test a；</span></span><br><span class="line"><span class="built_in">Test</span>(<span class="keyword">const</span> Test &amp;con) <span class="comment">//(2+)Test b = func(a);</span></span><br><span class="line">                        <span class="comment">//func(a)传参调用拷贝构造函数</span></span><br><span class="line"><span class="built_in">Test</span>()                  <span class="comment">//(3+)return Test();</span></span><br><span class="line">                        <span class="comment">//Test()对应的构造函数</span></span><br><span class="line"><span class="built_in">Test</span>(Test &amp;&amp;con)        <span class="comment">//(4+)return Test();</span></span><br><span class="line">                        <span class="comment">//为了传值调用的移动构造函数</span></span><br><span class="line">~<span class="built_in">Test</span>()                 <span class="comment">//(3-)return Test();</span></span><br><span class="line">                        <span class="comment">//Test()对应的析构函数</span></span><br><span class="line"><span class="built_in">Test</span>(Test &amp;&amp;con)        <span class="comment">//(5+)Test b = func(a);</span></span><br><span class="line">                        <span class="comment">//中给b传值时调用的移动构造函数</span></span><br><span class="line">~<span class="built_in">Test</span>()                 <span class="comment">//(4-)Test b = func(a);</span></span><br><span class="line">                       <span class="comment">//完成赋值后func(a)返回值对应的析构函数</span></span><br><span class="line">~<span class="built_in">Test</span>()                <span class="comment">//(2-)Test b = func(a);</span></span><br><span class="line">                       <span class="comment">//参数释放对应的析构函数</span></span><br><span class="line">~<span class="built_in">Test</span>()                <span class="comment">//(5-) 析构b</span></span><br><span class="line">~<span class="built_in">Test</span>()                <span class="comment">//(1-) 析构a</span></span><br></pre></td></tr></table></figure>
<p>这当中的析构顺序和3.2.3 例二完全相同。</p>
<h2 id="两类构造函数的调用时机">3.4 两类构造函数的调用时机</h2>
<h3 id="判断依据">3.4.1 判断依据</h3>
<p>引用的绑定规则：</p>
<p>拷贝构造函数的形参类型为常量左值引用，可以绑定常量左值、左值和右值。移动构造函数的形参类型为右值引用，可以绑定右值。引用的绑定存在优先级，例如常量左值引用和右值引用均能绑定右值，当传入实参类型为右值时优先匹配形参类型为右值引用的函数。</p>
<h3 id="拷贝构造函数的常见调用时机">3.4.2 拷贝构造函数的常见调用时机</h3>
<p>用一个类对象/引用/常量引用初始化另一个新的类对象 以类的对象为函数形参，传入实参为类的对象/引用/常量引用 函数返回类对象（类中未显式定义移动构造函数，不进行返回值优化）</p>
<h3 id="移动构造函数的常见调用时机">3.4.3 移动构造函数的常见调用时机</h3>
<p>用一个类对象的右值初始化另一个新的类对象（常配合std::move函数一起使用）: <code>Test b = func(a); Test b = std::move(a);</code> 与<code>Test b = a;</code> 不同</p>
<p>以类的对象为函数形参,传入实参为类对象的右值(常配合std::move函数使用):<code>func(Test());func(std::move(a));</code></p>
<p>与func(a)不同函数返回类对象（类中显式定义移动构造函数，不进行返回值优化）: <code>&#123;return Test(); or return tmp;&#125;</code>均调用移动构造</p>
<figure>
<img src="https://s2.loli.net/2022/01/11/upOzJL2Vgl9PYfB.png" alt="https://s2.loli.net/2022/01/11/upOzJL2Vgl9PYfB.png" /><figcaption aria-hidden="true">https://s2.loli.net/2022/01/11/upOzJL2Vgl9PYfB.png</figcaption>
</figure>
<p>注意到D是错的，返回值虽然是非静态临时变量的常量左值引用，但是返回类型根本不是引用，并不是返回临时变量的引用。</p>
<h1 id="四拷贝与移动赋值运算符">四、拷贝与移动赋值运算符</h1>
<h2 id="拷贝赋值运算符定义与意义">4.1 拷贝赋值运算符定义与意义</h2>
<p>已定义的对象之间相互赋值，可通过调用对象的“拷贝赋值运算符函数”来实现的。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">ClassName&amp; <span class="keyword">operator</span>= (<span class="keyword">const</span> ClassName&amp; right) &#123;</span><br><span class="line">   <span class="keyword">if</span> (<span class="keyword">this</span> != &amp;right) &#123;<span class="comment">// 避免自己赋值给自己</span></span><br><span class="line">        <span class="comment">// 将right对象中的内容拷贝到当前对象中...</span></span><br><span class="line">    &#125;</span><br><span class="line">   <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意作出区分：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">ClassName a;</span><br><span class="line">ClassName b;</span><br><span class="line">a = b;</span><br><span class="line"><span class="comment">//此处为拷贝复制运算</span></span><br><span class="line">ClassName a = b;</span><br><span class="line"><span class="comment">//此处为定义新对象</span></span><br></pre></td></tr></table></figure>
<p>赋值重载函数必须要是类的非静态成员函数(non-static member function)，不能是友元函数。因为复制运算是对于这个类而言的，显然是类函数。同时，赋值运算依赖于具体的对象，不能是静态的。（详见L4 创建与销毁2笔记）</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Test&amp; <span class="keyword">operator</span>= (<span class="keyword">const</span> Test&amp; right) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> == &amp;right)  cout &lt;&lt; <span class="string">&quot;same obj!\n&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++)</span><br><span class="line">            buf[i] = right.buf[i];  <span class="comment">//拷贝数据</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;operator=(const Test&amp;) called.\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="移动赋值运算符作用与意义">4.2 移动赋值运算符作用与意义</h2>
<p>和移动构造函数原理类似</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Test&amp; <span class="keyword">operator</span>= (Test&amp;&amp; right) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> == &amp;right)  cout &lt;&lt; <span class="string">&quot;same obj!\n&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span> &#123;  </span><br><span class="line">        <span class="keyword">this</span>-&gt;buf = right.buf;  <span class="comment">//直接赋值地址</span></span><br><span class="line">        right.buf = <span class="literal">nullptr</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;operator=(Test&amp;&amp;) called.\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>例如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">swap</span>(Test&amp; a, Test&amp; b) &#123; </span><br><span class="line">     <span class="function">Test <span class="title">tmp</span><span class="params">(std::move(a))</span></span>; <span class="comment">// 第一行调用移动构造函数</span></span><br><span class="line">     a = std::<span class="built_in">move</span>(b);       <span class="comment">// std::move的结果为右值引用，</span></span><br><span class="line">     b = std::<span class="built_in">move</span>(tmp); <span class="comment">// 后两行均调用移动赋值运算</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="调用时机-1">4.3 调用时机</h2>
<p>和拷贝/移动构造函数的调用时机类似，主要判断依据是引用的绑定规则</p>
<p>拷贝赋值运算符函数的形参类型为常量左值引用，可以绑定常量左值、左值和右值</p>
<p>移动赋值运算符函数的形参类型为右值引用，可以绑定右值(常量、表达式、函数返回)</p>
<p>引用的绑定存在优先级，例如常量左值引用和右值引用均能绑定右值，当赋值运算符右侧为右值时优先匹配形参类型为右值引用的赋值运算符函数</p>
<p>根据赋值运算符右侧变量的类型决定调用拷贝或移动赋值运算符函数</p>
<h2 id="自动合成的函数与运算符">4.4 自动合成的函数与运算符</h2>
<p>类中特殊的成员函数/运算符，即便用户不显式定义，编译器也会根据自身需要自动合成。</p>
<p>默认构造函数 拷贝构造函数 移动构造函数（C++11起） 拷贝赋值运算符 移动赋值运算符（C++11起） 析构函数</p>
<h1 id="五返回值优化">五、返回值优化</h1>
<p>该部分主要是第三次作业第二题的解析，建议结合阅读。</p>
<h2 id="优化条件">5.1 优化条件</h2>
<ol type="1">
<li>return的值类型与函数前面的返回值类型相同。</li>
<li>return的是一个局部对象的左值。</li>
</ol>
<h2 id="优化意义">5.2 优化意义</h2>
<ol type="1">
<li>在禁用返回值优化的条件下，如果一个函数的返回值是某个对象，那在函数返回前需要调用构造函数构建返回值。</li>
<li>即使我返回的东西就是我传进来的形参对象，返回前的这次构造仍然会发生，也就是这道题中f1的第二次构造函数调用。</li>
<li>但是对于返回值的构造调用的到底是移动构造函数，还是拷贝构造函数，对此C++11有规定：在无返回值优化的情况下，默认调用移动构造函数。</li>
<li>综上所述，返回一个局部对象的左值，通过移动构造构造返回值，返回值再移动赋值或移动构造给主函数语句。</li>
</ol>
<h2 id="优化实例">5.3 优化实例</h2>
<ul>
<li>如果开启了返回值优化，那么如果我的函数里新定义了一个Test对象。（比如：Test tmp; return tmp;)那编译器会给我优化，先用构造函数构造tmp，然后直接返回tmp。</li>
<li>这里甚至不会调用移动构造，也就是说甚至不是用tmp移动构造了要返回的对象，就是直接返回。</li>
<li>但如果没有开启优化，会首先调用默认构造函数构造tmp，然后调用移动构造函数将用tmp移动构造返回值。</li>
</ul>
<h2 id="返回值构造">5.4 返回值构造</h2>
<ul>
<li>如果返回值是普通的Test的话，那么函数返回时需要根据return后面的表达式来构造一个Test对象，所以才有移动构造或者拷贝构造的事情。</li>
<li>如果函数返回类型是const &amp;或者&amp;，那return的时候就没必要再构造新的对象了，直接返回相应的引用。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">(<span class="number">5</span>)<span class="function"><span class="keyword">const</span> Test&amp; <span class="title">F</span><span class="params">(<span class="keyword">const</span> Test&amp; a)</span></span>&#123;</span><br><span class="line">    Test b = a;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">Test</span>(<span class="number">1</span>);&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Test a;</span><br><span class="line">    <span class="keyword">const</span> Test &amp;A = <span class="built_in">F</span>(std::<span class="built_in">move</span>(a));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br></pre></td></tr></table></figure>
<p>比如此处，由于我的函数返回类型为引用，故而直接返回了返回值的引用。也就是Test(1)的常量左值引用。但是，在函数结束之后，这个常值引用所引用的Test(1)就被析构了，那这个常值引用就没用了。</p>
<p>总而言之，F的返回类型是一个常量左值引用，而返回值是Test(1)这一临时变量。临时变量会在函数体结束后被析构，从而引用失效。故而不能返回临时变量的引用，从而编译错误。</p>
<p>不过，Test(1)感觉只是个临时的右值，这能称为临时变量吗？ 实际上是可以的，如果去看编译得到的汇编码，<code>return test(1);</code>和<code>Test ret = test(1); return ret;</code>生成的汇编码是一样的。</p>
<h2 id="例子-3">5.5 例子</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> data = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">Test</span>()&#123;&#125;</span><br><span class="line">    <span class="built_in">Test</span>(<span class="keyword">const</span> Test&amp; t)&#123;&#125;</span><br><span class="line">    <span class="built_in">Test</span>(Test&amp;&amp; t)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">Test <span class="title">fn1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Test tmp; <span class="keyword">return</span> tmp; <span class="comment">//(1)</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Test&amp;&amp; <span class="title">fn2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Test tmp; <span class="keyword">return</span> <span class="built_in">move</span>(tmp); <span class="comment">//(2)</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Test <span class="title">fn3</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Test tmp; <span class="keyword">return</span> <span class="built_in">move</span>(tmp); <span class="comment">//(3)</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> Test&amp; a = <span class="built_in">fn1</span>(); <span class="comment">//(4)</span></span><br><span class="line">    Test&amp;&amp; b = <span class="built_in">fn1</span>(); <span class="comment">//(5)</span></span><br><span class="line">    Test c = <span class="built_in">fn1</span>(); <span class="comment">//(6)</span></span><br><span class="line">    Test&amp;&amp; d = <span class="built_in">fn2</span>(); <span class="comment">//(7)</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>建议做法包括(1)(4)(5)(6),避免多余拷贝，优化资源利用</p>
<p>Test fn1(); 满足返回值优化条件 可利用常量左值引用(2)，右值引用(5)，构造新对象(7)的方式接收返回值 不建议做法包括(2)(3)(7) (2)(7) d会指向被析构的tmp，出现运行错误 std::move()将左值转变为右值，不进行返回值优化，(3)会移动构造临时变量</p>
<p>关于(2)(7)，首先记住，如果返回引用，只有返回常量局部变量的左值引用是合法的，其他的都不合法。即使在某些编译器上通过了，也很危险。在较为严格的编译器上不一定能通过。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> &amp;<span class="title">func</span><span class="params">()</span></span>&#123;<span class="keyword">static</span> <span class="keyword">int</span> x=<span class="number">0</span>;<span class="keyword">return</span> x;&#125;</span><br></pre></td></tr></table></figure>
<p>用此处(2)(7)举例，(2)(7)的意思是返回了一个右值的右值引用，把这个右值引用的返回值赋值给了一个右值引用。</p>
<p>我们写出如下一个类似的例子：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span>&amp;&amp;<span class="title">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tmp=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">move</span>(tmp);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span>&amp;&amp;x=<span class="built_in">func</span>()+<span class="number">1</span>;</span><br><span class="line">    cout&lt;&lt;x;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>采用glot平台运行，output：2</p>
<p>采用retexter平台运行，编译指令采用clang++-Wall -std=c++14 -stdlib=libc++ -O2 -o a.out source_file.cpp，输出结果为完全不确定的整数。虽然直觉上可以完成赋值，但是由于tmp不是静态局部变量，逐语句结束后会被析构，导致x在访问非法内存。</p>
<p>采用retexter平台运行，编译指令采用g++--Wall -std=c++14 -O2 -o a.out source_file.cpp，输出结果为1，warning如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">1944460822</span>/source.cpp: In function <span class="string">&#x27;int&amp;&amp; func()&#x27;</span>:</span><br><span class="line"><span class="number">1944460822</span>/source.cpp:<span class="number">5</span>:<span class="number">25</span>: warning: function returns address of local variable [-Wreturn-local-addr]</span><br><span class="line"><span class="keyword">return</span> std::<span class="built_in">move</span>(tmp);</span><br><span class="line">                         ^</span><br><span class="line"><span class="number">1944460822</span>/source.cpp:<span class="number">4</span>:<span class="number">9</span>: note: declared here</span><br><span class="line">     <span class="keyword">int</span> tmp=<span class="number">1</span>;</span><br><span class="line">         ^~~</span><br><span class="line"><span class="number">1944460822</span>/source.cpp: In function ‘<span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>’:</span></span><br><span class="line"><span class="function"><span class="number">1944460822</span>/source.cpp:<span class="number">8</span>:<span class="number">19</span>: warning: ‘tmp’ is used uninitialized in this function [-Wuninitialized]</span></span><br><span class="line"><span class="function">     int&amp;&amp;x=</span><span class="built_in">func</span>()+<span class="number">1</span>;</span><br><span class="line">                   ^</span><br></pre></td></tr></table></figure>
<p>总而言之，返回非静态临时变量的引用风险极大。</p>
<p>备注：这个例子本身并不太好。如果实在想检测这样的函数，不应该用int类型。因为int是编译器自带的基本类型，采用过多的优化，故而glot输出2也是合理的。这样的检测最好使用自定义类型并完整地定义所有的构造，析构，拷贝构造，移动构造，移动赋值与拷贝赋值，确保编译器优化不多。</p>
<h1 id="六delete-与检测">六、delete 与检测</h1>
<p>该部分为第三次作业第三题的解析，建议结合阅读</p>
<hr />
<h2 id="delete-的意义">6.1 Delete 的意义</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">delete</span>[]array;<span class="comment">//delete：释放指针指向的内存区</span></span><br></pre></td></tr></table></figure>
<p>故而delete之后，内存区的数据就清除了。</p>
<p>delete释放的是指针指向的内存空间，指针变量本身仍然存在可以使用（用于赋值etc）。但是调用array[i]会产生运行时错误segmentation fault，因为它没有指向一块内存空间用于存储数据。</p>
<p>清除不等同于设为0。而且实际上，在这道题里面，如果delete之后还把array[i]赋值为0，不仅没有意义（因为内存已经被清除了），而且会因为调用了多次Node的拷贝构造函数而浪费了效率。比如下面这个写法纯属浪费效率，还有错误。在delete[]array;语句后，如果想进行赋值为0的操作，array要重新申请指向一块内存。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Vector&amp;Vector::<span class="keyword">operator</span>=(<span class="keyword">const</span> Vector&amp; other)</span><br><span class="line">&#123;	<span class="keyword">if</span> (<span class="keyword">this</span> != &amp;other) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;array != <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;<span class="keyword">delete</span>[]array;&#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; capacity; i++)</span><br><span class="line">        &#123;array[i] = <span class="number">0</span>;&#125;......&#125;</span><br></pre></td></tr></table></figure>
<h2 id="delete的检测">6.2 Delete的检测</h2>
<p>建议在delete前检测指针是否为空指针，因为空指针delete会报错。</p>
<h2 id="赋值的检测">6.3 赋值的检测</h2>
<p>和delete相似，建议赋值也要先进行检测，避免浪费效率</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Vector&amp;Vector::<span class="keyword">operator</span>=(<span class="keyword">const</span> Vector&amp; other)</span><br><span class="line">&#123;	   <span class="keyword">if</span> (<span class="keyword">this</span> != &amp;other) </span><br><span class="line">        <span class="comment">//建议赋值的时候检测是否相同，检测的原理本质上就是检测地址是否相同</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;array != <span class="literal">nullptr</span>)</span><br><span class="line">        &#123; <span class="keyword">delete</span>[]array; &#125;......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="七move-与类型转换">七、move 与类型转换</h1>
<p>该部分为第三次作业第二题的解析，建议结合阅读</p>
<hr />
<h2 id="move-的意义">7.1 move 的意义</h2>
<p>move的作用就是仅仅把左右值这个属性改为右值，其余的属性不变。</p>
<h2 id="例子-4">7.2 例子</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">Test <span class="title">F</span><span class="params">(<span class="keyword">const</span> Test&amp; a)</span></span>&#123;</span><br><span class="line">    Test b = std::<span class="built_in">move</span>(a);</span><br><span class="line"><span class="keyword">return</span> b;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Test A = <span class="built_in">F</span>(<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个地方极其有趣的是F函数体内对b的构造是采用了拷贝构造而非移动构造。</p>
<p>这是由于move和const的双重作用。如同前文所述，move一定可以把任意对象调整为右值，不管是不是const。</p>
<p>深层次地说，变量储存在内存里的时候存的都是它的数据，而不会专门开辟一块空间来说明它是不是const，是不是&amp;等，const和&amp;这些“类型”是由编译器来处理的。</p>
<p>我们说类型转换，指的就是改变类型，而不变动它在内存里的储存形式。比如一个指针，它在内存里存的就是一串数字表示地址，我们看它的内存情况时，完全可以把这块内存当做存的是一个整型变量。我们强行把指针当做整型变量来看的时候就是进行了一个类型转换。</p>
<p>所以std::move(a)这个表达式的类型就是const&amp;&amp;，因为它发生了类型转换。而转换之后，a转为const&amp;&amp;，这是一个常量右值引用，C++固定其只能够被const&amp;绑定。故而在构造函数重载的情况下调用了相应const&amp;的拷贝构造函数。</p>
<h2 id="进一步讨论">7.3 进一步讨论</h2>
<figure>
<img src="https://s2.loli.net/2022/01/11/DsEUd8jN6yZuRoh.png" alt="https://s2.loli.net/2022/01/11/DsEUd8jN6yZuRoh.png" /><figcaption aria-hidden="true">https://s2.loli.net/2022/01/11/DsEUd8jN6yZuRoh.png</figcaption>
</figure>
<p>这张表给出了关于绑定和左右值的关系。左边的一列是参数的属性，Lvalue是指左值，rvalue是指右值，const是指常量。上方一行给出了能够绑定的类型。而表中的次序代表多种绑定时的优先级。从而可见，常量右值优先在我们的两个构造函数当中只能绑定const&amp;。（因为没有const&amp;&amp;类型的重载，故而绑定的是）从而调用了拷贝构造函数。</p>
<h1 id="八置空性讨论">八、置空性讨论</h1>
<h2 id="析构置空">8.0 析构置空</h2>
<p>析构函数需要将成员数据中的指针指向的内存空间置空（delete）</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Vector::~<span class="built_in">Vector</span>()</span><br><span class="line">&#123;<span class="keyword">if</span> (array != <span class="literal">nullptr</span>) &#123; <span class="keyword">delete</span>[]array; &#125;&#125;</span><br></pre></td></tr></table></figure>
<p>下文以A=B为例，讨论赋值过程中的置空性</p>
<h2 id="移动置空">8.1 移动置空</h2>
<ul>
<li>每次移动时，我们将B完全置空但是不delete。</li>
</ul>
<h3 id="移动和拷贝的语义区别">8.1.1 移动和拷贝的语义区别</h3>
<p>移动和拷贝的语义区别在于，被拷贝的对象之后还可能会被使用的，而被移动的对象必须置空（但不是delete，delete出现在赋值置空和析构置空当中）。因为移动的本质原理是把对同一块内存空间更换为新指针，并且将原指针置空。</p>
<h3 id="移动和拷贝的原理区别">8.1.2 移动和拷贝的原理区别</h3>
<p>8.1.2.1拷贝的原理</p>
<p>A与B各自有一个指针，如果A！=B时，两个指针指向两块独立的内存空间。（A=B时无需拷贝）现将A内存空间里所有数据清除（为什么要清除在2.2.1进行了解释），接着把B的内存空间内所有数据传递给A的内存空间。这一传递过程不会破坏B的数据，但是效率较低。</p>
<p>8.1.2.2移动的原理</p>
<p>A与B各自有一个指针。如果A！=B时，两个指针指向两块独立的内存空间。（A=B时无需移动）如果此时A的指针指向的内存空间不为空，也就是A指针不为空指针，那么将A的指针指向的内存空间通过delete清除，A指针即转为空指针。将B的指针赋值给A的指针，并将B指针置为空指针。这一过程实际上是改变了内存空间的指针但是没有改变内存空间。</p>
<h3 id="移动过程中b指针置空">8.1.3 移动过程中B指针置空</h3>
<p>在析构函数里，我们会调用delete。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Vector::~<span class="built_in">Vector</span>()</span><br><span class="line">&#123;<span class="keyword">if</span> (array != <span class="literal">nullptr</span>) &#123; <span class="keyword">delete</span>[]array; &#125;&#125;</span><br></pre></td></tr></table></figure>
<p>倘若不把B指针置空，那么我们会析构delete一次B指针指向的内存空间，然而A指针不为空。在析构时，又将对同一个内存空间delete一次。Delete一空的空间是不允许的。故而移动构造必然要将B指针置空以避免多次delete同一空间。这样也导致了B指针不能再次使用（整个B无法再去赋值），这就是为什么移动构造必然要破坏用来构造的对象：因为不能出现两个指针指向同一块空间的情况。</p>
<p>同样的，为了模拟这种对B指针的破坏性，在第三部分技术细节里提及了Node的移动构造机制。这一机制也将“B指针”（实际上是原来的int）置空，故而被移动了的Node也是没法再次利用的。</p>
<h3 id="移动过程中b完全置空">8.1.4 移动过程中B完全置空</h3>
<p>我们在上文已经叙述了为什么需要将B指针置空。实际上，由于B对象被移动之后已经不再次使用，需要将其完全置空（所有的成员数据都要置空，而不只是B里面的指针对象），从而避免内存泄漏。（这里点到为止，具体的细节参见第三部分）</p>
<h2 id="赋值置空">8.2 赋值置空</h2>
<ul>
<li>Def每次赋值时，我们需要通过delete将A置空</li>
</ul>
<h3 id="拷贝赋值">8.2.1 拷贝赋值</h3>
<p>拷贝赋值时，检测完A==B后，我们需要使用delete将A置空。</p>
<p>这里为什么要先清除A的原内存空间？</p>
<p>首先，我们的移动赋值需要二者赋值完后完全相同，如果A原内存空间超出B的那部分容积有多于内容，不清除将A则无法使得A与B完全相同。其次，不清除更大的问题是内存泄露严重。</p>
<p>注意到拷贝赋值现将A的内存空间delete之后，A的指针需要指向一块内存空间才能使A接受B的拷贝赋值。故需要申请新的内存空间。（与B的内存空间大小完全相同）</p>
<h3 id="移动赋值">8.2.2 移动赋值</h3>
<p>综合前文所述，移动需要将B完全置空但是不delete，而赋值需要将A通过delete置空之后再次申请新的空间。所以用B移动赋值A的时候需要两次置空，一次delete（对A的）而另一次不delete（对B的）。</p>
<h1 id="九类型转换">九、类型转换</h1>
<h2 id="意义">9.1 意义</h2>
<p>当编译器发现表达式和函数调用所需的数据类型和实际类型不同时，便会进行自动类型转换。</p>
<p>自动类型转换可通过定义特定的<strong>转换运算符</strong>和<strong>构造函数</strong>来完成。</p>
<p>除自动类型转换外，在有必要的时候还可以进行强制类型转换。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> d)</span> </span>&#123; &#125; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="number">3.5</span>);</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;c&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="语法">9.2 语法</h2>
<p>方法一：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dst</span> &#123;</span> <span class="comment">//目标类Destination</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Dst</span>() &#123; cout &lt;&lt; <span class="string">&quot;Dst::Dst()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Src</span> &#123;</span> <span class="comment">//源类Source</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Src</span>() &#123; cout &lt;&lt; <span class="string">&quot;Src::Src()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">operator</span> <span class="title">Dst</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Src::operator Dst() called&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Dst</span>(); </span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在源类中定义“源类中重载目标类型转换运算符”</p>
<p>注意：不需要指定返回类型，因为operator后Dst()已经指明，返回值是Dst()，返回函数名故而不需要返回类型。这是类型转换的固定语法，如同构造函数不需要就好。</p>
<p>方法二：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Src</span>;</span>  <span class="comment">// 前置类型声明，因为在Dst中要用到Src类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dst</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Dst</span>() &#123; cout &lt;&lt; <span class="string">&quot;Dst::Dst()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">  <span class="built_in">Dst</span>(<span class="keyword">const</span> Src&amp; s) &#123; </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Dst::Dst(const Src&amp;)&quot;</span> &lt;&lt; endl; </span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Src</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Src</span>() &#123; cout &lt;&lt; <span class="string">&quot;Src::Src()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在目标类中定义“目标类中定义源类对象作参数的构造函数”。</p>
<p>两种方法任选一种即可运行。 但是一定要注意区分两种转换方式，如果没有做区分，常常会导致转换方向错误。此外，两种自动类型转换的方法不能同时使用，使用时必须任选其中一种。</p>
<h2 id="例子-5">9.3 例子</h2>
<p>例1：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dst</span> &#123;</span> <span class="comment">//目标类Destination</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Dst</span>() &#123; cout &lt;&lt; <span class="string">&quot;Dst::Dst()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Src</span> &#123;</span> <span class="comment">//源类Source</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Src</span>() &#123; cout &lt;&lt; <span class="string">&quot;Src::Src()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">operator</span> <span class="title">Dst</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Src::operator Dst() called&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Dst</span>(); </span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Transform</span><span class="params">(Dst d)</span> </span>&#123; &#125; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  Src s;</span><br><span class="line">  <span class="function">Dst <span class="title">d1</span><span class="params">(s)</span></span>;</span><br><span class="line">  Dst d2 = s; </span><br><span class="line">  <span class="built_in">Transform</span>(s); </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">output：</span><br><span class="line">Src::<span class="built_in">Src</span>()</span><br><span class="line"><span class="function">Src::<span class="keyword">operator</span> <span class="title">Dst</span><span class="params">()</span> called</span></span><br><span class="line"><span class="function"><span class="title">Dst::Dst</span><span class="params">()</span></span></span><br><span class="line"><span class="function">Src::<span class="keyword">operator</span> <span class="title">Dst</span><span class="params">()</span> called</span></span><br><span class="line"><span class="function"><span class="title">Dst::Dst</span><span class="params">()</span></span></span><br><span class="line"><span class="function">Src::<span class="keyword">operator</span> <span class="title">Dst</span><span class="params">()</span> called</span></span><br><span class="line"><span class="function"><span class="title">Dst::Dst</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>
<p>注意到强制类型转换并不会发生类似切片的效果，只是用某一个类型生成了另一类型而已。这里主函数内Dst d2 = s;等价于Dst d2(s)；而<code>void Transform(Dst d);</code>调用的参数本该是Dst类型，由于定义了从s到Dst的类型转换，故而也可以执行，并进行了转换。</p>
<p>例2：寻找错误</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SmallInt</span>;</span></span><br><span class="line"><span class="function"><span class="keyword">operator</span> <span class="title">int</span><span class="params">(SmallInt&amp;)</span></span>; <span class="comment">//错误：不是成员函数；无论哪种转换方式，都是定义在类内的成员函数</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SmallInt</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="keyword">operator</span> <span class="title">int</span><span class="params">()</span> <span class="keyword">const</span></span>;   </span><br><span class="line"><span class="comment">//错误：不能返回类型 </span></span><br><span class="line"><span class="function"><span class="keyword">operator</span> <span class="title">int</span><span class="params">(<span class="keyword">int</span> = <span class="number">0</span>)</span> <span class="keyword">const</span></span>; <span class="comment">//错误：在源类中定义目标类的重载运算符需要参数列表为空</span></span><br><span class="line"><span class="keyword">operator</span> <span class="keyword">int</span>*() <span class="keyword">const</span> &#123;<span class="keyword">return</span> <span class="number">42</span>;&#125; </span><br><span class="line"><span class="comment">//错误：42不是一个合法指针,本意：将SmallInt对象转换为int* 指针</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>例3：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SmallInt</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">SmallInt</span> (<span class="keyword">int</span> i=<span class="number">0</span>): <span class="built_in">val</span>(i)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;SmallInt_Init&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//构造函数:以int为参数的SmallInt构造函数，从而将int转换为SmallInt</span></span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">int</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; </span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Int_Transform&quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">return</span> val; </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//转换运算符:从SmallInt转换为int；在源类中定义“目标类型转换运算符”</span></span><br><span class="line"><span class="comment">//注意到这个例子既有int到smallint的转换，也有smallint到int的转换。</span></span><br><span class="line"><span class="comment">//smallint既做了源类，又做了目标类</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        cout &lt;&lt; val &lt;&lt; endl; </span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">size_t</span> val;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    SmallInt si;</span><br><span class="line">    si.<span class="built_in">print</span>();</span><br><span class="line">    si = <span class="number">4.10</span>;</span><br><span class="line">    si.<span class="built_in">print</span>();</span><br><span class="line">    si = si + <span class="number">3</span>;</span><br><span class="line">    si.<span class="built_in">print</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">output:</span><br><span class="line">SmallInt_Init</span><br><span class="line"><span class="number">0</span></span><br><span class="line">SmallInt_Init</span><br><span class="line"><span class="number">4</span></span><br><span class="line">Int_Transform</span><br><span class="line">SmallInt_Init</span><br><span class="line"><span class="number">7</span></span><br></pre></td></tr></table></figure>
<p>首先，这里定义的val是size_t类型。它是一种“整型”类型，里面保存的是一个整数，就像int, long一样。这种整数用来记录一个大小(size)。</p>
<p>size_t的全称应该是size type，就是说“一种用来记录大小的数据类型”。通常我们用sizeof(XXX)操作，这个操作所得到的结果就是size_t类型。因为size_t类型的数据其实是保存了一个整数，所以它也可以做加减乘除，也可以转化为int并赋值给int类型的变量。</p>
<p>注意第二个SmallInt_Init;出现在si = 4.10，首先内置类型转换将double转换为int，然后调用构造函数构造了以int 4为参数的SmallInt（4），隐式地将4转换成SmallInt类型。之后把这个Smallint（4）赋值给Si，系统自动生成了Smallint的赋值运算符重载。</p>
<p><code>si = si + 3；</code>首先执行si + 3，之后执行赋值语句。</p>
<p>这可能有两种情况：情况一，把si转为int，然后执行int的加法，得到7；得到7之后的步骤即为赋值语句si=7，和上方的si=4类似。调用构造函数构造了以int 7为参数的SmallInt（7），隐式地将7转换成SmallInt类型，之后再调用编译器自动生成的赋值运算符重载。情况二，把3转为smallint再和si相加。这就有个问题，我们没有显式地重载smallint的+运算符，故而无法这个转换即是完成了，也无法继续。</p>
<p>另一方面，如果我们在此基础上重载了smallint的+运算符，我们不仅有smallint转为int然后两个int相加再构造smallint(7)再赋值这条路，同时还有3利用构造函数隐式转为smallint之后两个smallint相加，再赋值给si这条路。会出现路径歧义而编译错误。如何只进行第二条路，我们通过例4来实现。</p>
<p>例4：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SmallInt</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">SmallInt</span>(<span class="keyword">int</span> i=<span class="number">0</span>): <span class="built_in">val</span>(i)&#123;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;SmallInt_Init&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    SmallInt&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> SmallInt &amp;src)&#123;</span><br><span class="line">        <span class="keyword">if</span>( <span class="keyword">this</span> == &amp;src ) <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        cout &lt;&lt;<span class="string">&quot;operator=&quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">this</span>-&gt;val = src.val;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">SmallInt <span class="keyword">operator</span>+(<span class="keyword">const</span> SmallInt&amp; b) &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;operator+&quot;</span>&lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">SmallInt</span>(<span class="keyword">this</span>-&gt;val + b.val);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">size_t</span> val;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    SmallInt si;</span><br><span class="line">    si = <span class="number">4.10</span>;</span><br><span class="line">    si = si + <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">output：</span><br><span class="line">SmallInt_Init</span><br><span class="line">SmallInt_Init</span><br><span class="line"><span class="keyword">operator</span>=</span><br><span class="line">SmallInt_Init</span><br><span class="line"><span class="keyword">operator</span>+</span><br><span class="line">SmallInt_Init</span><br><span class="line"><span class="keyword">operator</span>=</span><br></pre></td></tr></table></figure>
<p>这一例子验证了之前的理解。我们有了si=smallint（4）对应的=拷贝赋值运算符重载的输出。在si=si+3这一步，首先把3转为了smallint（3），接着利用了operator+。注意到operator+的返回值再次调用了构造函数，接着把返回值拷贝赋值给si。</p>
<p>但是例四是如何避免了路径歧义呢？注意到我们删除了从smallint转为int的类型转换运算符，故而没有路径一，只有路径二。</p>
<h2 id="禁止自动类型转换">9.4 禁止自动类型转换</h2>
<p>如果用<strong>explicit</strong>修饰类型转换运算符或类型转换构造函数，则相应的类型转换必须显式地进行。例如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="keyword">operator</span> <span class="title">Dst</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">或使用</span><br><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">Dst</span><span class="params">(<span class="keyword">const</span> Src&amp; s)</span></span>;</span><br></pre></td></tr></table></figure>
<p>在例1中如果使用explicit，那么：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  Src s;</span><br><span class="line">  <span class="function">Dst <span class="title">d1</span><span class="params">(s)</span></span>;        <span class="comment">//可以执行，被认为是显式初始化</span></span><br><span class="line">  <span class="comment">//Dst d2 = s;     //错误，隐式转换</span></span><br><span class="line">  <span class="comment">//Transform(s); //错误，隐式转换</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="四类强制类型转换">9.5 四类强制类型转换</h2>
<p>const_cast，去除类型的const或volatile属性。 static_cast，类似于C风格的强制转换。无条件转换，静态类型转换。 dynamic_cast，动态类型转换，如派生类和基类之间的多态类型转换。 reinterpret_cast，仅仅重新解释类型，但没有进行二进制的转换。</p>
<p>之前的例子重写为：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  Src s;</span><br><span class="line">  <span class="function">Dst <span class="title">d1</span><span class="params">(s)</span></span>;</span><br><span class="line"></span><br><span class="line">  Dst d2 = <span class="keyword">static_cast</span>&lt;Dst&gt;(s);</span><br><span class="line">  <span class="built_in">Transform</span>(<span class="keyword">static_cast</span>&lt;Dst&gt;(s));</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">Eren Zhao</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="http://example.com/2022/01/12/Lecture/%E4%BB%8E%E5%89%8D%E7%9A%84%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/OOP/L6%20%E5%BC%95%E7%94%A8%E4%B8%8E%E5%A4%8D%E5%88%B6/">http://example.com/2022/01/12/Lecture/%E4%BB%8E%E5%89%8D%E7%9A%84%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/OOP/L6%20%E5%BC%95%E7%94%A8%E4%B8%8E%E5%A4%8D%E5%88%B6/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://pic.imgdb.cn/item/623475d95baa1a80ab3b102b.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/01/12/Lecture/%E4%BB%8E%E5%89%8D%E7%9A%84%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/OOP/L8%20%E8%99%9A%E5%87%BD%E6%95%B0/"><img class="prev-cover" src="https://s2.loli.net/2022/03/08/jPxmqXH5YvbsgOu.png" onerror="onerror=null;src='https://wkphoto.cdn.bcebos.com/1f178a82b9014a9058a735deb9773912b31bee3c.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">Previous Post</div><div class="prev_info">oop笔记  L8  虚函数</div></div></a></div><div class="next-post pull-right"><a href="/2022/01/12/Lecture/%E4%BB%8E%E5%89%8D%E7%9A%84%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/OOP/L9%20%E5%A4%9A%E6%80%81%E4%B8%8E%E6%A8%A1%E6%9D%BF/"><img class="next-cover" src="https://pic.imgdb.cn/item/623475f75baa1a80ab3b54f1.jpg" onerror="onerror=null;src='https://wkphoto.cdn.bcebos.com/1f178a82b9014a9058a735deb9773912b31bee3c.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">Next Post</div><div class="next_info">oop笔记  L9  多态与模板</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/avatar.jpeg" onerror="this.onerror=null;this.src='/img/friend.jpg'" alt="avatar"/></div><div class="author-info__name">Eren Zhao</div><div class="author-info__description">求道之人，不论寒暑，无问西东</div></div><div class="card-info-data is-center"><div class="card-info-data-item"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">166</div></a></div><div class="card-info-data-item"><a href="/tags/"><div class="headline">Tags</div><div class="length-num">53</div></a></div><div class="card-info-data-item"><a href="/categories/"><div class="headline">Categories</div><div class="length-num">12</div></a></div></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/zhaochenyang20"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>Announcement</span></div><div class="announcement_content">但是，当我醒来，我看见一片无垠的自由</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Catalog</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#l6-%E5%BC%95%E7%94%A8%E4%B8%8E%E5%A4%8D%E5%88%B6"><span class="toc-number">1.</span> <span class="toc-text">L6 引用与复制</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%80%E5%B8%B8%E9%87%8F%E5%BC%95%E7%94%A8"><span class="toc-number">2.</span> <span class="toc-text">一、常量引用</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E9%87%8F%E5%BC%95%E7%94%A8%E7%9A%84%E6%84%8F%E4%B9%89"><span class="toc-number">2.1.</span> <span class="toc-text">1.1 常量引用的意义</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">3.</span> <span class="toc-text">二、拷贝构造函数</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%E4%B8%8E%E8%AF%AD%E6%B3%95%E8%A7%84%E5%88%99"><span class="toc-number">3.1.</span> <span class="toc-text">2.1 定义与语法规则</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B0%83%E7%94%A8%E6%97%B6%E6%9C%BA"><span class="toc-number">3.2.</span> <span class="toc-text">2.2 调用时机</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9A%90%E5%BC%8F%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">3.3.</span> <span class="toc-text">2.3 隐式拷贝构造函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F"><span class="toc-number">3.4.</span> <span class="toc-text">2.4 执行顺序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E7%9A%84%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F"><span class="toc-number">3.4.1.</span> <span class="toc-text">2.4.1 基本的执行顺序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BE%8B%E5%AD%90"><span class="toc-number">3.4.2.</span> <span class="toc-text">2.4.2 例子</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E7%BC%BA%E9%99%B7"><span class="toc-number">3.5.</span> <span class="toc-text">2.5 拷贝构造函数的缺陷</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95"><span class="toc-number">3.6.</span> <span class="toc-text">2.6 解决方法</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%89%E7%A7%BB%E5%8A%A8%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">4.</span> <span class="toc-text">三、移动构造函数</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%B3%E5%80%BC%E4%B8%8E%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8"><span class="toc-number">4.1.</span> <span class="toc-text">3.1 右值与右值引用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B7%A6%E5%8F%B3%E5%80%BC"><span class="toc-number">4.1.1.</span> <span class="toc-text">3.1.1 左右值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8"><span class="toc-number">4.1.2.</span> <span class="toc-text">3.1.2 右值引用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A7%BB%E5%8A%A8%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">4.2.</span> <span class="toc-text">3.2 移动构造函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%E4%B8%8E%E6%84%8F%E4%B9%89"><span class="toc-number">4.2.1.</span> <span class="toc-text">3.2.1 定义与意义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%A4%E7%A7%8D%E6%9E%84%E9%80%A0%E6%9C%AC%E8%B4%A8%E5%8C%BA%E5%88%AB"><span class="toc-number">4.2.2.</span> <span class="toc-text">3.2.2 两种构造本质区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BE%8B%E5%AD%90-1"><span class="toc-number">4.2.3.</span> <span class="toc-text">3.2.3 例子</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A7%BB%E5%8A%A8%E8%AF%AD%E5%8F%A5"><span class="toc-number">4.3.</span> <span class="toc-text">3.3 移动语句</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%AD%E6%B3%95%E4%B8%8E%E6%84%8F%E4%B9%89"><span class="toc-number">4.3.1.</span> <span class="toc-text">3.3.1 语法与意义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BE%8B%E5%AD%90-2"><span class="toc-number">4.3.2.</span> <span class="toc-text">3.3.2 例子</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%A4%E7%B1%BB%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E8%B0%83%E7%94%A8%E6%97%B6%E6%9C%BA"><span class="toc-number">4.4.</span> <span class="toc-text">3.4 两类构造函数的调用时机</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A4%E6%96%AD%E4%BE%9D%E6%8D%AE"><span class="toc-number">4.4.1.</span> <span class="toc-text">3.4.1 判断依据</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E5%B8%B8%E8%A7%81%E8%B0%83%E7%94%A8%E6%97%B6%E6%9C%BA"><span class="toc-number">4.4.2.</span> <span class="toc-text">3.4.2 拷贝构造函数的常见调用时机</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A7%BB%E5%8A%A8%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E5%B8%B8%E8%A7%81%E8%B0%83%E7%94%A8%E6%97%B6%E6%9C%BA"><span class="toc-number">4.4.3.</span> <span class="toc-text">3.4.3 移动构造函数的常见调用时机</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9B%9B%E6%8B%B7%E8%B4%9D%E4%B8%8E%E7%A7%BB%E5%8A%A8%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">5.</span> <span class="toc-text">四、拷贝与移动赋值运算符</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8B%B7%E8%B4%9D%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6%E5%AE%9A%E4%B9%89%E4%B8%8E%E6%84%8F%E4%B9%89"><span class="toc-number">5.1.</span> <span class="toc-text">4.1 拷贝赋值运算符定义与意义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A7%BB%E5%8A%A8%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6%E4%BD%9C%E7%94%A8%E4%B8%8E%E6%84%8F%E4%B9%89"><span class="toc-number">5.2.</span> <span class="toc-text">4.2 移动赋值运算符作用与意义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B0%83%E7%94%A8%E6%97%B6%E6%9C%BA-1"><span class="toc-number">5.3.</span> <span class="toc-text">4.3 调用时机</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%87%AA%E5%8A%A8%E5%90%88%E6%88%90%E7%9A%84%E5%87%BD%E6%95%B0%E4%B8%8E%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">5.4.</span> <span class="toc-text">4.4 自动合成的函数与运算符</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%94%E8%BF%94%E5%9B%9E%E5%80%BC%E4%BC%98%E5%8C%96"><span class="toc-number">6.</span> <span class="toc-text">五、返回值优化</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BC%98%E5%8C%96%E6%9D%A1%E4%BB%B6"><span class="toc-number">6.1.</span> <span class="toc-text">5.1 优化条件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BC%98%E5%8C%96%E6%84%8F%E4%B9%89"><span class="toc-number">6.2.</span> <span class="toc-text">5.2 优化意义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BC%98%E5%8C%96%E5%AE%9E%E4%BE%8B"><span class="toc-number">6.3.</span> <span class="toc-text">5.3 优化实例</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%94%E5%9B%9E%E5%80%BC%E6%9E%84%E9%80%A0"><span class="toc-number">6.4.</span> <span class="toc-text">5.4 返回值构造</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BE%8B%E5%AD%90-3"><span class="toc-number">6.5.</span> <span class="toc-text">5.5 例子</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%ADdelete-%E4%B8%8E%E6%A3%80%E6%B5%8B"><span class="toc-number">7.</span> <span class="toc-text">六、delete 与检测</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#delete-%E7%9A%84%E6%84%8F%E4%B9%89"><span class="toc-number">7.1.</span> <span class="toc-text">6.1 Delete 的意义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#delete%E7%9A%84%E6%A3%80%E6%B5%8B"><span class="toc-number">7.2.</span> <span class="toc-text">6.2 Delete的检测</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B5%8B%E5%80%BC%E7%9A%84%E6%A3%80%E6%B5%8B"><span class="toc-number">7.3.</span> <span class="toc-text">6.3 赋值的检测</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%83move-%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-number">8.</span> <span class="toc-text">七、move 与类型转换</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#move-%E7%9A%84%E6%84%8F%E4%B9%89"><span class="toc-number">8.1.</span> <span class="toc-text">7.1 move 的意义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BE%8B%E5%AD%90-4"><span class="toc-number">8.2.</span> <span class="toc-text">7.2 例子</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E4%B8%80%E6%AD%A5%E8%AE%A8%E8%AE%BA"><span class="toc-number">8.3.</span> <span class="toc-text">7.3 进一步讨论</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%AB%E7%BD%AE%E7%A9%BA%E6%80%A7%E8%AE%A8%E8%AE%BA"><span class="toc-number">9.</span> <span class="toc-text">八、置空性讨论</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%90%E6%9E%84%E7%BD%AE%E7%A9%BA"><span class="toc-number">9.1.</span> <span class="toc-text">8.0 析构置空</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A7%BB%E5%8A%A8%E7%BD%AE%E7%A9%BA"><span class="toc-number">9.2.</span> <span class="toc-text">8.1 移动置空</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A7%BB%E5%8A%A8%E5%92%8C%E6%8B%B7%E8%B4%9D%E7%9A%84%E8%AF%AD%E4%B9%89%E5%8C%BA%E5%88%AB"><span class="toc-number">9.2.1.</span> <span class="toc-text">8.1.1 移动和拷贝的语义区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A7%BB%E5%8A%A8%E5%92%8C%E6%8B%B7%E8%B4%9D%E7%9A%84%E5%8E%9F%E7%90%86%E5%8C%BA%E5%88%AB"><span class="toc-number">9.2.2.</span> <span class="toc-text">8.1.2 移动和拷贝的原理区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A7%BB%E5%8A%A8%E8%BF%87%E7%A8%8B%E4%B8%ADb%E6%8C%87%E9%92%88%E7%BD%AE%E7%A9%BA"><span class="toc-number">9.2.3.</span> <span class="toc-text">8.1.3 移动过程中B指针置空</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A7%BB%E5%8A%A8%E8%BF%87%E7%A8%8B%E4%B8%ADb%E5%AE%8C%E5%85%A8%E7%BD%AE%E7%A9%BA"><span class="toc-number">9.2.4.</span> <span class="toc-text">8.1.4 移动过程中B完全置空</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B5%8B%E5%80%BC%E7%BD%AE%E7%A9%BA"><span class="toc-number">9.3.</span> <span class="toc-text">8.2 赋值置空</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8B%B7%E8%B4%9D%E8%B5%8B%E5%80%BC"><span class="toc-number">9.3.1.</span> <span class="toc-text">8.2.1 拷贝赋值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A7%BB%E5%8A%A8%E8%B5%8B%E5%80%BC"><span class="toc-number">9.3.2.</span> <span class="toc-text">8.2.2 移动赋值</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B9%9D%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-number">10.</span> <span class="toc-text">九、类型转换</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%84%8F%E4%B9%89"><span class="toc-number">10.1.</span> <span class="toc-text">9.1 意义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%AD%E6%B3%95"><span class="toc-number">10.2.</span> <span class="toc-text">9.2 语法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BE%8B%E5%AD%90-5"><span class="toc-number">10.3.</span> <span class="toc-text">9.3 例子</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A6%81%E6%AD%A2%E8%87%AA%E5%8A%A8%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-number">10.4.</span> <span class="toc-text">9.4 禁止自动类型转换</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E7%B1%BB%E5%BC%BA%E5%88%B6%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-number">10.5.</span> <span class="toc-text">9.5 四类强制类型转换</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Post</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2022/05/02/%E9%9A%8F%E7%AC%94/%E6%B8%85%E5%8D%8E%E5%9B%AD%E6%97%A5%E8%AE%B0/%E6%B8%85%E5%8D%8E%E5%9B%AD%E6%97%A5%E8%AE%B0--%E7%AC%AC%E5%9B%9B%E9%83%A8/" title="清华园日记——第四部"><img src="https://pic.imgdb.cn/item/620a7c122ab3f51d9109df33.jpg" onerror="this.onerror=null;this.src='https://wkphoto.cdn.bcebos.com/1f178a82b9014a9058a735deb9773912b31bee3c.jpg'" alt="清华园日记——第四部"/></a><div class="content"><a class="title" href="/2022/05/02/%E9%9A%8F%E7%AC%94/%E6%B8%85%E5%8D%8E%E5%9B%AD%E6%97%A5%E8%AE%B0/%E6%B8%85%E5%8D%8E%E5%9B%AD%E6%97%A5%E8%AE%B0--%E7%AC%AC%E5%9B%9B%E9%83%A8/" title="清华园日记——第四部">清华园日记——第四部</a><time datetime="2022-05-01T23:08:23.503Z" title="Created 2022-05-02 07:08:23">2022-05-02</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/04/25/%E9%9A%8F%E7%AC%94/%E5%BF%83%E5%BF%83%E5%BF%B5%E5%BF%B5/%E6%B1%82%E9%81%93%E4%B9%8B%E4%BA%BA/" title="求道之人，不问寒暑"><img src="https://pic.imgdb.cn/item/623475e95baa1a80ab3b366f.jpg" onerror="this.onerror=null;this.src='https://wkphoto.cdn.bcebos.com/1f178a82b9014a9058a735deb9773912b31bee3c.jpg'" alt="求道之人，不问寒暑"/></a><div class="content"><a class="title" href="/2022/04/25/%E9%9A%8F%E7%AC%94/%E5%BF%83%E5%BF%83%E5%BF%B5%E5%BF%B5/%E6%B1%82%E9%81%93%E4%B9%8B%E4%BA%BA/" title="求道之人，不问寒暑">求道之人，不问寒暑</a><time datetime="2022-04-25T00:12:06.667Z" title="Created 2022-04-25 08:12:06">2022-04-25</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/04/24/%E9%9A%8F%E7%AC%94/%E5%BF%83%E5%BF%83%E5%BF%B5%E5%BF%B5/aniversary/" title="分流转系后的一整年"><img src="https://pic.imgdb.cn/item/61eccb5c2ab3f51d91d6238c.jpg" onerror="this.onerror=null;this.src='https://wkphoto.cdn.bcebos.com/1f178a82b9014a9058a735deb9773912b31bee3c.jpg'" alt="分流转系后的一整年"/></a><div class="content"><a class="title" href="/2022/04/24/%E9%9A%8F%E7%AC%94/%E5%BF%83%E5%BF%83%E5%BF%B5%E5%BF%B5/aniversary/" title="分流转系后的一整年">分流转系后的一整年</a><time datetime="2022-04-24T13:17:30.403Z" title="Created 2022-04-24 21:17:30">2022-04-24</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/04/15/CS/others/GSOC_proposal/" title="Proposal for Explore and Optimize Popular Datasets for Hub"><img src="https://pic.imgdb.cn/item/61f0fc802ab3f51d91731f03.jpg" onerror="this.onerror=null;this.src='https://wkphoto.cdn.bcebos.com/1f178a82b9014a9058a735deb9773912b31bee3c.jpg'" alt="Proposal for Explore and Optimize Popular Datasets for Hub"/></a><div class="content"><a class="title" href="/2022/04/15/CS/others/GSOC_proposal/" title="Proposal for Explore and Optimize Popular Datasets for Hub">Proposal for Explore and Optimize Popular Datasets for Hub</a><time datetime="2022-04-15T02:33:59.508Z" title="Created 2022-04-15 10:33:59">2022-04-15</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/04/13/Lecture/2022%20Spring/%E6%88%91%E4%BB%AC%E7%9A%84%E4%BC%9F%E5%A4%A7%E4%B8%8E%E6%B8%BA%E5%B0%8F/" title="我们的伟大与渺小"><img src="https://pic.imgdb.cn/item/61f106b42ab3f51d917b5210.jpg" onerror="this.onerror=null;this.src='https://wkphoto.cdn.bcebos.com/1f178a82b9014a9058a735deb9773912b31bee3c.jpg'" alt="我们的伟大与渺小"/></a><div class="content"><a class="title" href="/2022/04/13/Lecture/2022%20Spring/%E6%88%91%E4%BB%AC%E7%9A%84%E4%BC%9F%E5%A4%A7%E4%B8%8E%E6%B8%BA%E5%B0%8F/" title="我们的伟大与渺小">我们的伟大与渺小</a><time datetime="2022-04-13T10:15:08.391Z" title="Created 2022-04-13 18:15:08">2022-04-13</time></div></div></div></div></div></div></main><footer id="footer" style="background: ＃191970"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2022 By Eren Zhao</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Toggle Between Light And Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle between single-column and double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="Setting"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back To Top"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">Local search</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  Loading the Database</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="Search for Posts" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [ ['$','$'], ["\\(","\\)"]],
      tags: 'ams'
    },
    chtml: {
      scale: 1.2
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, ''],
        insertScript: [200, () => {
          document.querySelectorAll('mjx-container:not\([display]\)').forEach(node => {
            const target = node.parentNode
            if (target.nodeName.toLowerCase() === 'li') {
              target.parentNode.classList.add('has-jax')
            } else {
              target.classList.add('has-jax')
            }
          });
        }, '', false]
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typeset()
}</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/tororo.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":true},"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/"});</script></body></html>