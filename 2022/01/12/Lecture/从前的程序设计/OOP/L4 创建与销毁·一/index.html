<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>oop笔记  L4  创建与销毁·一 | 求道之人，不问寒暑</title><meta name="keywords" content="跪系的普通学生"><meta name="author" content="Eren Zhao"><meta name="copyright" content="Eren Zhao"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="不得不说，一年之后我真的再也没用过oop了...">
<meta property="og:type" content="article">
<meta property="og:title" content="oop笔记  L4  创建与销毁·一">
<meta property="og:url" content="http://example.com/2022/01/12/Lecture/%E4%BB%8E%E5%89%8D%E7%9A%84%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/OOP/L4%20%E5%88%9B%E5%BB%BA%E4%B8%8E%E9%94%80%E6%AF%81%C2%B7%E4%B8%80/index.html">
<meta property="og:site_name" content="求道之人，不问寒暑">
<meta property="og:description" content="不得不说，一年之后我真的再也没用过oop了...">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://raw.githubusercontent.com/zhaochenyang20/ivue_wallpaper/main/ivue_desktop/Photo by Carlos "Grury" Santos (WiuAZ1Q7aMw).jpg">
<meta property="article:published_time" content="2022-01-12T08:33:22.000Z">
<meta property="article:modified_time" content="2022-08-26T15:38:12.900Z">
<meta property="article:author" content="Eren Zhao">
<meta property="article:tag" content="跪系的普通学生">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://raw.githubusercontent.com/zhaochenyang20/ivue_wallpaper/main/ivue_desktop/Photo by Carlos "Grury" Santos (WiuAZ1Q7aMw).jpg"><link rel="shortcut icon" href="/img/favicon.ico"><link rel="canonical" href="http://example.com/2022/01/12/Lecture/%E4%BB%8E%E5%89%8D%E7%9A%84%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/OOP/L4%20%E5%88%9B%E5%BB%BA%E4%B8%8E%E9%94%80%E6%AF%81%C2%B7%E4%B8%80/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"麻了，找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: true,
  islazyload: false,
  isAnchor: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'oop笔记  L4  创建与销毁·一',
  isPost: true,
  isHome: false,
  isHighlightShrink: true,
  isToc: true,
  postUpdate: '2022-08-26 23:38:12'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          const now = new Date()
          const hour = now.getHours()
          const isNight = hour <= 6 || hour >= 18
          if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
          else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/mouse.css"><meta name="generator" content="Hexo 6.0.0"><style>.darkmode--activated{--body-bg-color:#282828;--content-bg-color:#333;--card-bg-color:#555;--text-color:#ccc;--blockquote-color:#bbb;--link-color:#ccc;--link-hover-color:#eee;--brand-color:#ddd;--brand-hover-color:#ddd;--table-row-odd-bg-color:#282828;--table-row-hover-bg-color:#363636;--menu-item-bg-color:#555;--btn-default-bg:#222;--btn-default-color:#ccc;--btn-default-border-color:#555;--btn-default-hover-bg:#666;--btn-default-hover-color:#ccc;--btn-default-hover-border-color:#666;--highlight-background:#282b2e;--highlight-foreground:#a9b7c6;--highlight-gutter-background:#34393d;--highlight-gutter-foreground:#9ca9b6}.darkmode--activated img{opacity:.75}.darkmode--activated img:hover{opacity:.9}.darkmode--activated code{color:#69dbdc;background:0 0}button.darkmode-toggle{z-index:9999}.darkmode-ignore,img{display:flex!important}</style><link rel="alternate" href="/atom.xml" title="求道之人，不问寒暑" type="application/atom+xml">
</head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/avatar.jpeg" onerror="onerror=null;src='/img/friend.jpg'" alt="avatar"/></div><div class="site-data is-center"><div class="data-item"><a href="/archives/"><div class="headline">文章</div><div class="length-num">192</div></a></div><div class="data-item"><a href="/tags/"><div class="headline">标签</div><div class="length-num">52</div></a></div><div class="data-item"><a href="/categories/"><div class="headline">分类</div><div class="length-num">31</div></a></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/list-100/"><i class="fa-fw fas fa-music"></i><span> TODO</span></a></div><div class="menus_item"><a class="site-page" href="/projects/"><i class="fa-fw fas fa-video"></i><span> Projects</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://raw.githubusercontent.com/zhaochenyang20/ivue_wallpaper/main/ivue_desktop/Photo by Carlos &quot;Grury&quot; Santos (WiuAZ1Q7aMw).jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">求道之人，不问寒暑</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/list-100/"><i class="fa-fw fas fa-music"></i><span> TODO</span></a></div><div class="menus_item"><a class="site-page" href="/projects/"><i class="fa-fw fas fa-video"></i><span> Projects</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">oop笔记  L4  创建与销毁·一</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-01-12T08:33:22.000Z" title="发表于 2022-01-12 16:33:22">2022-01-12</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-08-26T15:38:12.900Z" title="更新于 2022-08-26 23:38:12">2022-08-26</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E8%AF%BE%E7%A8%8B/">课程</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E8%AF%BE%E7%A8%8B/OOP/">OOP</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">10.1k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>37分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="oop笔记  L4  创建与销毁·一"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="l4-创建与销毁一">L4 创建与销毁·一</h1>
<blockquote>
<p>如果阅读时间不够充足，建议阅读课堂的扩展部分。</p>
<ul>
<li>1.1.4 初始化列表和构造函数体的基本区别</li>
<li>1.2 委派构造函数实例</li>
<li>3.2 返回静态局部对象的引用</li>
</ul>
</blockquote>
<hr />
<h1 id="一构造函数与析构函数">一、构造函数与析构函数</h1>
<h2 id="面向对象程序的可靠性">1.0 面向对象程序的可靠性</h2>
<p>oop三性：简单性、清晰性、普遍性。对用户定义类型进行严格的类型检查。隐藏实现，防止受到不必要的干扰。对象的初始化和清除，需要自动进行。忘记初始化或清除变量可能会导致程序崩溃。由类生成的对象是一种新型的变量，也要初始化。由于隐藏实现（访问权限控制），对象的有些私有数据成员只有类的设计者知道，而且只允许类的成员函数访问。尽管可以由通过显式调用对象成员函数来初始化对象，但这种做法缺少强制性，因而容易被程序员遗忘。</p>
<p>结论： - 如何进行初始化和清除(HOW)，应由类设计者决定。</p>
<ul>
<li>何时进行初始化和清除(WHEN)，应由编译器来决定。</li>
</ul>
<h2 id="构造函数">1.1 构造函数</h2>
<h3 id="意义">1.1.1 意义</h3>
<p>对象的“生”（初始化工作）是由编译器在创建对象处自动生成调用构造函数的代码来完成的。构造函数是类的特殊成员函数，它用来确保类的每个对象都能正确地初始化。</p>
<h3 id="语法">1.1.2 语法</h3>
<p>构造函数没有返回值类型，函数名与类名相同。
类的构造函数可以重载，即可以使用不同的函数参数进行对象初始化。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> ID;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Student</span>(<span class="keyword">int</span> id) &#123; ID = id; &#125;</span><br><span class="line">    <span class="built_in">Student</span>(<span class="keyword">int</span> year, <span class="keyword">int</span> order) &#123; </span><br><span class="line">            ID = year * <span class="number">10000</span> + order; </span><br><span class="line">     &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="初始化列表">1.1.3 初始化列表</h3>
<p>构造函数可以使用初始化列表初始化成员数据，使用“数据成员(初始值)”的形式。该列表在定义构造函数时使用，位置在函数体之前、函数参数列表之后，以冒号作开头。</p>
<h3 id="初始化列表和构造函数体的基本区别">1.1.4
初始化列表和构造函数体的基本区别</h3>
<p>1.1.4.1 实现过程区别</p>
<p>构造函数可以分两个阶段进行：（1）初始化阶段；（2）函数体阶段。
函数体阶段由函数体内所有的语句组成。不管成员是否在构造函数初始化列表中显式初始化，类的数据成员初始化总是在初始化阶段进行，初始化阶段先于计算阶段。构造函数初始化列表是对类的成员做初始化，而在构造函数体内只是对类的数据成员进行了一次赋值操作。</p>
<p>也就是说，构造函数函数体内对于成员数据的赋值意味着初始化已经完成，仅仅是进行了赋值。这一点可以联系《创建与销毁·二》当中对于声明、定义、初始化、赋值的讨论一同理解。这也可以用于理解，为什么常量成员数据仅仅可以在初始化列表中初始化，但是不可以在函数体内赋值。（因为常量成员仅能进行初始化，却不能在初始化之后再赋值（因为常量成员不能更改）。而一个常量成员，即使在初始化列表中没有被显式初始化，也已经被初始化过了，一个初始化过的常量自然不能在函数体里被修改。）更加详细的讨论在《L5
创建与销毁·二》。</p>
<p>1.1.4.2 效率区别</p>
<p>如前文所述，初始化列表显然避免了函数体内不必要的一些赋值过程，这在类的成员数据较为复杂时能够显著地提高效率。</p>
<h3 id="初始化列表的初始顺序">1.1.5 初始化列表的初始顺序</h3>
<p>初始化列表的成员是按照声明的顺序初始化的，而不是按照出现在初始化列表中的顺序。比如下列代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> ID1;</span><br><span class="line">	<span class="keyword">int</span> ID2;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Student</span>(<span class="keyword">int</span> id) : <span class="built_in">ID2</span>(id), <span class="built_in">ID1</span>(ID2) &#123; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;cout&lt;&lt;<span class="string">&quot;ID1 exist &quot;</span>&lt;&lt;<span class="keyword">this</span>-&gt;ID1&lt;&lt;endl;</span><br><span class="line">	  cout&lt;&lt;<span class="keyword">this</span>-&gt;ID2&lt;&lt;endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">Student <span class="title">test</span><span class="params">(<span class="number">100</span>)</span></span>;</span><br><span class="line">    Test.<span class="built_in">print</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">输出：ID1 exist <span class="number">32767</span></span><br><span class="line">     <span class="number">100</span>在这个例子中，ID1在ID2之前声明，但其初始化依赖于ID2。初始化列表会按照声明顺序进行初始化，先用未知的ID2的值对ID1进行初始化，再用可知的id来初始化ID2。从而使得ID1的值不可预测。</span><br><span class="line">这里的不可预测在不同的编译器上表现不同。可能会有如上输出，也可能是warning（不是error，这里可以参考《第三次作业第二题》的解析）一般来说我们会参考g++编译器的输出，vs编译器有时会更严格。</span><br></pre></td></tr></table></figure>
<p>在这个例子中，ID1在ID2之前声明，但其初始化依赖于ID2。初始化列表会按照声明顺序进行初始化，先用未知的ID2的值对ID1进行初始化，再用可知的id来初始化ID2。从而使得ID1的值不可预测。</p>
<p>这里的不可预测在不同的编译器上表现不同。可能会有如上输出，也可能是warning（不是error，这里可以参考《第三次作业第二题》的解析）一般来说我们会参考g++编译器的输出，vs编译器有时会更严格。</p>
<h2 id="委派构造函数">1.2 委派构造函数</h2>
<h3 id="定义">1.2.1 定义</h3>
<p>在构造函数的初始化列表中，还可以调用其他构造函数，称为“委派构造函数”。</p>
<h3 id="意义-1">1.2.2 意义</h3>
<p>委派构造函数也是c++11中对c++的构造函数的一项改进，其目的就是减少程序员写构造函数的时间。通过委派其他构造函数，多构造函数的类编写起来就很简单容易。</p>
<h3 id="实例">1.2.3 实例</h3>
<p>对比如下两个例子：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Info</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> <span class="built_in">Info</span>() : <span class="built_in">type</span>(<span class="number">1</span>), <span class="built_in">name</span>(<span class="string">&#x27;a&#x27;</span>) &#123;</span><br><span class="line">  <span class="built_in">InitRest</span>();</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="built_in">Info</span>(<span class="keyword">int</span> i) : <span class="built_in">type</span>(i), <span class="built_in">name</span>(<span class="string">&#x27;a&#x27;</span>) &#123;</span><br><span class="line">  <span class="built_in">InitRest</span>();</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="built_in">Info</span>(<span class="keyword">char</span> e) : <span class="built_in">type</span>(<span class="number">1</span>),, <span class="built_in">name</span>(e) &#123;</span><br><span class="line">  <span class="built_in">InitRest</span>();</span><br><span class="line"> &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">InitRest</span><span class="params">()</span> </span>&#123; <span class="comment">//其他初始化 &#125;</span></span><br><span class="line"> <span class="keyword">int</span> type;</span><br><span class="line"> <span class="keyword">char</span> name;</span><br><span class="line">&#125;；</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Info</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> <span class="built_in">Info</span>() &#123; <span class="built_in">InitRest</span>(); &#125;  <span class="comment">//称为目标构造函数（被调用）</span></span><br><span class="line"> <span class="built_in">Info</span>(<span class="keyword">int</span> i) : <span class="built_in">Info</span>() &#123; type = i; &#125;  <span class="comment">//委派构造函数（调用者）</span></span><br><span class="line"> <span class="built_in">Info</span>(<span class="keyword">char</span> e) : <span class="built_in">Info</span>() &#123; name = e; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">InitRest</span><span class="params">()</span> </span>&#123; <span class="comment">// other int &#125;</span></span><br><span class="line"> <span class="keyword">int</span> type &#123;<span class="number">1</span>&#125;;</span><br><span class="line"> <span class="keyword">char</span> name &#123;<span class="string">&#x27;a&#x27;</span>&#125;;  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>委派构造函数不能有初始化列表，因为C++中，构造函数不能同时使用委派和初始化列表。只能在函数体内为type，name等成员赋值。</p>
<p>在构造函数比较多时，可以有不止一个委派构造函数。目标构造函数也可以是委派构造函数，可以在委派构造函数中形成链状的委派构造关系。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Info</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>：</span><br><span class="line"> <span class="built_in">Info</span>() : <span class="built_in">Info</span>(<span class="number">1</span>) &#123;&#125;<span class="comment">//这个不带参数的构造函数的目标函数就在下方，而目标函数也有委派构造函数，从而形成了委派构造函数链。</span></span><br><span class="line"> <span class="built_in">Info</span>(<span class="keyword">int</span> i) : <span class="built_in">Info</span>(i, <span class="string">&#x27;a&#x27;</span>) &#123;&#125;  <span class="comment">//可以委派成链状，但不能形成环。</span></span><br><span class="line"> <span class="built_in">Info</span>(<span class="keyword">char</span> e) : <span class="built_in">Info</span>(<span class="number">1</span>, e) &#123;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"> <span class="built_in">Info</span>(<span class="keyword">int</span> i, <span class="keyword">char</span> e) : <span class="built_in">type</span>(i), <span class="built_in">name</span>(e) &#123;&#125;<span class="comment">//info()调用info(1)，info(1)调用info(1,&#x27;a&#x27;)</span></span><br><span class="line"> <span class="keyword">int</span> type;</span><br><span class="line"> <span class="keyword">char</span> name;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这个例子其实蛮有意思的是，我们之前很少有见到构造函数放在private里面的例子。这个例子却实现了这一点。</p>
<h2 id="就地初始化">1.3 就地初始化</h2>
<p>首先需要指出的是，在课程PPT中对于声明、初始化、定义这三个概念有些混用。三者的广义概念界定在《L4
创建与销毁·二》中进行了阐述。</p>
<p>C++11之前，类中的一般成员变量不能在类声明时进行初始化（定义），它们的初始化操作（定义）只能通过构造函数进行。C++11新增支持如下初始化操作，称为就地初始化。（类似于给类内对象提供了缺省值。）你可以认为就地初始化是一种特殊的机制，他可以使得定义和初始化在类内得以进行。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">1</span>; <span class="comment">//声明+初始化（定义）/</span></span><br><span class="line"><span class="keyword">double</span> b &#123;<span class="number">2.0</span>&#125;; <span class="comment">//声明+初始化（定义）</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>() &#123;&#125; <span class="comment">//a=1 b=2.0</span></span><br><span class="line">    <span class="built_in">A</span>(<span class="keyword">int</span> i):<span class="built_in">a</span>(i) &#123;&#125; <span class="comment">//a=i b=2.0</span></span><br><span class="line">    <span class="built_in">A</span>(<span class="keyword">int</span> i, <span class="keyword">double</span> j):<span class="built_in">a</span>(i), <span class="built_in">b</span>(j) &#123;&#125;     <span class="comment">//a=i b=j</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>注意：就地初始化只是一种简便的表达方式，实际操作仍然在对象构造的时候执行。</p>
<h2 id="默认构造函数">1.4 默认构造函数</h2>
<h3 id="定义-1">1.4.1 定义</h3>
<p>不带任何参数的构造函数，或每个形参提供默认实参的构造函数，被称为“默认构造函数”，也称“缺省构造函数”。</p>
<h3 id="语法-1">1.4.2 语法</h3>
<p>使用默认构造函数（没有参数）来生成对象时，对象定义的格式如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">ClassName a;    <span class="comment">//调用默认构造函数</span></span><br><span class="line">ClassName b = <span class="built_in">ClassName</span>();  <span class="comment">//同样调用默认构造函数</span></span><br></pre></td></tr></table></figure>
<p>注意和下方代码区别开来：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">ClassName <span class="title">c</span><span class="params">()</span></span>;<span class="comment">//这声明了一个返回值为ClassName,不带参数的函数</span></span><br></pre></td></tr></table></figure>
<h3 id="编译器的额外操作">1.4.3 编译器的额外操作</h3>
<p>基于之后涉及到的组合的概念，在类的构造函数中，除了执行函数体内声明的语句，编译器还会做一些额外操作。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>() &#123; cout &lt;&lt; <span class="string">&quot;A()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    A a;</span><br><span class="line">    <span class="built_in">B</span>() &#123; cout &lt;&lt; <span class="string">&quot;B()&quot;</span> &lt;&lt; endl;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">B b;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br></pre></td></tr></table></figure>
<p>这里会先输出A的默认构造函数对应的输出，再输出B的默认构造函数对应的输出。</p>
<p>也就是说，如果类A里面有另一个类B作为这个类的成员，调用类A的默认构造函数时会先调用B的构造函数。先构造成员-再构造类。</p>
<h3 id="隐式定义的默认构造函数">1.4.4 隐式定义的默认构造函数</h3>
<p>有时候我们没有手动定义默认构造函数，但我们仍然能够按上述方式定义变量。这是因为编译器帮我们隐式地合成了一个默认构造函数。</p>
<figure>
<img src="https://s2.loli.net/2022/01/10/tVJ6PWm1eTjMNCc.png"
alt="https://s2.loli.net/2022/01/10/tVJ6PWm1eTjMNCc.png" />
<figcaption
aria-hidden="true">https://s2.loli.net/2022/01/10/tVJ6PWm1eTjMNCc.png</figcaption>
</figure>
<figure>
<img src="https://s2.loli.net/2022/01/10/HyuRqMQ6LKNcWfr.png"
alt="https://s2.loli.net/2022/01/10/HyuRqMQ6LKNcWfr.png" />
<figcaption
aria-hidden="true">https://s2.loli.net/2022/01/10/HyuRqMQ6LKNcWfr.png</figcaption>
</figure>
<p>注意这个例子，b究竟是调用了哪一个构造函数？</p>
<p>我们将代码修改如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>() &#123; cout&lt;&lt;<span class="string">&quot;A()&quot;</span>&lt;&lt;endl; &#125;</span><br><span class="line">    <span class="built_in">A</span>(<span class="keyword">int</span> x)</span><br><span class="line">       &#123; cout &lt;&lt; <span class="string">&quot;A(int)&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> &#123;</span></span><br><span class="line">    A a;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">B</span>(<span class="keyword">int</span> x=<span class="number">1</span>): <span class="built_in">a</span>(x) &#123;&#125;</span><br><span class="line">    <span class="built_in">B</span>():<span class="built_in">a</span>(<span class="number">1</span>)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    B b;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>发现会因为函数调用不明确而error，故而可以确定上述选择题是调用了缺省的构造函数而非隐式生成的默认构造函数。这一点在函数重载有讨论。</p>
<p>某种意义上，缺省的构造函数本质上已经实现了默认构造函数的功能。</p>
<p>另一方面，若用户已经定义了其他构造函数，编译器将不会隐式合成默认构造函数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">double</span> b &#123;<span class="number">2.0</span>&#125;; </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   <span class="built_in">A</span>(<span class="keyword">int</span> i):<span class="built_in">a</span>(i) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">A a;  <span class="comment">//编译错误</span></span><br></pre></td></tr></table></figure>
<h3 id="显式声明默认构造函数">1.4.5 显式声明默认构造函数</h3>
<p>出于某些需要，我们可以手动指定生成默认版本的构造函数：即便其他构造函数存在，编译器也会定义隐式默认构造函数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">double</span> b &#123;<span class="number">2.0</span>&#125;; </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>() = <span class="keyword">default</span>;    <span class="comment">// C++11起</span></span><br><span class="line">    <span class="built_in">A</span>(<span class="keyword">int</span> i):<span class="built_in">a</span>(i) &#123;&#125;   </span><br><span class="line">&#125;;</span><br><span class="line">A a;</span><br></pre></td></tr></table></figure>
<h3 id="显式删除危险构造函数">1.4.6 显式删除危险构造函数</h3>
<p>有时候，我们也可以显式地声明禁用某些带有风险的构造函数。这种禁用不仅可以禁用编译器合成的默认构造函数，也可以用来禁止一些自动类型转换带来的构造函数调用。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">double</span> b &#123;<span class="number">2.0</span>&#125;; </span><br><span class="line">    <span class="keyword">char</span> c = <span class="string">&#x27;c&#x27;</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">A</span>(<span class="keyword">int</span> i):<span class="built_in">a</span>(i) &#123;cout&lt;&lt;i&lt;&lt;endl;&#125;   </span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">A <span class="title">a</span><span class="params">(<span class="string">&#x27;c&#x27;</span>)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">输出结果 <span class="number">99</span></span><br></pre></td></tr></table></figure>
<p>这一代码存在风险，本意一定是希望他报错，但是实则不会。从正确性上讲，这样的代码没有问题，char和int可以类型转换，故而将‘c’转为了int，调用了参数为int的构造函数。但是从工程的角度讲，这是很危险的行为。因为在开发者看来，用字符初始化应该是未定义的行为。</p>
<p>故而显式地禁用某一构造函数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">       <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">       <span class="keyword">double</span> b &#123;<span class="number">2.0</span>&#125;; </span><br><span class="line">       <span class="keyword">char</span> c = <span class="string">&#x27;c&#x27;</span>;</span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">       <span class="built_in">A</span>() = <span class="keyword">default</span>;</span><br><span class="line">       <span class="built_in">A</span>(<span class="keyword">int</span> i):<span class="built_in">a</span>(i) &#123;&#125;</span><br><span class="line">       <span class="built_in">A</span>(<span class="keyword">char</span> ch) = <span class="keyword">delete</span>;   </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="对象数组的初始化在main中">1.5 对象数组的初始化（在main中）</h2>
<p>无参定义对象数组，必须要有默认构造函数 A a[50]; //
定义了一个具有50个元素的A类对象数组</p>
<p>如果构造函数带有参数 A a[3] = {1, 3, 5}; //
三个实参分别传递给3个数组元素的构造函数</p>
<p>带有多个参数 A a[3] = {A(1, 2), A(3, 5), A(0, 7)}; //
构造函数有两个整型参数</p>
<h2 id="析构函数">1.6 析构函数</h2>
<h3 id="概述">1.6.1 概述</h3>
<p>对象的“死”（清除和释放资源）是由编译器在对象作用域结束处自动生成调用析构函数代码来完成的，动态分配的内存就是一种典型的需要释放的资源。
当执行到“包含对象定义范围结束处”时，编译器自动调用对象的析构函数。清除对象占用的资源是无条件的，不需要任何选项。因此，析构函数没有参数，且只有一个，即清除方式唯一。</p>
<p>这在《创建与销毁·二》的3.4.1的例子中有所体现。</p>
<figure>
<img src="https://s2.loli.net/2022/01/11/DPQkzN7uhonaWFd.png"
alt="https://s2.loli.net/2022/01/11/DPQkzN7uhonaWFd.png" />
<figcaption
aria-hidden="true">https://s2.loli.net/2022/01/11/DPQkzN7uhonaWFd.png</figcaption>
</figure>
<p>没有显式定义拷贝构造函数，系统调用了隐式生成的拷贝构造函数，这当然是没有输出的。形参的构造用的是拷贝构造函数，可是析构却是共用的一个析构函数。</p>
<h3 id="语法-2">1.6.2 语法</h3>
<p>一个类只有一个析构函数，名称是“~类名”，没有函数返回值，没有函数参数。编译器在对象生命期结束时自动调用类的析构函数，以便释放对象占用的资源，或其他后处理。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassRoom</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> num;</span><br><span class="line">    <span class="keyword">int</span>* ID_list;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ClassRoom</span>() : <span class="built_in">num</span>(<span class="number">0</span>), <span class="built_in">ID_list</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">    ...</span><br><span class="line">    ~<span class="built_in">ClassRoom</span>() &#123;  <span class="comment">// 析构函数</span></span><br><span class="line">        <span class="keyword">if</span> (ID_list) <span class="keyword">delete</span>[] ID_list; <span class="comment">// 释放内存    </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>注意到这个例子也体现了对于指针，delete之前应先检测是否为空指针。</p>
<h3 id="析构排序">1.6.3 析构排序</h3>
<p>和默认构造函数一样，析构函数除了执行函数体内声明的语句，编译器还会做一些额外操作。例如在组合当中，会自动调用成员变量的析构函数，先执行自己的析构函数，再调用成员变量的析构。（这点与构造函数恰恰相反）以及最基本的，先构造的后析构。</p>
<h3 id="默认析构函数">1.6.4 默认析构函数</h3>
<p>和构造函数类似，当用户没有自定义析构函数时，编译器会自动合成一个隐式的析构函数。</p>
<figure>
<img src="https://s2.loli.net/2022/01/11/tvpBJmeGUr2dlS7.png"
alt="https://s2.loli.net/2022/01/11/tvpBJmeGUr2dlS7.png" />
<figcaption
aria-hidden="true">https://s2.loli.net/2022/01/11/tvpBJmeGUr2dlS7.png</figcaption>
</figure>
<p>问题在于隐式定义的析构函数不会delete指针成员，可能造成内存泄露。</p>
<h1 id="二对象的析构与构造">二、对象的析构与构造</h1>
<h2 id="局部对象的析构与构造">2.1 局部对象的析构与构造</h2>
<h3 id="定义-2">2.2.1 定义</h3>
<p>作用域：该变量能够被引用的区域，例如，{}将会形成一个作用域。</p>
<p>非静态的局部对象：在程序执行到该局部对象的代码时被初始化。在局部对象生命周期结束、即所在作用域结束后被析构。这里注意与静态的局部对象进行对比。详见《L4
创建与销毁·二》。</p>
<p>非静态全局变量：在main()函数调用之前进行初始化。在同一编译单元中，按照定义顺序进行初始化。</p>
<p>编译单元：通常同一编译单元就是同一源文件。</p>
<p>不同编译单元间，对象初始化顺序不确定。</p>
<p>在main()函数执行完return之后，对象被析构。</p>
<h3 id="全局变量的局限性">2.2.2 全局变量的局限性</h3>
<p>尽量少用全局对象。首先，全局对象的构造顺序不能完全确定，所以全局对象之间不能有依赖关系，否则会出现问题。其次，全局对象会增大代码的耦合性，导致程序难以复用或者测试。</p>
<figure>
<img src="https://s2.loli.net/2022/01/11/sBzdFWmkgnp2KVD.png"
alt="https://s2.loli.net/2022/01/11/sBzdFWmkgnp2KVD.png" />
<figcaption
aria-hidden="true">https://s2.loli.net/2022/01/11/sBzdFWmkgnp2KVD.png</figcaption>
</figure>
<p>这道题就是强调了全局变量在main()函数执行完return之后被析构。而<code>local_obj</code>相当于是main的局部变量，会在全局变量后析构。</p>
<h1 id="三引用">三、引用</h1>
<h2 id="定义与语法">3.1 定义与语法</h2>
<p>同一个内存单元的两个不同名字。</p>
<p>格式具名变量的别名：类型名 &amp; 引用名 变量名 例：int v0; int &amp;
v1 = v0;
v1是变量v0的引用。引用必须在定义时进行初始化，且不能修改引用指向，这点和指针不同。</p>
<p>被引用变量名可以是类的成员变量，如int &amp; m = s.m;</p>
<h2 id="结合函数使用">3.2 结合函数使用</h2>
<p>函数参数可以是引用类型，表示函数的形式参数与实际参数是同一个变量，改变形参将改变实参，使用得当也可避免许多不必要的形参拷贝。如调用以下函数将交换实参的值：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>&amp; a, <span class="keyword">int</span>&amp; b)</span></span></span><br><span class="line"><span class="function">  </span>&#123;  <span class="keyword">int</span> tmp = b; b = a; a = tmp; &#125;</span><br></pre></td></tr></table></figure>
<p>函数返回值可以是引用类型，但不得指向函数的非静态的临时变量。换言之，你可以返回临时变量（这相当于把它复制了一份
return
出去，它本身会被销毁），但不能返回非静态临时变量的引用。静态局部变量是可以作为返回值的，并且有着神奇的操作。（这一神奇的操作涉及到静态局部变量的作用，详见《L4
创建与销毁·二》1.2.2.2）</p>
<figure>
<img src="https://s2.loli.net/2022/01/11/oJibuxv5syLw96Z.png"
alt="https://s2.loli.net/2022/01/11/oJibuxv5syLw96Z.png" />
<figcaption
aria-hidden="true">https://s2.loli.net/2022/01/11/oJibuxv5syLw96Z.png</figcaption>
</figure>
<p>这段代码存在非法内存访问。注意到func2定义的局部变量tmp是非静态的，故而func2结束之后立刻析构。而f被定义为了tmp的引用，tmp已经被销毁了，这块内存空间已经被释放。</p>
<p>被释放的内存，访问是危险的，但并非不可访问。现在一般的编译器都是允许访问，但访问的结果不确定，有可能是运行错误，有可能是不确定的值。这个可能需要等到学汇编会了解的更清楚。</p>
<p>故而这段代码在glot编译器上的结果为4_0。</p>
<p>然而我们对局部变量tmp加上static修饰：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Int</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    <span class="built_in">Int</span>() &#123; data = <span class="number">1</span>; &#125;</span><br><span class="line">    <span class="built_in">Int</span>(<span class="keyword">int</span> i): <span class="built_in">data</span>(i) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func1</span><span class="params">(Int&amp; a, Int b)</span> </span>&#123;</span><br><span class="line">    a.data += b.data;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Int&amp; <span class="title">func2</span><span class="params">(Int&amp; a, Int b)</span> </span>&#123; </span><br><span class="line">    <span class="built_in">func1</span>(a, b);</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="keyword">static</span> <span class="title">tmp</span><span class="params">(a.data + b.data)</span></span>;</span><br><span class="line">    <span class="keyword">return</span>  tmp; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> a, <span class="built_in">b</span>(<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">int</span> &amp;f = <span class="built_in">func2</span>(a, b);</span><br><span class="line">    cout &lt;&lt; a.data &lt;&lt;<span class="string">&quot;_&quot;</span>&lt;&lt;f.data &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">输出：<span class="number">4</span>_7</span><br></pre></td></tr></table></figure>
<p>非常神奇，我们不仅通过static修饰保留了局部变量，似乎还改变了这个局部变量。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Int</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    <span class="built_in">Int</span>() &#123; data = <span class="number">1</span>; &#125;</span><br><span class="line">    <span class="built_in">Int</span>(<span class="keyword">int</span> i): <span class="built_in">data</span>(i) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func1</span><span class="params">(Int&amp; a, Int b)</span> </span>&#123;</span><br><span class="line">    a.data += b.data;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Int&amp; <span class="title">func2</span><span class="params">(Int&amp; a, Int b)</span> </span>&#123; </span><br><span class="line">    <span class="built_in">func1</span>(a, b);</span><br><span class="line">    <span class="function">Int <span class="keyword">static</span> <span class="title">tmp</span><span class="params">(a.data + b.data)</span></span>;</span><br><span class="line">    <span class="keyword">return</span>  tmp; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Int a, <span class="built_in">b</span>(<span class="number">3</span>);</span><br><span class="line">    Int &amp;f = <span class="built_in">func2</span>(a, b);</span><br><span class="line">    cout &lt;&lt; a.data &lt;&lt;<span class="string">&quot;_&quot;</span>&lt;&lt;f.data&lt;&lt;endl;</span><br><span class="line">    f.data++;</span><br><span class="line">    cout &lt;&lt; a.data &lt;&lt;<span class="string">&quot;_&quot;</span>&lt;&lt;<span class="built_in">func2</span>(a,b).data&lt;&lt;<span class="string">&quot;_&quot;</span>&lt;&lt;a.data&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">输出：<span class="number">4</span>_7</span><br><span class="line"><span class="number">4</span>_8_7</span><br></pre></td></tr></table></figure>
<p>这似乎违反了静态局部变量只能够被定义它的函数体操作这一点，实则不然。我们之前叙述的是，静态局部变量不能在函数外被使用，但是但它的内存空间可以。上例是绕过了语言层面，直接对于内存进行了操作。</p>
<p>对于变量的操作，是指例如编写一行C语言代码，明确地操作这个变量，比如变量x++。但是操作可以通过指针，比如定义一个指针p来指向这个地址，然后对*
p<em>进行各类操作。这时候编译器并不知道</em>p指向的内存空间究竟怎么来的，它只知道是一段内存空间，进行了一系列操作。</p>
<p>简而言之，你不能在函数体外使用静态局部变量的名字，但是可以使用这块内存空间。</p>
<p>另外，我在func2(a,b).data中第二次调用func2(a,b)时，由于之前已经定义了static
int
tmp，所以第二次不再用<code>Int static tmp(a.data + b.data;</code>来构造新的tmp，相当于构造tmp的这一行失效了，但是func1(a, b);仍然会进行，故而a还是加了3。</p>
<p>又比如下面这段代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Int</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    <span class="built_in">Int</span>() &#123; data = <span class="number">1</span>; &#125;</span><br><span class="line">    <span class="built_in">Int</span>(<span class="keyword">int</span> i): <span class="built_in">data</span>(i) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func1</span><span class="params">(Int&amp; a, Int b)</span> </span>&#123;</span><br><span class="line">    a.data += b.data;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Int&amp; <span class="title">func2</span><span class="params">(Int&amp; a, Int b)</span> </span>&#123; </span><br><span class="line">    <span class="built_in">func1</span>(a, b);</span><br><span class="line">    <span class="function">Int <span class="keyword">static</span> <span class="title">tmp</span><span class="params">(a.data + b.data)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> tmp; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Int a, <span class="built_in">b</span>(<span class="number">3</span>);</span><br><span class="line">    Int &amp;f = <span class="built_in">func2</span>(a, b);</span><br><span class="line">    cout &lt;&lt; a.data &lt;&lt;<span class="string">&quot;_&quot;</span>&lt;&lt;f.data&lt;&lt;endl;</span><br><span class="line">    <span class="built_in">func2</span>(a,b).data++;</span><br><span class="line">    cout &lt;&lt; a.data &lt;&lt;<span class="string">&quot;_&quot;</span>&lt;&lt;<span class="built_in">func2</span>(a,b).data&lt;&lt;<span class="string">&quot;_&quot;</span>&lt;&lt;a.data&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">输出：<span class="number">4</span>_7</span><br><span class="line"><span class="number">7</span>_8_10</span><br></pre></td></tr></table></figure>
<p>我企图直接对func2(a,b).data++；因为我返回类型为tmp的引用，也成功实现了对于tmp的内存空间的操作。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Int</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    <span class="built_in">Int</span>() &#123; data = <span class="number">1</span>; &#125;</span><br><span class="line">    <span class="built_in">Int</span>(<span class="keyword">int</span> i): <span class="built_in">data</span>(i) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func1</span><span class="params">(Int&amp; a, Int b)</span> </span>&#123;</span><br><span class="line">    a.data += b.data;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Int&amp; <span class="title">func2</span><span class="params">(Int&amp; a, Int b)</span> </span>&#123; </span><br><span class="line">    <span class="built_in">func1</span>(a, b);</span><br><span class="line">    <span class="function">Int <span class="keyword">static</span> <span class="title">tmp</span><span class="params">(a.data + b.data)</span></span>;</span><br><span class="line">    <span class="keyword">return</span>  tmp; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Int a, <span class="built_in">b</span>(<span class="number">3</span>);</span><br><span class="line">    Int &amp;f = <span class="built_in">func2</span>(a, b);</span><br><span class="line">    cout &lt;&lt; a.data &lt;&lt;<span class="string">&quot;_&quot;</span>&lt;&lt;f.data&lt;&lt;endl;</span><br><span class="line">    tmp.data++;</span><br><span class="line">    cout &lt;&lt; a.data &lt;&lt;<span class="string">&quot;_&quot;</span>&lt;&lt;<span class="built_in">func2</span>(a,b).data&lt;&lt;<span class="string">&quot;_&quot;</span>&lt;&lt;a.data&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">输出：</span><br><span class="line">error: use of undeclared identifier <span class="string">&#x27;tmp&#x27;</span></span><br><span class="line">    tmp.data++;</span><br><span class="line">    ^</span><br><span class="line"><span class="number">1</span> error generated.</span><br></pre></td></tr></table></figure>
<h2 id="引用的其他特点">3.3 引用的其他特点</h2>
<p>不存在空引用。引用必须连接到一块合法的内存。</p>
<p>一旦引用被初始化为一个对象，就不能被指向到另一个对象。指针可以在任何时候指向到另一个对象。</p>
<p>引用必须在创建时被初始化为一个对象。指针可以在初始化时置空，之后再指向对象。</p>
<p>引用的优势：更灵活地支持运算符重载。</p>
<p>引用的特性：创建时必须初始化、初始化后便不能指向其他对象，不存在空引用。</p>
<h1 id="四运算符重载">四、运算符重载</h1>
<h2 id="意义-2">4.1 意义</h2>
<p>用户自定义类，没有对常用的运算符进行定义，比如想要表示两个类对象相加，无法采用a+b这种方式。可以采取定义一个add函数的方式，解决这种问题。但这种实现方式，在调用的时候，会和基础类型差别很大，缺少编程的一致性。需要过多地区分自定义类和基础类别，调用起来也不方便。因此，我们引入运算符重载。</p>
<h2 id="语法-3">4.2 语法</h2>
<p>运算符重载需要按规则声明执行该运算的函数。例如 + 对应
operator+（operator就是运算的意思，相当于我人为定义了对于A类的+号）
运算重载一般有两种方式（注意参数不同），且只能用一种。</p>
<ul>
<li>全局函数型运算符重载</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">A <span class="keyword">operator</span>+(A&amp; a1, A&amp; a2) &#123;</span><br><span class="line">    <span class="function">A <span class="title">new_a</span><span class="params">(a1.data + a2.data)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> new_a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用全局函数型重载：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    <span class="built_in">A</span>(<span class="keyword">int</span> i) &#123; data = i; &#125;</span><br><span class="line">&#125;;</span><br><span class="line">A <span class="keyword">operator</span>+(A&amp; a1, A&amp; a2) &#123;</span><br><span class="line">    <span class="function">A <span class="title">new_a</span><span class="params">(a1.data + a2.data)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> new_a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">A <span class="title">a1</span><span class="params">(<span class="number">2</span>)</span>, <span class="title">a2</span><span class="params">(<span class="number">3</span>)</span></span>;</span><br><span class="line">    a1 += a2; <span class="comment">// 调用operator+=()</span></span><br><span class="line">    cout &lt;&lt; a1.data &lt;&lt; endl; </span><br><span class="line">    cout &lt;&lt; (a1 + a2).data &lt;&lt; endl; <span class="comment">// 调用operator+()</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的a1+a2相当于调用函数operator+(a1,a2);</p>
<ul>
<li>成员函数型运算符重载</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    A <span class="keyword">operator</span>+(A&amp; a) &#123; </span><br><span class="line">	  <span class="function">A <span class="title">new_a</span><span class="params">(data + a.data)</span></span>;</span><br><span class="line">		<span class="keyword">return</span> new_a;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>注意理解参数的不同。定义为全局函数型运算符重载之后，需要指出对于哪两个对象进行操作。但是定义为成员函数型运算符重载时，这一函数是某一对象的成员函数。如果是双目运算符只需指明另一个数据为参数。</p>
<p>使用成员函数型重载：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line"><span class="built_in">A</span>(<span class="keyword">int</span> i) &#123; data = i; &#125;</span><br><span class="line">A&amp; <span class="keyword">operator</span>+=(A&amp; a) &#123; data += a.data; <span class="keyword">return</span> *<span class="keyword">this</span>;&#125;</span><br><span class="line">A <span class="keyword">operator</span>+(A&amp; a) &#123; </span><br><span class="line"><span class="function">A <span class="title">new_a</span><span class="params">(data + a.data)</span></span>;</span><br><span class="line"><span class="keyword">return</span> new_a;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">A <span class="title">a1</span><span class="params">(<span class="number">2</span>)</span>, <span class="title">a2</span><span class="params">(<span class="number">3</span>)</span></span>;</span><br><span class="line">    a1 += a2; <span class="comment">// 调用operator+=()</span></span><br><span class="line">    cout &lt;&lt; a1.data &lt;&lt; endl; </span><br><span class="line">    cout &lt;&lt; (a1 + a2).data &lt;&lt; endl; <span class="comment">// 调用operator+()</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>显然对于+=和+都应该重载，不可能只重载+就解决问题。
这里的a1+a2相当于调用函数a1.operator+(a2);</p>
<h2 id="具体的重载实例">4.3 具体的重载实例</h2>
<p>（进一步讨论参见选择题解析2）</p>
<h3 id="可重载类型">4.3.1 可重载类型</h3>
<p>双目算术运算符</p>
<p><code>+</code>(加)，<code>-</code>(减)，<code>*</code>(乘)，<code>/</code>(除)，<code>%</code>(取模)</p>
<p>关系运算符 <code>==</code>（等于)，<code>!=</code>
(不等于)，<code>&lt;</code> (小于)，<code>&gt;</code>
(大于），<code>&lt;=</code>(小于等于)，<code>&gt;=</code>(大于等于)</p>
<p>逻辑运算符
<code>||</code>(逻辑或)，<code>&amp;&amp;</code>(逻辑与)，<code>!</code>(逻辑非)</p>
<p>单目运算符</p>
<p><code>+</code>(正)，<code>-</code>(负)，<code>*</code>(指针)，<code>&amp;</code>(取地址)</p>
<p>自增自减运算符 <code>++</code>(自增)，<code>--</code>(自减)</p>
<p>位运算符 <code>|</code> (按位或)，<code>&amp;</code>
(按位与)，<code>~</code>(按位取反)，<code>^</code>(按位异或)，<code>&lt;&lt;</code>
(左移),<code>&gt;&gt;</code>(右移)</p>
<p>赋值运算符
<code>=, +=, -=, *=, /= , % = , &amp;=, |=, ^=, &lt;&lt;=, &gt;&gt;=</code></p>
<p>空间申请与释放 <code>new</code>,<code>delete</code>,
<code>new[]</code> , <code>delete[]</code></p>
<p>其他运算符
<code>()</code>(函数调用)，<code>-&gt;</code>(成员访问)，<code>,</code>(逗号)，</p>
<h3 id="前后缀重载">4.3.2 前后缀重载</h3>
<p>4.3.2.1 声明</p>
<p>前缀运算符重载声明：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">ClassName <span class="keyword">operator</span>++();</span><br><span class="line">ClassName <span class="keyword">operator</span>--();</span><br></pre></td></tr></table></figure>
<p>后缀运算符重载声明：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">ClassName <span class="keyword">operator</span>++(<span class="keyword">int</span> dummy);</span><br></pre></td></tr></table></figure>
<p>Dummy表示哑元，实际上哑元可以没有名字。</p>
<p>（这里笔记写的略微有问题，参考选择题解析2）</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">ClassName <span class="keyword">operator</span>++(<span class="keyword">int</span> dummy);</span><br><span class="line">++a等价于<span class="keyword">operator</span>++(a)</span><br><span class="line">a++ 等价于<span class="keyword">operator</span>++(a,<span class="keyword">int</span>)</span><br><span class="line">ClassName <span class="keyword">operator</span>--(<span class="keyword">int</span> dummy);</span><br></pre></td></tr></table></figure>
<p>哑元的意义：设想没有这一哑元，那么a++和++a的声明完全相同。然而实际上，两个函数的功能完全不同，需要实现重载。这一实现就是借助哑元达成的。</p>
<p>编译器在编译a++时，等价于operator++(a,int)，从而调用了后缀运算符。编译器自动识别，就像是a1+a2等价于a1.operator+(a2)，这种等价就是编译器自动等价。</p>
<p>4.3.2.2 语义识别</p>
<p>int a = ++b; //先完成b+1操作，再赋值 int a = b++;
//先完成赋值，再b+1操作</p>
<p>4.3.2.3 前缀运算符重载实例</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">int</span> data = <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">Test</span>(<span class="keyword">int</span> d) &#123;data = d;&#125;</span><br><span class="line">  Test&amp; <span class="keyword">operator</span>++ () &#123;</span><br><span class="line">    ++data;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="function">Test <span class="title">test</span><span class="params">(<span class="number">1</span>)</span></span>; </span><br><span class="line">  ++test;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>4.3.2.4 后缀运算符重载</p>
<p>4.3.2.4.1 实例一：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">int</span> data = <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">Test</span>(<span class="keyword">int</span> d) &#123;data = d;&#125;</span><br><span class="line">  Test <span class="keyword">operator</span>++ (<span class="keyword">int</span>) &#123;</span><br><span class="line">    <span class="function">Test <span class="title">test</span><span class="params">(data)</span></span>;</span><br><span class="line">    ++data;</span><br><span class="line">    <span class="keyword">return</span> test;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="function">Test <span class="title">test</span><span class="params">(<span class="number">1</span>)</span></span>; </span><br><span class="line">  test++;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先需要指出的是，函数的返回值并不一定需要使用。这一段就是典型的例子，尽管我返回的是个Test对象，但是没有人接收这一对象，他会在主函数的对应语句（也就是test++）结束后被释放。虽然在这个例子里面，test++并没有用到Test类型的返回值，可以改为void，但是在其他情况下是需要用到这一个返回值的。</p>
<p>4.3.2.4.2 关于析构时机</p>
<p>对于此处局部对象的析构时机，结合第三次作业第二题的f1部分进行一定的解读。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">Test <span class="title">f1</span><span class="params">(Test a)</span></span>&#123;</span><br><span class="line">    a.<span class="built_in">print</span>(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line">Test A = <span class="built_in">f1</span>(a);</span><br></pre></td></tr></table></figure>
<p>对于这一赋值构造(构造外面的A）+函数调用语句，构造A和析构返回值和形参的先后顺序：先执行完f1的函数体，暂不析构。然后执行完整个语句，具体到这个语句，就是外部对A的移动构造，再析构。</p>
<p>完成了对A的移动构造之后，就已经完成了两次对应移动构造的输出。分别是因为返回值优化被禁用而对返回值进行的规定的移动构造，以及返回的对象对于A的移动构造。接下来，这一语句执行完毕后才进行函数体的析构，也就是连续的两次析构。第一次析构掉返回值，第二次析构掉形参。（先构造的后析构）</p>
<p>但是这里的析构顺序其实还有进一步讨论：</p>
<blockquote>
<p>由于函数返回值是对象而在return时也会产生一次对象构造（通常会被编译器优化，但可以通过开启编译指令<code>-fon-elide-constructors</code>让编译器不优化），这个临时对象会在return语句执行时被创建，等return语句结束后，函数体内的对象被析构，然后这个临时变量被析构，最后才到作为参数的变量被析构。</p>
</blockquote>
<p>析构顺序是先析构函数体内对象，然后是返回值对象，最后是形参。虽然这和通常意义上的先构造的后析构有些矛盾，但是特例记住就好。</p>
<p>至于为什么对A是移动构造：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Test A = <span class="built_in">f1</span>(a);<span class="comment">//f1(a)是个右值，因为你没法对f1(a)++; f1(a)是个右值，故而默认调用了移动构造函数</span></span><br></pre></td></tr></table></figure>
<p>这里需要意识到，f1(a)本身是个右值，但是A就是个左值了。</p>
<p>还值得说明的是，上文的析构时机是建立在主函数的语句既有赋值又有函数调用的基础上，也就是函数的返回值有赋值作用。如果函数返回值没有赋值的作用，那么返回值会立刻在函数体结束后被析构，而不是主函数的对应语句结束后析构。譬如上文简单的写a++就会让test立刻被析构。</p>
<p>4.3.2.4.3 实例二：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">int</span> data = <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">Test</span>(<span class="keyword">int</span> d) &#123;data = d;&#125;</span><br><span class="line">  Test <span class="keyword">operator</span>++ (<span class="keyword">int</span>) &#123;<span class="comment">//后缀重载</span></span><br><span class="line">    <span class="function">Test <span class="title">test</span><span class="params">(data)</span></span>;</span><br><span class="line">    ++data;</span><br><span class="line">    <span class="keyword">return</span> test;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="function">Test <span class="title">test</span><span class="params">(<span class="number">1</span>)</span></span>; </span><br><span class="line">  test=test++;</span><br><span class="line">  cout&lt;&lt;test.data&lt;&lt;endl;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">输出：<span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>为什么会输出1？我们结合修改后的代码进行解释。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">int</span> data = <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">Test</span>(<span class="keyword">int</span> d) &#123;data = d;&#125;</span><br><span class="line">  Test <span class="keyword">operator</span>++ (<span class="keyword">int</span>) &#123;</span><br><span class="line">    <span class="function">Test <span class="title">new_test</span><span class="params">(data)</span></span>;</span><br><span class="line">    ++data;</span><br><span class="line">    <span class="keyword">return</span> new_test;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="function">Test <span class="title">test</span><span class="params">(<span class="number">1</span>)</span></span>; </span><br><span class="line">  test=test++;</span><br><span class="line">  cout&lt;&lt;test.data&lt;&lt;endl;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">输出：<span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>先构建了new_test，然后对原有的test.data++，然后把new_test返回给了test。注意到这一逻辑过程的先后顺序，我虽然对于test.data++了，但这步之后用返回的new_test（data还是1）对test进行了移动赋值，覆盖了++的效果，故而test.data还是1。</p>
<p>另一方面，避免主函数的局部变量和函数体局部变量重名必然是个好习惯！</p>
<p>4.3.2.5 全局型重载</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    <span class="built_in">A</span>() &#123; data = <span class="number">0</span>; &#125;</span><br><span class="line">    <span class="built_in">A</span>(<span class="keyword">int</span> i) &#123; data = i; &#125;</span><br><span class="line">&#125;;</span><br><span class="line">A <span class="keyword">operator</span>++(A&amp; a) &#123;<span class="comment">//前缀</span></span><br><span class="line">    ++a.data;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line">A <span class="keyword">operator</span>++(A&amp; a, <span class="keyword">int</span>) &#123; <span class="comment">//哑元，后缀</span></span><br><span class="line">    <span class="function">A <span class="title">new_a</span><span class="params">(a.data)</span></span>;</span><br><span class="line">    ++a.data;</span><br><span class="line">    <span class="keyword">return</span> new_a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">A <span class="title">a</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">    cout &lt;&lt; (++a).data &lt;&lt; endl; <span class="comment">// 2</span></span><br><span class="line">    cout &lt;&lt; (a++).data &lt;&lt; endl; <span class="comment">// 2</span></span><br><span class="line">    cout &lt;&lt; a.data &lt;&lt; endl; <span class="comment">// 3</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="函数运算符重载">4.3.3 函数运算符()重载</h3>
<p>在自定义类中也可以重载函数运算符()
，它使对象看上去如同是一个函数名，可以称之为函数对象。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;operator() called. &quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Test sum;</span><br><span class="line">  <span class="keyword">int</span> s = <span class="built_in">sum</span>(<span class="number">3</span>, <span class="number">4</span>); <span class="comment">/// sum对象看上去象是一个函数，故也称“函数对象”</span></span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;a + b = &quot;</span> &lt;&lt; s &lt;&lt; endl;</span><br><span class="line">  <span class="keyword">int</span> t = sum.<span class="built_in"><span class="keyword">operator</span></span>()(<span class="number">5</span>, <span class="number">6</span>); </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ReturnType <span class="title">operator</span><span class="params">()</span> <span class="params">(Parameters)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ClassName Obj;</span><br><span class="line"><span class="built_in">Obj</span>(real_parameters); <span class="comment">//注意这里显然不是在调用构造函数！</span></span><br></pre></td></tr></table></figure>
<p>实际上在调用<code>Obj(real_parameters)</code>;
时，等价于调用了<code>Obj.operator() (real_parameters)</code>;</p>
<h3 id="数组下标重载">4.3.4 数组下标重载</h3>
<p>函数声明形式：返回类型 operator[] (参数);</p>
<p>如果返回类型是引用，则数组运算符调用可以出现在等号左边，接受赋值，即Obj[index]
= value;（也就是返回左值）如果返回类型不是引用，则只能出现在等号右边Var
= Obj[index];（也就是成员函数函数返回了右值，但右值不可以赋值）</p>
<p>注意到，这里Obj是一个对象，而不是一个数组。这是对于一个类，定义了一个成员函数来重载数组下标。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span><span class="comment">//为了使用strcmp    </span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">char</span> week_name[<span class="number">7</span>][<span class="number">4</span>] = &#123;<span class="string">&quot;mon&quot;</span>,<span class="string">&quot;tue&quot;</span>,<span class="string">&quot;wed&quot;</span>,<span class="string">&quot;thu&quot;</span>,<span class="string">&quot;fri&quot;</span>,<span class="string">&quot;sat&quot;</span>,<span class="string">&quot;sun&quot;</span>&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WeekTemperature</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> temperature[<span class="number">7</span>];</span><br><span class="line">    <span class="keyword">int</span> error_temperature;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span>&amp; <span class="keyword">operator</span>[] (<span class="keyword">const</span> <span class="keyword">char</span>* name) <span class="comment">// 字符串作下标</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">7</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">strcmp</span>(week_name[i], name) == <span class="number">0</span>) </span><br><span class="line">                <span class="keyword">return</span> temperature[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> error_temperature; <span class="comment">//没有匹配到字符串</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">WeekTemperature beijing;</span><br><span class="line">    beijing[<span class="string">&quot;mon&quot;</span>] = <span class="number">-3</span>;    </span><br><span class="line">    beijing[<span class="string">&quot;tue&quot;</span>] = <span class="number">-1</span>;</span><br><span class="line">    cout    &lt;&lt; <span class="string">&quot;Monday Temperature: &quot;</span> </span><br><span class="line">            &lt;&lt; beijing[<span class="string">&quot;mon&quot;</span>] &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">输出结果：Monday Temperature: <span class="number">-3</span></span><br></pre></td></tr></table></figure>
<p>const
char*name:表示一个常量字符串，避免修改。这个字符串常量就是在[]里面的内容，比如[“test”]那你的参数就是test。（注意到必须要有双引号才能是字符串）</p>
<p>此处，对于private做一说明：temp是private，所以直接访问temp这个名字不可行，但是可通过其他方式访问其引用，进而可修改内存空间。</p>
<p>这个名字被保护了，但是他的内存单元没有被保护。private一般用于修饰类的内部属性（变量）和方法（函数）（即：那些不想暴露给外部的），它保证了它修饰的属性和方法不能在类的外部被【直接】访问，但可以通过类的一些public方法实现间接访问。例如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>: <span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Test</span>(<span class="keyword">int</span> j):<span class="built_in">i</span>(j)&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;cout&lt;&lt;<span class="keyword">this</span>-&gt;i;&#125;</span><br><span class="line">&#125;;  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="function">Test <span class="title">test</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">  <span class="keyword">int</span>&amp;b=test.i;</span><br><span class="line">  b++;</span><br><span class="line">  test.<span class="built_in">print</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里将会访问失败，因为主函数内不可访问直接private成员。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>: <span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Test</span>(<span class="keyword">int</span> j):<span class="built_in">i</span>(j)&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;cout&lt;&lt;<span class="keyword">this</span>-&gt;i;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span>&amp; <span class="title">setTest</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> <span class="keyword">this</span>-&gt;i;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="function">Test <span class="title">test</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">  <span class="keyword">int</span>&amp;b=test.<span class="built_in">setTest</span>();</span><br><span class="line">  b++;</span><br><span class="line">  test.<span class="built_in">print</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此处，我通过setTest这一public方法得到了i的引用，再构造了另外一个引用。直接绕过了变量，对其指向的内存空间进行了操作。</p>
<h3 id="只能成员函数型重载的运算符">4.3.5
只能成员函数型重载的运算符</h3>
<p><code>=</code>,<code>[]</code>,<code>()</code>,<code>-&gt;</code>只能通过成员函数来重载。</p>
<p>这里其实可以联系到之后学习的拷贝赋值运算和移动赋值运算，因为本质上二者就是实现方式值得推究的两种运算符重载。</p>
<p>当我们没有显式地在类内定义这两个运算符（重载）时，编译器会自动生成缺失的部分。编译器无法获知（或者至少没有尝试去获知）类以外已经重载了operator
=，它在编译这个类时发现这个类没有重载operator
=，于是就给它补上了一个。但如果之后又在类以外重载了一个operator
=，这就会导致调用的时候不知道用哪个，产生歧义。综上，c++禁止了在类以外重载operator=。</p>
<p>换言之，编译器编译类时能看到类内重载的赋值运算符，就不会自动生成=的重载。但全局的编译器无法在编译时检测到,只有在链接的时候才能检测到。而此时会链接歧义函数。</p>
<p>仅仅是只是链接两个歧义函数并不会出错，在发生有歧义的调用的时候才会有问题。（也就是说，如果在类外重载operator=，而不调用=,是不会warning或者error的。）比如我们甚至可以同时定义int
foo(int x, int y=1) 和int foo(int x) 这两个函数，只有使用了foo(x)
才会导致CE。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y=<span class="number">0</span>)</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;1&quot;</span>&lt;&lt;endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//这不会有问题</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y=<span class="number">0</span>)</span></span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;1&quot;</span>&lt;&lt;endl;</span><br><span class="line"><span class="built_in">func</span>(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//这就有问题</span></span><br></pre></td></tr></table></figure>
<h3 id="流运算符重载">4.3.6 流运算符重载</h3>
<p>用户自定义的类，虽然可以像内置类型那样定义变量（对象），但想要使用流运算符输入、输出对象，则还需要为类定义流运算符重载。</p>
<p>4.3.6.1 语法</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">istream&amp; <span class="keyword">operator</span>&gt;&gt; (istream&amp; in, Test&amp; dst );</span><br><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt; (ostream&amp; out, <span class="keyword">const</span> Test&amp; src );</span><br></pre></td></tr></table></figure>
<p>函数名为：operator&gt;&gt; 和 operator&lt;&lt;</p>
<p>不修改istream和ostream类的情况下，只能使用全局函数重载。</p>
<p>返回值为：istream&amp; 和 ostream&amp;，均为引用</p>
<p>参数分别：流对象的引用、目标对象的引用。对于输出流，目标对象一般是常量引用。</p>
<p>备注：因为流运算符往往需要输出private数据，故而往往设为友元函数并在类内声明，并尽量在类外时实现。同时，在类外实现时，已经不用再写friend了，friend只是一个全局函数在类内的标记。</p>
<p>为什么流运算符不能是成员函数重载？</p>
<p>实际上，这句话指的是，流运算符不能是某个对象的成员函数重载，因为我们在调用流运算符时，调用顺序是：cout&lt;&lt;a;而不是a&lt;&lt;cout;
从而可以看出，调用的是ostream类的一个成员函数，而不是a的类的成员函数。</p>
<p>4.3.6.2 实例</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Test</span>(<span class="keyword">int</span> i) : <span class="built_in">id</span>(i) &#123; cout &lt;&lt; <span class="string">&quot;obj_&quot;</span> &lt;&lt; id &lt;&lt; <span class="string">&quot; created\n&quot;</span>; &#125;   </span><br><span class="line">    <span class="keyword">friend</span> istream&amp; <span class="keyword">operator</span>&gt;&gt; (istream&amp; in, Test&amp; dst); </span><br><span class="line">    <span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span>&lt;&lt; (ostream&amp; out, <span class="keyword">const</span> Test&amp; src); </span><br><span class="line">&#125;;  </span><br><span class="line">istream&amp; <span class="keyword">operator</span>&gt;&gt; (istream&amp; in, Test&amp; dst) &#123;</span><br><span class="line">        in &gt;&gt; dst.id;</span><br><span class="line">        <span class="keyword">return</span> in;</span><br><span class="line">&#125;</span><br><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt; (ostream&amp; out, <span class="keyword">const</span> Test&amp; src) &#123;</span><br><span class="line">    out &lt;&lt; src.id &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> out;</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Test <span class="title">obj</span><span class="params">(<span class="number">1</span>)</span></span>;    </span><br><span class="line">    cout &lt;&lt; obj;  <span class="comment">// 等价于obj.operator&lt;&lt;(cout,obj)</span></span><br><span class="line">    cin &gt;&gt; obj;   <span class="comment">// 等价于obj.operator&gt;&gt;(cin,obj)     </span></span><br><span class="line">    cout &lt;&lt; obj;    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意到，函数体内用的都是in和out，而不是cin和cout，因为你在重载out，你希望你的out对于所有的输出流都适用，那么不能写cout。因为还有fout等等。如果写了cout，没有问题，但是没法给fout这些用，因此写out习惯更好。</p>
<p>参数的意义：cout &lt;&lt; asdfsad &lt;&lt; sadf;
out即时ostream类对象cout，src即是test类对象asdfsad。函数结束后，返回了一个新的ostream&amp;，接下来继续输出。</p>
</article><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="addthis_inline_share_toolbox"></div><script src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-62b11572b25ab3ab" async="async"></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/01/12/Lecture/%E4%BB%8E%E5%89%8D%E7%9A%84%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/OOP/L12%20%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1%E5%92%8C%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/"><img class="prev-cover" src="https://raw.githubusercontent.com/zhaochenyang20/ivue_wallpaper/main/ivue_desktop/Photo by Tim Gouw (rxLGSOM0e3U).jpg" onerror="onerror=null;src='https://raw.githubusercontent.com/zhaochenyang20/ivue_wallpaper/main/ivue_desktop/Photo by Oscar Rodrigo Hernandez Panczenko (P0GQ95huhBo).jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">L12 函数对象与智能指针</div></div></a></div><div class="next-post pull-right"><a href="/2022/01/12/Lecture/%E4%BB%8E%E5%89%8D%E7%9A%84%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/OOP/L1%E3%80%81L2%20%E7%BB%AA%E8%AE%BA%E4%B8%8E%E7%BC%96%E7%A8%8B%E7%8E%AF%E5%A2%83/"><img class="next-cover" src="https://pic.imgdb.cn/item/61f106b02ab3f51d917b4c8a.jpg" onerror="onerror=null;src='https://raw.githubusercontent.com/zhaochenyang20/ivue_wallpaper/main/ivue_desktop/Photo by Oscar Rodrigo Hernandez Panczenko (P0GQ95huhBo).jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">oop笔记  L1、L2 绪论与编程环境</div></div></a></div></nav><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="gitalk-container"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#l4-%E5%88%9B%E5%BB%BA%E4%B8%8E%E9%94%80%E6%AF%81%E4%B8%80"><span class="toc-number">1.</span> <span class="toc-text">L4 创建与销毁·一</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%80%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E4%B8%8E%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0"><span class="toc-number">2.</span> <span class="toc-text">一、构造函数与析构函数</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%8F%AF%E9%9D%A0%E6%80%A7"><span class="toc-number">2.1.</span> <span class="toc-text">1.0 面向对象程序的可靠性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">2.2.</span> <span class="toc-text">1.1 构造函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%84%8F%E4%B9%89"><span class="toc-number">2.2.1.</span> <span class="toc-text">1.1.1 意义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%AD%E6%B3%95"><span class="toc-number">2.2.2.</span> <span class="toc-text">1.1.2 语法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E5%88%97%E8%A1%A8"><span class="toc-number">2.2.3.</span> <span class="toc-text">1.1.3 初始化列表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E5%88%97%E8%A1%A8%E5%92%8C%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E4%BD%93%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8C%BA%E5%88%AB"><span class="toc-number">2.2.4.</span> <span class="toc-text">1.1.4
初始化列表和构造函数体的基本区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E5%88%97%E8%A1%A8%E7%9A%84%E5%88%9D%E5%A7%8B%E9%A1%BA%E5%BA%8F"><span class="toc-number">2.2.5.</span> <span class="toc-text">1.1.5 初始化列表的初始顺序</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A7%94%E6%B4%BE%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">2.3.</span> <span class="toc-text">1.2 委派构造函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89"><span class="toc-number">2.3.1.</span> <span class="toc-text">1.2.1 定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%84%8F%E4%B9%89-1"><span class="toc-number">2.3.2.</span> <span class="toc-text">1.2.2 意义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B"><span class="toc-number">2.3.3.</span> <span class="toc-text">1.2.3 实例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B0%B1%E5%9C%B0%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">2.4.</span> <span class="toc-text">1.3 就地初始化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%BB%98%E8%AE%A4%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">2.5.</span> <span class="toc-text">1.4 默认构造函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89-1"><span class="toc-number">2.5.1.</span> <span class="toc-text">1.4.1 定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%AD%E6%B3%95-1"><span class="toc-number">2.5.2.</span> <span class="toc-text">1.4.2 语法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%96%E8%AF%91%E5%99%A8%E7%9A%84%E9%A2%9D%E5%A4%96%E6%93%8D%E4%BD%9C"><span class="toc-number">2.5.3.</span> <span class="toc-text">1.4.3 编译器的额外操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9A%90%E5%BC%8F%E5%AE%9A%E4%B9%89%E7%9A%84%E9%BB%98%E8%AE%A4%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">2.5.4.</span> <span class="toc-text">1.4.4 隐式定义的默认构造函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%98%BE%E5%BC%8F%E5%A3%B0%E6%98%8E%E9%BB%98%E8%AE%A4%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">2.5.5.</span> <span class="toc-text">1.4.5 显式声明默认构造函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%98%BE%E5%BC%8F%E5%88%A0%E9%99%A4%E5%8D%B1%E9%99%A9%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">2.5.6.</span> <span class="toc-text">1.4.6 显式删除危险构造函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E6%95%B0%E7%BB%84%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E5%9C%A8main%E4%B8%AD"><span class="toc-number">2.6.</span> <span class="toc-text">1.5 对象数组的初始化（在main中）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0"><span class="toc-number">2.7.</span> <span class="toc-text">1.6 析构函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0"><span class="toc-number">2.7.1.</span> <span class="toc-text">1.6.1 概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%AD%E6%B3%95-2"><span class="toc-number">2.7.2.</span> <span class="toc-text">1.6.2 语法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%90%E6%9E%84%E6%8E%92%E5%BA%8F"><span class="toc-number">2.7.3.</span> <span class="toc-text">1.6.3 析构排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%BB%98%E8%AE%A4%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0"><span class="toc-number">2.7.4.</span> <span class="toc-text">1.6.4 默认析构函数</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%9E%90%E6%9E%84%E4%B8%8E%E6%9E%84%E9%80%A0"><span class="toc-number">3.</span> <span class="toc-text">二、对象的析构与构造</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B1%80%E9%83%A8%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%9E%90%E6%9E%84%E4%B8%8E%E6%9E%84%E9%80%A0"><span class="toc-number">3.1.</span> <span class="toc-text">2.1 局部对象的析构与构造</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89-2"><span class="toc-number">3.1.1.</span> <span class="toc-text">2.2.1 定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E7%9A%84%E5%B1%80%E9%99%90%E6%80%A7"><span class="toc-number">3.1.2.</span> <span class="toc-text">2.2.2 全局变量的局限性</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%89%E5%BC%95%E7%94%A8"><span class="toc-number">4.</span> <span class="toc-text">三、引用</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%E4%B8%8E%E8%AF%AD%E6%B3%95"><span class="toc-number">4.1.</span> <span class="toc-text">3.1 定义与语法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%93%E5%90%88%E5%87%BD%E6%95%B0%E4%BD%BF%E7%94%A8"><span class="toc-number">4.2.</span> <span class="toc-text">3.2 结合函数使用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E7%9A%84%E5%85%B6%E4%BB%96%E7%89%B9%E7%82%B9"><span class="toc-number">4.3.</span> <span class="toc-text">3.3 引用的其他特点</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9B%9B%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD"><span class="toc-number">5.</span> <span class="toc-text">四、运算符重载</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%84%8F%E4%B9%89-2"><span class="toc-number">5.1.</span> <span class="toc-text">4.1 意义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%AD%E6%B3%95-3"><span class="toc-number">5.2.</span> <span class="toc-text">4.2 语法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B7%E4%BD%93%E7%9A%84%E9%87%8D%E8%BD%BD%E5%AE%9E%E4%BE%8B"><span class="toc-number">5.3.</span> <span class="toc-text">4.3 具体的重载实例</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AF%E9%87%8D%E8%BD%BD%E7%B1%BB%E5%9E%8B"><span class="toc-number">5.3.1.</span> <span class="toc-text">4.3.1 可重载类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%89%8D%E5%90%8E%E7%BC%80%E9%87%8D%E8%BD%BD"><span class="toc-number">5.3.2.</span> <span class="toc-text">4.3.2 前后缀重载</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD"><span class="toc-number">5.3.3.</span> <span class="toc-text">4.3.3 函数运算符()重载</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E4%B8%8B%E6%A0%87%E9%87%8D%E8%BD%BD"><span class="toc-number">5.3.4.</span> <span class="toc-text">4.3.4 数组下标重载</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AA%E8%83%BD%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E5%9E%8B%E9%87%8D%E8%BD%BD%E7%9A%84%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">5.3.5.</span> <span class="toc-text">4.3.5
只能成员函数型重载的运算符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%81%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD"><span class="toc-number">5.3.6.</span> <span class="toc-text">4.3.6 流运算符重载</span></a></li></ol></li></ol></li></ol></div></div></div></div></main><footer id="footer" style="background: ＃0096FF"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2022 By Eren Zhao</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div><script type="text/javascript" id="maid-script" src="https://unpkg.com/mermaid@undefined/dist/mermaid.min.js?v=undefined"></script><script>if (window.mermaid) {
  var options = JSON.parse(document.getElementById('maid-script').getAttribute('mermaidoptioins'));
  mermaid.initialize(options);
}</script></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="chat_btn" type="button" title="rightside.chat_btn"><i class="fas fa-sms"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">本地搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库正在艰难运行</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [ ['$','$'], ["\\(","\\)"]],
      tags: 'ams'
    },
    chtml: {
      scale: 1.2
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, ''],
        insertScript: [200, () => {
          document.querySelectorAll('mjx-container:not\([display]\)').forEach(node => {
            const target = node.parentNode
            if (target.nodeName.toLowerCase() === 'li') {
              target.parentNode.classList.add('has-jax')
            } else {
              target.classList.add('has-jax')
            }
          });
        }, '', false]
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typeset()
}</script><script>(() => {
  const $mermaidWrap = document.querySelectorAll('#article-container .mermaid-wrap')
  if ($mermaidWrap.length) {
    window.runMermaid = () => {
      window.loadMermaid = true
      const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

      Array.from($mermaidWrap).forEach((item, index) => {
        const mermaidSrc = item.firstElementChild
        const mermaidThemeConfig = '%%{init:{ \'theme\':\'' + theme + '\'}}%%\n'
        const mermaidID = 'mermaid-' + index
        const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent
        mermaid.mermaidAPI.render(mermaidID, mermaidDefinition, (svgCode) => {
          mermaidSrc.insertAdjacentHTML('afterend', svgCode)
        })
      })
    }

    const loadMermaid = () => {
      window.loadMermaid ? runMermaid() : getScript('https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js').then(runMermaid)
    }

    window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
  }
})()</script><script>function addGitalkSource () {
  const ele = document.createElement('link')
  ele.rel = 'stylesheet'
  ele.href= 'https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css'
  document.getElementsByTagName('head')[0].appendChild(ele)
}

function loadGitalk () {
  function initGitalk () {
    var gitalk = new Gitalk(Object.assign({
      clientID: '978121c7b834efdd76be',
      clientSecret: '59b40e8f39a1c33db5a2c891771086164b9575c4',
      repo: 'zhaochenyang20.github.io',
      owner: 'zhaochenyang20',
      admin: ['zhaochenyang20'],
      id: 'a2c6e7f37a2c1b9d1c7984322eb7fd4a',
      updateCountCallback: commentCount
    },null))

    gitalk.render('gitalk-container')
  }

  if (typeof Gitalk === 'function') initGitalk()
  else {
    addGitalkSource()
    getScript('https://cdn.jsdelivr.net/npm/gitalk@latest/dist/gitalk.min.js').then(initGitalk)
  }
}

function commentCount(n){
  let isCommentCount = document.querySelector('#post-meta .gitalk-comment-count')
  if (isCommentCount) {
    isCommentCount.innerHTML= n
  }
}

if ('Gitalk' === 'Gitalk' || !true) {
  if (true) btf.loadComment(document.getElementById('gitalk-container'), loadGitalk)
  else loadGitalk()
} else {
  function loadOtherComment () {
    loadGitalk()
  }
}</script></div><canvas class="fireworks" mobile="true"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/fireworks.min.js"></script><script defer="defer" id="fluttering_ribbon" mobile="true" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-fluttering-ribbon.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = false;
POWERMODE.mobile = true;
document.body.addEventListener('input', POWERMODE);
</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/tororo.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":true},"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/"});</script></body></html>