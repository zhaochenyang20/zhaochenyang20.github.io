<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>oop笔记  L5  创建与销毁·二 | I'LL TAKE YOU TO THE MOON</title><meta name="keywords" content="跪系的普通学生"><meta name="author" content="Eren Zhao"><meta name="copyright" content="Eren Zhao"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="为了搞清楚变量类型，我还是用Python吧...">
<meta property="og:type" content="article">
<meta property="og:title" content="oop笔记  L5  创建与销毁·二">
<meta property="og:url" content="http://example.com/2022/01/12/Lecture/%E4%BB%8E%E5%89%8D%E7%9A%84%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/OOP/L5%20%E5%88%9B%E5%BB%BA%E4%B8%8E%E9%94%80%E6%AF%81%C2%B7%E4%BA%8C/index.html">
<meta property="og:site_name" content="I&#39;LL TAKE YOU TO THE MOON">
<meta property="og:description" content="为了搞清楚变量类型，我还是用Python吧...">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://raw.githubusercontent.com/zhaochenyang20/ivue_wallpaper/main/ivue_desktop/Photo by Tobias Reich (aJDb9v3CIkY).jpg">
<meta property="article:published_time" content="2022-01-12T08:33:22.000Z">
<meta property="article:modified_time" content="2022-08-26T15:38:17.917Z">
<meta property="article:author" content="Eren Zhao">
<meta property="article:tag" content="跪系的普通学生">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://raw.githubusercontent.com/zhaochenyang20/ivue_wallpaper/main/ivue_desktop/Photo by Tobias Reich (aJDb9v3CIkY).jpg"><link rel="shortcut icon" href="/img/favicon.ico"><link rel="canonical" href="http://example.com/2022/01/12/Lecture/%E4%BB%8E%E5%89%8D%E7%9A%84%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/OOP/L5%20%E5%88%9B%E5%BB%BA%E4%B8%8E%E9%94%80%E6%AF%81%C2%B7%E4%BA%8C/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"麻了，找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: true,
  islazyload: false,
  isAnchor: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'oop笔记  L5  创建与销毁·二',
  isPost: true,
  isHome: false,
  isHighlightShrink: true,
  isToc: true,
  postUpdate: '2022-08-26 23:38:17'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          const now = new Date()
          const hour = now.getHours()
          const isNight = hour <= 6 || hour >= 18
          if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
          else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/mouse.css"><meta name="generator" content="Hexo 6.0.0"><link rel="alternate" href="/atom.xml" title="I'LL TAKE YOU TO THE MOON" type="application/atom+xml">
<style>.darkmode--activated{--body-bg-color:#282828;--content-bg-color:#333;--card-bg-color:#555;--text-color:#ccc;--blockquote-color:#bbb;--link-color:#ccc;--link-hover-color:#eee;--brand-color:#ddd;--brand-hover-color:#ddd;--table-row-odd-bg-color:#282828;--table-row-hover-bg-color:#363636;--menu-item-bg-color:#555;--btn-default-bg:#222;--btn-default-color:#ccc;--btn-default-border-color:#555;--btn-default-hover-bg:#666;--btn-default-hover-color:#ccc;--btn-default-hover-border-color:#666;--highlight-background:#282b2e;--highlight-foreground:#a9b7c6;--highlight-gutter-background:#34393d;--highlight-gutter-foreground:#9ca9b6}.darkmode--activated img{opacity:.75}.darkmode--activated img:hover{opacity:.9}.darkmode--activated code{color:#69dbdc;background:0 0}button.darkmode-toggle{z-index:9999}.darkmode-ignore,img{display:flex!important}</style></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/avatar.jpeg" onerror="onerror=null;src='/img/friend.jpg'" alt="avatar"/></div><div class="site-data is-center"><div class="data-item"><a href="/archives/"><div class="headline">文章</div><div class="length-num">193</div></a></div><div class="data-item"><a href="/tags/"><div class="headline">标签</div><div class="length-num">52</div></a></div><div class="data-item"><a href="/categories/"><div class="headline">分类</div><div class="length-num">31</div></a></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/list-100/"><i class="fa-fw fas fa-music"></i><span> TODO</span></a></div><div class="menus_item"><a class="site-page" href="/projects/"><i class="fa-fw fas fa-video"></i><span> Projects</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://raw.githubusercontent.com/zhaochenyang20/ivue_wallpaper/main/ivue_desktop/Photo by Tobias Reich (aJDb9v3CIkY).jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">I'LL TAKE YOU TO THE MOON</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/list-100/"><i class="fa-fw fas fa-music"></i><span> TODO</span></a></div><div class="menus_item"><a class="site-page" href="/projects/"><i class="fa-fw fas fa-video"></i><span> Projects</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">oop笔记  L5  创建与销毁·二</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-01-12T08:33:22.000Z" title="发表于 2022-01-12 16:33:22">2022-01-12</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-08-26T15:38:17.917Z" title="更新于 2022-08-26 23:38:17">2022-08-26</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E8%AF%BE%E7%A8%8B/">课程</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E8%AF%BE%E7%A8%8B/OOP/">OOP</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">9.1k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>30分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="oop笔记  L5  创建与销毁·二"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="L5-创建与销毁·二"><a href="#L5-创建与销毁·二" class="headerlink" title="L5 创建与销毁·二"></a>L5 创建与销毁·二</h1><blockquote>
<p>如果阅读时间不够充足，建议阅读课堂的扩展部分：</p>
<ul>
<li>1.1 对四类变量的区别</li>
<li>1.2 静态变量与相关概念的界定</li>
<li>1.2.5 extern修饰符的详细讨论</li>
<li>1.3 类变量与相关概念的界定</li>
</ul>
</blockquote>
<hr>
<h1 id="速览表格"><a href="#速览表格" class="headerlink" title="速览表格"></a>速览表格</h1><p><img src="https://s2.loli.net/2022/01/11/1PSAfKNFsVgw2a6.png" alt="https://s2.loli.net/2022/01/11/1PSAfKNFsVgw2a6.png"></p>
<h1 id="一、变量与静态变量"><a href="#一、变量与静态变量" class="headerlink" title="一、变量与静态变量"></a>一、变量与静态变量</h1><h2 id="1-1-四类变量的区别"><a href="#1-1-四类变量的区别" class="headerlink" title="1.1  四类变量的区别"></a>1.1  四类变量的区别</h2><h3 id="1-1-1-按存储区域分"><a href="#1-1-1-按存储区域分" class="headerlink" title="1.1.1  按存储区域分"></a>1.1.1  按存储区域分</h3><p>全局变量、静态全局变量和静态局部变量都存放在内存的静态存储区域，局部变量存放在内存的栈区。静态储存区在函数结束后不会销毁，而栈区在函数结束后会退栈而销毁。</p>
<h3 id="1-1-2-按作用域分"><a href="#1-1-2-按作用域分" class="headerlink" title="1.1.2  按作用域分"></a>1.1.2  按作用域分</h3><p>1.1.2.1  动态变量</p>
<p>全局变量：在整个工程文件内都有效；“在函数外定义的变量”，即从定义变量的位置到本源文件结束都有效。由于同一文件中的所有函数都能引用全局变量的值，因此如果在一个函数中改变了全局变量的值，就能影响到其他函数中全局变量的值。<br>所谓整个工程，是指所有的文件都可以用，不单单在定义全局变量的那个文件。</p>
<p>局部变量：在定义它的函数内有效，但是函数返回后失效。“在函数内定义的变量”，即在一个函数内部定义的变量，只在本函数范围内有效。</p>
<p>注意：全局变量和静态变量如果没有手工初始化，则由编译器初始化为0。局部变量的值不可知。</p>
<p>1.1.2.2  静态变量(static)</p>
<p>静态决定了两件事，第一就是存储后不会立刻销毁。第二是自带有一定的限定变量作用区域的功能，强化全局/局部的具体作用域。</p>
<p>静态全局变量：只在定义它的文件内有效，效果和全局变量一样，只是就在本文件内部。</p>
<p>静态局部变量：只在定义它的函数内有效，只是程序仅分配一次内存，函数返回后，该变量不会消失；静态局部变量的生存期虽然为整个工程，但是其作用仍与局部变量相同，即只能在定义该变量的函数内使用该变量。退出该函数后， 尽管该变量还继续存在。(局部决定其无法被其他函数使用只能被同一函数下次再用。静态决定其保存在静态区，无法被立刻销毁)</p>
<p>这里还继续存在意味着很重要的性质，对于这个函数而言，静态局部变量是可以复用的。静态局部变量在静态存储区内分配存储单元。在程序整个运行期间都不释放。而自动变量（即动态局部变量）属于动态存储类别，存储在动态存储区空间(而不是静态存储区空间)，每一次该函数调用结束后即释放。</p>
<p>为静态局部变量赋初值是在编译时进行的，即只赋初值一次，在程序运行时它已有初值。以后每次调用函数时不再重新赋初值而只是保留上次函数调用结束时的值。而为自动变量赋初值，不是在编译时进行的，而是在函数调用时进行，每调用一次函数重新给一次初值，相当于执行一次赋值语句。</p>
<p>如果在定义局部变量时不赋初值的话，对静态局部变量来说，编译时自动赋初值0(对数值型变量)或空字符(对字符型变量)。而对自动变量来说，如果不赋初值，则它的值是一个不确定的值。这是由于每次函数调用结束后存储单元已释放，下次调用时又重新另分配存储单元，而所分配的单元中的值是不确定的。</p>
<p>虽然静态局部变量在函数调用结束后仍然存在，但其他函数是不能引用它的。也就是说，在其他函数中它是“不可见”的。 （这个不可见是指静态局部变量的名称不可在其他函数内被操作。但是由于其内存并没有被析构掉，我们依然能够对这块内存进行操作，这一神奇的操作详见《L4 创建与销毁·一》3.2部分）</p>
<p>静态变量与全局变量最明显的区别就在于：全局变量在其定义后所有函数都能用，但是静态全局变量只能在一个文件里面使用，而静态局部变量只能在一个函数里使用。</p>
<h3 id="1-1-3-形参变量"><a href="#1-1-3-形参变量" class="headerlink" title="1.1.3  形参变量"></a>1.1.3  形参变量</h3><p>只在被调用期间才分配内存单元，调用结束立即释放。</p>
<p>在函数体内，形参的等级最高。当全局变量名与形参名冲突的时候，函数会操作形参，而不是全局变量。例如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;stdio.h&quot;</span></span></span><br><span class="line">  <span class="keyword">int</span> Max = <span class="number">1</span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> Max)</span></span></span><br><span class="line"><span class="function">  </span>&#123; Max = <span class="number">2</span>;&#125;</span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;<span class="built_in">add</span>(Max);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Max = %d&quot;</span>,Max);</span><br><span class="line">    <span class="built_in">getchar</span>();</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br></pre></td></tr></table></figure>
<p>这个结果当然是Max=1。但是进入函数后，用int Max(形参)=Max(实参)来构造了形参，形参的优先级高于全局变量，但改变形参不改变全局变量，且函数执行完后，形参释放。</p>
<h2 id="1-2-静态变量"><a href="#1-2-静态变量" class="headerlink" title="1.2  静态变量"></a>1.2  静态变量</h2><h3 id="1-2-0-意义"><a href="#1-2-0-意义" class="headerlink" title="1.2.0  意义"></a>1.2.0  意义</h3><p>static的本质意义在于可控制变量的存储方式和可见性。</p>
<p>在函数内部定义的变量，当程序执行到它的定义处时，编译器为它在栈上分配空间，函数在栈上分配的空间在此函数执行结束时会释放掉。如果想将函数中此变量的值保存至下一次调用时，应该如何实现？ 最容易想到的方法是定义为全局的变量，但定义一个全局变量有许多缺点，最明显的缺点是破坏了此变量的访问范围（使得在此函数中定义的变量，不仅仅只受此函数控制）。static关键字则可以很好的解决这个问题。</p>
<p>另一方面，在 C++ 中，需要一个数据对象为整个类而非某个对象服务，同时又力求不破坏类的封装性,即要求此成员隐藏在类的内部，对外不可见时，可将其定义为静态数据。</p>
<h3 id="1-2-1-定义"><a href="#1-2-1-定义" class="headerlink" title="1.2.1  定义"></a>1.2.1  定义</h3><p>使用static修饰的变量。例如static int i=1;</p>
<h3 id="1-2-2-初始化"><a href="#1-2-2-初始化" class="headerlink" title="1.2.2  初始化"></a>1.2.2  初始化</h3><p>初次定义时需要初始化。如果是在函数体内的静态局部变量，则只会初始化一次，之后如果再次调用该函数，还有初始化语句，但这些之后的初始化语句失效。也即是在一个函数执行一次这个过程中，不能两次定义同一个static数据成员。一个函数执行多次，那么每次都可以有静态局部变量定义的语句，但是只有第一次有效。</p>
<p>而静态全局变量只能初始化一次，之后再初始化则报错。</p>
<h3 id="1-2-3-静态局部变量"><a href="#1-2-3-静态局部变量" class="headerlink" title="1.2.3  静态局部变量"></a>1.2.3  静态局部变量</h3><p>静态局部变量存储在静态存储区，生命周期将持续到整个程序结束。</p>
<h3 id="1-2-4-静态全局变量"><a href="#1-2-4-静态全局变量" class="headerlink" title="1.2.4  静态全局变量"></a>1.2.4  静态全局变量</h3><p>静态全局变量具有内部可链接性，作用域仅限其声明的源文件，不能被其他源文件所用，可以避免和其他源文件中的同名变量冲突。</p>
<p>显式static修饰的全局变量和全局函数即是在其他.cpp里使用extern也不能用。</p>
<h3 id="1-2-5-extern-修饰符"><a href="#1-2-5-extern-修饰符" class="headerlink" title="1.2.5  extern 修饰符"></a>1.2.5  extern 修饰符</h3><p>首先需要指出的是，非显式static修饰的全局变量和全局函数默认都是非静态的，即可共享的，但是必须在其他文件里用extern来声明才可以用。</p>
<p>extern 修饰符通常用于当有两个或多个文件希望共享相同的全局变量或函数的时候。一般情况下，没有显式加上static修饰的全局变量（譬如int x）是默认非静态的。如果想在其他的编译单元中使用同一个全局变量，倘若再次定义int x，必然造成重复定义。于是使用extern int x来声明而不再次定义。（注意，不可以extern一个显式static修饰的全局变量，因为static修饰的全局变量的作用域只限于它被定义的那个cpp文件）这样以来，该全局变量对extern它的所有的程序文件都可见的。</p>
<p>进一步讲，我们已知不可以在头文件中定义全局变量，譬如int x。（这等价于int x=0） include的功能很简单，就是复制粘贴。故而对于每个包含了该头文件的cpp文件，复制粘贴后相当于都定义了一次非静态的全局变量int x=0，造成重复定义而链接失败。从而只能在头文件中声明变量，extern int x。</p>
<p>另一方面，全局函数也是默认非static的。但extern修饰对于一个不带static修饰的全局函数没有必要，因为当我们在另一cpp中声明（而非重定义）这一全局函数时，系统会默认视为extern。从而，在另一cpp中调用这一全局函数，不需要extern修饰，但是仍需声明。这样一来，尽量也不在头文件中定义函数。假设在头文件中定义函数，复制粘贴后还是重定义，也只能在头文件中声明函数。不过对于非显式static修饰的函数而言，不带extern的声明会被编译器视为自动带上extern。</p>
<p>综上，extern用于实现只声明，不定义。（不分配空间并赋值）</p>
<p>进一步的例子：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// func.cpp </span></span><br><span class="line"><span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">    x += a;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// main.cpp </span></span><br><span class="line">______(填空)_____<span class="comment">//仅仅只需填写 int add(int)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">add</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里不必然声明extern int x，因为调用add后，add和x在一个cpp下，是可以调用的。然而，必须要在main.cpp当中声明add才可以调用。注意到，extern对于非显式static修饰的全局函数没有必要是指不写extern也会自动变extern，而不是说在其他cpp中调用这个函数不需要声明。</p>
<p>另外，编译器能够识别int add(int)和int add(int x)为同一个函数，名字和形参类型一样就是一个函数。</p>
<p>更进一步：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// func.cpp </span></span><br><span class="line"><span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">    x += a;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// main.cpp </span></span><br><span class="line"><span class="keyword">int</span> x=<span class="number">10</span>；</span><br><span class="line"><span class="keyword">int</span> <span class="built_in">add</span>(<span class="keyword">int</span>);</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">add</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我的两个x定义在两个cpp里，且对于各自的cpp而言而言他们都是非static的，故而会multi-definition。</p>
<p>结论：对于头文件，尽量只声明函数而不实现函数。尽量只声明全局变量而不定义全局变量。</p>
<h3 id="1-2-6-全局变量与局部变量"><a href="#1-2-6-全局变量与局部变量" class="headerlink" title="1.2.6  全局变量与局部变量"></a>1.2.6  全局变量与局部变量</h3><p>全局变量和局部变量是从变量的作用域的角度划分。<br>静态变量和动态变量是从变量的内存分配的角度划分。</p>
<p>全局变量本身是非静态存储方式，静态全局变量是静态存储方式。这两者在存储方式上并无不同，区别在于非静态全局变量的作用域是整个源程序，当一个源程序由多个源文件组成时，非静态的全局变量在各个源文件（所有的cpp文件）中都是有效的。而静态全局变量则限制了其作用域，即只在定义该变量的源文件（某个cpp文件）内有效，在同一源程序的其它源文件中不能使用它。（具体解释是静态全局变量仅仅内部可链接）</p>
<h3 id="1-2-7-内部可链接与外部可链接"><a href="#1-2-7-内部可链接与外部可链接" class="headerlink" title="1.2.7  内部可链接与外部可链接"></a>1.2.7  内部可链接与外部可链接</h3><p>编译单元：简单来说一个cpp文件就是一个编译单元。当一个c或cpp文件在编译时，预处理器首先递归包含头文件，形成一个含有所有必要信息的单个源文件，这个源文件就是一个编译单元。</p>
<p>事实上，编译每个编译单元(.cpp)时是相互独立的，即每个cpp文件之间是不知道对方的存在的。（不考虑#include “xxx.cpp” 这种奇葩的写法）编译器会分别将每个编译单元(.cpp)进行编译，生成相应的obj文件。然后链接器会将所有的obj文件进行链接，生成最终可执行文件。</p>
<p>我们知道C++中声明和定义可以分开。例如我们可以一个函数声明定义放在b.cpp中，在a.cpp只需再声明一下这个函数，就可以在a.cpp中使用这个函数。例如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">show</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;&#125;<span class="comment">//这个是a.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span>void show()</span></span><br><span class="line">&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Hello&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;<span class="comment">//这个是b.cpp</span></span><br></pre></td></tr></table></figure>
<p>而通过之前的了解，我们知道每个编译单元间是相互独立不知道彼此的存在的。那么a.cpp又是如何知道show函数的定义的呢？</p>
<p>其实在编译一个编译单元(.cpp)生成相应的obj文件过程中，编译器会将分析这个编译单元(.cpp)，将其所能提供给其他编译单元(.cpp)使用的函数，变量定义记录下来。而将自己缺少的函数，变量的定义也记录下来。所以可以认为a.obj和b.obj记录了以下的信息：</p>
<blockquote>
<p>a.obj:我能提供main函数的定义，我需要show函数的定义</p>
<p>b.obj:我能提供show函数的定义</p>
</blockquote>
<p>然后在链接器连接的时候就会知道a.obj需要show函数定义，而b.obj中恰好提供了show函数的定义，通过链接，在最终的可执行文件中我们能看到show函数的运行。</p>
<p>内部连接：如果一个名称对编译单元(.cpp)来说是局部的，在链接的时候其他的编译单元无法链接到它且不会与其它编译单元(.cpp)中的同样的名称相冲突。例如static函数，inline函数等（注：用static修饰的函数，本限定在本源码文件中，不能被本源码文件以外的代码文件调用。而普通的函数，默认是extern的，也就是说，可以被其它代码文件调用该函数）</p>
<p>外部连接：如果一个名称对编译单元(.cpp)来说不是局部的，而在链接的时候其他的编译单元可以访问它，也就是说它可以和别的编译单元交互。例如非静态全局变量就是外部链接。</p>
<p>PPT第14和15页有两个比较简单的例子，可以简单看一看。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span>  </span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line"><span class="keyword">public</span>:    </span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">output</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        cout &lt;&lt; data &lt;&lt; endl; <span class="comment">// 编译错误</span></span><br><span class="line">    &#125;  </span><br><span class="line">&#125;;  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    A a;  </span><br><span class="line">    a.<span class="built_in">output</span>();  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//Vehicle.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vehicle</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">int</span> wheel = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> wings = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> max_wheel_num = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> max_wing_num = <span class="number">0</span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">add_wheel</span><span class="params">()</span> </span>&#123; wheel++; <span class="keyword">return</span>; &#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">add_wing</span><span class="params">()</span> </span>&#123; wings++; <span class="keyword">return</span>; &#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">finished</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (wheel == max_wheel_num)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">virtual</span> ~<span class="built_in">Vehicle</span>() &#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;I am running&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">set_max_wheel_num</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; max_wheel_num = x; <span class="keyword">return</span>; &#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">set_max_wing_num</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; max_wing_num = x; <span class="keyword">return</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Plane.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&quot;Vehicle.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Plane</span> :</span> <span class="keyword">public</span> Vehicle &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Plane</span>() &#123;</span><br><span class="line">        <span class="built_in">set_max_wheel_num</span>(<span class="number">3</span>);</span><br><span class="line">        <span class="built_in">set_max_wing_num</span>(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;I am running and flying&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">finished</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ((wheel == <span class="number">3</span>) &amp;&amp; (wings == <span class="number">2</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> [Error] invalid use of member <span class="string">&#x27;A::data&#x27;</span> in <span class="keyword">static</span> member function</span><br></pre></td></tr></table></figure>
<h2 id="1-3-static-数据成员（类变量）"><a href="#1-3-static-数据成员（类变量）" class="headerlink" title="1.3  static 数据成员（类变量）"></a>1.3  static 数据成员（类变量）</h2><h3 id="1-3-0-声明、定义、初始化、赋值"><a href="#1-3-0-声明、定义、初始化、赋值" class="headerlink" title="1.3.0  声明、定义、初始化、赋值"></a>1.3.0  声明、定义、初始化、赋值</h3><p>声明（declaration ）指定了一个变量的标识符，用来描述变量的种类，是类型还是对象，或者函数等。声明，用于编译器(compiler)识别变量名所引用的实体。</p>
<p>广义的角度上来讲定义是声明的特例，一般情况下把分配了内存空间的声明称作定义，不需要存储空间的声明称作声明。</p>
<p>对于全局变量，<code>int a;</code>这是定义性声明，或称定义。<code>extern int a;</code>这是引用性声明。对于.h文件里的class，仅仅<code>static int x；</code>这是声明（没有分配内存空间）。如果在class里就写上<code>static int x=0；</code>（就地初始化），这里既完成了声明，又完成了定义（分配了内存空间），但是这么写不规范，大多编译器都会报错。（下文会解释）</p>
<p><code>extern int a;</code>只能全局变量用，只声明但是不分配。但是全局变量int a既完成了声明也完成了定义，编译器默认赋值为0。对于class，static int a就起到了只声明不分配（也就是只声明不定义）的作用。</p>
<p>初始化和定义的意义相近，广义上将就是分配了储存空间并完成了赋初始值。而赋值就是给已经完成定义的内存空间赋值。</p>
<h3 id="1-3-1-静态数据成员定义与基本性质"><a href="#1-3-1-静态数据成员定义与基本性质" class="headerlink" title="1.3.1  静态数据成员定义与基本性质"></a>1.3.1  静态数据成员定义与基本性质</h3><p>使用static修饰的数据成员，是隶属于类的，称为类的静态数据成员，也称“类变量”。该数据成员被该类的所有对象共享，即所有对象中的这个数据域处在同一内存位置，在类实例化对象前已分配内存空间。</p>
<p>类的静态成员（数据、函数）既可以通过对象来访问，也可以通过类名来访问，如ClassName::static_var或者a.static_var（a为ClassName类的对象）</p>
<p>类的静态成员在实现文件(.cpp)中赋初值，格式为：<code>Type ClassName::static_var = Value;</code></p>
<p>和全局变量一样，类的静态数据成员在程序开始前初始化。应该在h文件里声明（不分配内存空间），在cpp文件里定义（分配内存空间且初始化）。</p>
<p>最好不要在h文件里定义（也就是写static int x=0）。如果这么做，可能会导致重复定义（重复分配内存空间），故而这么写不太好。可能造成重定义而无法完成链接，编译失败。</p>
<h3 id="1-3-2-例子"><a href="#1-3-2-例子" class="headerlink" title="1.3.2  例子"></a>1.3.2  例子</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span>  </span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line"><span class="keyword">public</span>:    </span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">output</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        cout &lt;&lt; data &lt;&lt; endl; <span class="comment">// 编译错误</span></span><br><span class="line">    &#125;  </span><br><span class="line">&#125;;  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    A a;  </span><br><span class="line">    a.<span class="built_in">output</span>();  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"> [Error] invalid use of member <span class="string">&#x27;A::data&#x27;</span> in <span class="keyword">static</span> member function</span><br></pre></td></tr></table></figure>
<p><img src="https://s2.loli.net/2022/01/11/kK3hdEZISCcznH5.png" alt="https://s2.loli.net/2022/01/11/kK3hdEZISCcznH5.png"></p>
<p>这个例子的意义：注意到我通过构造函数构造了个Test数组，含有10个对象，每调用一次构造函数就会给count++；从而加了10次。（这其实也体现了static数据是整个类共享的）</p>
<h2 id="1-4-static成员函数"><a href="#1-4-static成员函数" class="headerlink" title="1.4  static成员函数"></a>1.4  static成员函数</h2><h3 id="1-4-1-定义与基本性质"><a href="#1-4-1-定义与基本性质" class="headerlink" title="1.4.1  定义与基本性质"></a>1.4.1  定义与基本性质</h3><p>在返回值前面添加static修饰的成员函数，称为类的静态成员函数。</p>
<p>和静态数据成员类似，类的静态成员函数既可以通过对象来访问，也可以通过类名来访问，如ClassName::static_function或者a.static_function(a为ClassName类的对象）</p>
<p>静态成员函数属于整个类，在类实例化对象之前已经分配了内存空间。<br>类的非静态成员必须在类实例化对象后才分配内存空间。如果使用静态成员函数访问非静态成员，相当于没有定义一个变量却要使用它。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span>  </span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line"><span class="keyword">public</span>:    </span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">output</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        cout &lt;&lt; data &lt;&lt; endl; <span class="comment">// 编译错误</span></span><br><span class="line">    &#125;  </span><br><span class="line">&#125;;  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    A a;  </span><br><span class="line">    a.<span class="built_in">output</span>();  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"> [Error] invalid use of member <span class="string">&#x27;A::data&#x27;</span> in <span class="keyword">static</span> member function</span><br></pre></td></tr></table></figure>
<p>看上去output将会输出a的data，而且a已经初始化了，貌似可以输出。但是由于Static成员函数没有this指针，故而output没法得知输出的是this-&gt;data，从而编译失败。</p>
<p>但是静态成员函数是可以修改静态数据成员的，比如这段代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span>&#123;</span></span><br><span class="line">   <span class="keyword">const</span> <span class="keyword">int</span> member1;</span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">float</span> member2;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   <span class="built_in">Test</span>(<span class="keyword">int</span> mem):<span class="built_in">member1</span>(mem)&#123;&#125;</span><br><span class="line">   <span class="function"><span class="keyword">int</span> <span class="title">MyMember1</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> member1;&#125;</span><br><span class="line">   <span class="function"><span class="keyword">static</span> <span class="keyword">float</span> <span class="title">Mymember2</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> member2;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">float</span> Test::member2 = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<p>这里Mymember2是可以访问member2的，因为member2是静态数据成员。</p>
<p>与静态数据成员有区别的是，静态成员函数可以在.h中实现。（可以但是不推荐，志愿者说希望实现都放到相应的.cpp里面）</p>
<p>PPT上的例子较为简单，可自行阅读。</p>
<h1 id="二、常量数据成员与函数"><a href="#二、常量数据成员与函数" class="headerlink" title="二、常量数据成员与函数"></a>二、常量数据成员与函数</h1><h2 id="2-1-常量"><a href="#2-1-常量" class="headerlink" title="2.1  常量"></a>2.1  常量</h2><h3 id="2-1-1-定义"><a href="#2-1-1-定义" class="headerlink" title="2.1.1  定义"></a>2.1.1  定义</h3><p>常量关键字const常用于修饰变量、引用/指针、函数返回值。</p>
<h3 id="2-1-2-性质"><a href="#2-1-2-性质" class="headerlink" title="2.1.2  性质"></a>2.1.2  性质</h3><p>修饰变量时（如const int n = 1;），必须就地初始化，该变量的值在其生命周期内都不会发生变化。修饰引用/指针时（如int a=1; const int&amp; b=a;），不能通过该引用/指针修改相应变量的值，常用于函数参数以保证函数体中无法修改参数的值。修饰函数返回值时（如const int* func() {…}），函数返回值的内容（或其指向的内容）不能被修改。</p>
<h2 id="2-2-常量数据成员-const"><a href="#2-2-常量数据成员-const" class="headerlink" title="2.2  常量数据成员(const)"></a>2.2  常量数据成员(const)</h2><h3 id="2-2-1-定义"><a href="#2-2-1-定义" class="headerlink" title="2.2.1  定义"></a>2.2.1  定义</h3><p>使用const修饰的数据成员，称为类的常量数据成员，在对象（具体某个对象，而非一个类共有）的整个生命周期里不可更改。</p>
<h3 id="2-2-2-初始化"><a href="#2-2-2-初始化" class="headerlink" title="2.2.2  初始化"></a>2.2.2  初始化</h3><p>构造函数的初始化列表中被初始化，就地初始化，但是不允许在构造函数的函数体中通过赋值来设置。</p>
<h3 id="2-2-3-对“不能赋值”的理解"><a href="#2-2-3-对“不能赋值”的理解" class="headerlink" title="2.2.3  对“不能赋值”的理解"></a>2.2.3  对“不能赋值”的理解</h3><p>为什么不能在构造函数里面初始化常量？</p>
<blockquote>
<p>构造函数也是函数，常量的意思就是函数不可以改。——cqq</p>
<p>常量只能定义不能赋值，在任何函数体里的都算是赋值语句，构造函数体也算。——cyd</p>
<p>当执行到构造函数的函数体里的时候，实例已经构造完成了（this指针已经存在），这时就只能修改它的一些非const属性了。——单带师</p>
</blockquote>
<h2 id="2-3-常量成员函数"><a href="#2-3-常量成员函数" class="headerlink" title="2.3  常量成员函数"></a>2.3  常量成员函数</h2><h3 id="2-3-1-定义"><a href="#2-3-1-定义" class="headerlink" title="2.3.1  定义"></a>2.3.1  定义</h3><p>成员函数也能用const来修饰，称为常量成员函数。</p>
<h3 id="2-3-2-意义"><a href="#2-3-2-意义" class="headerlink" title="2.3.2  意义"></a>2.3.2  意义</h3><p>实现语句不能修改类的数据成员，即不能改变对象状态（内容）。</p>
<p>非常量对象的常量成员函数不能访问不修改对象状态的非常量成员函数。</p>
<p>所谓常量成员函数不能修改类的数据成员，这句话是对的，因为这是PPT的原话，但是这句话有很多问题。首先，实际上A类a对象的常量成员函数不能修改a的所有成员数据，但是可以修改A类的静态数据成员，甚至还可以修改A类另外一个b对象的成员数据，就只是不能修改独属于自己的成员数据。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span>&#123;</span></span><br><span class="line">   <span class="keyword">const</span> <span class="keyword">int</span> member1;</span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">float</span> member2;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> zcy=<span class="number">0</span>;</span><br><span class="line">   <span class="built_in">Test</span>(<span class="keyword">int</span> mem):<span class="built_in">member1</span>(mem)&#123;&#125;</span><br><span class="line">   <span class="function"><span class="keyword">int</span> <span class="title">MyMember1</span><span class="params">(Test &amp;a)</span> <span class="keyword">const</span> </span>&#123;a.zcy+=<span class="number">100</span>;<span class="keyword">return</span> member1;&#125;</span><br><span class="line">   <span class="function"><span class="keyword">static</span> <span class="keyword">float</span> <span class="title">Mymember2</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> member2;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">float</span> Test::member2 = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="function">Test <span class="title">a</span><span class="params">(<span class="number">0</span>)</span>,<span class="title">b</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">	a.<span class="built_in">MyMember1</span>(b);</span><br><span class="line">	cout&lt;&lt;b.zcy&lt;&lt;endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">output：</span><br><span class="line"><span class="number">100</span></span><br></pre></td></tr></table></figure>
<h3 id="2-3-3-写法"><a href="#2-3-3-写法" class="headerlink" title="2.3.3  写法"></a>2.3.3  写法</h3><p><code>ReturnType Func(…) const &#123;…&#125;</code></p>
<p>注意区别：<code>const ReturnType Func(…) &#123;…&#125;</code></p>
<p>后者是返回值为常量，也就是前文提及的“修饰函数返回值时（如const int* func() {…}），函数返回值的内容（或其指向的内容）不能被修改。”</p>
<h2 id="2-4-常量对象"><a href="#2-4-常量对象" class="headerlink" title="2.4  常量对象"></a>2.4  常量对象</h2><p>若对象被定义为常量(const ClassName a;)，则它只能调用以const修饰的成员函数与静态成员函数。不能调用任何既非常量，也非静态的函数。以及，常量对象可以成为非常量成员函数的参数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span>&#123;</span></span><br><span class="line">   <span class="keyword">const</span> <span class="keyword">int</span> member1;</span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">float</span> member2;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> zcy=<span class="number">0</span>;</span><br><span class="line">   <span class="built_in">Test</span>(<span class="keyword">int</span> mem):<span class="built_in">member1</span>(mem)&#123;&#125;</span><br><span class="line">   <span class="function"><span class="keyword">int</span> <span class="title">func1</span><span class="params">()</span></span>&#123;cout&lt;&lt;<span class="string">&quot;当然调用不了&quot;</span>&lt;&lt;endl;<span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br><span class="line">   <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">func2</span><span class="params">()</span></span>&#123;cout&lt;&lt;<span class="string">&quot;这个调用的了&quot;</span>&lt;&lt;endl;<span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br><span class="line">   <span class="function"><span class="keyword">int</span> <span class="title">MyMember1</span><span class="params">(Test &amp;a)</span> <span class="keyword">const</span> </span>&#123;a.zcy+=<span class="number">100</span>;<span class="keyword">return</span> member1;&#125;</span><br><span class="line">   <span class="function"><span class="keyword">static</span> <span class="keyword">float</span> <span class="title">Mymember2</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> member2;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">float</span> Test::member2 = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="function">Test <span class="title">a</span><span class="params">(<span class="number">0</span>)</span>,<span class="title">b</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">const</span> Test <span class="title">c</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">c.<span class="built_in">func2</span>();</span><br><span class="line">a.<span class="built_in">MyMember1</span>(b);</span><br><span class="line">cout&lt;&lt;b.zcy&lt;&lt;endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">output:</span><br><span class="line">这个调用的了</span><br><span class="line"><span class="number">100</span></span><br></pre></td></tr></table></figure>
<h2 id="2-5-常量静态变量"><a href="#2-5-常量静态变量" class="headerlink" title="2.5  常量静态变量"></a>2.5  常量静态变量</h2><h3 id="2-5-1-定义"><a href="#2-5-1-定义" class="headerlink" title="2.5.1  定义"></a>2.5.1  定义</h3><p>我们可以定义既是常量也是静态的变量。常量意味着不可改，静量意味着特定的作用区域。我们可以进一步定义常量静态成员数据，作为不可更改的类变量。</p>
<h3 id="2-5-2-定义方法"><a href="#2-5-2-定义方法" class="headerlink" title="2.5.2  定义方法"></a>2.5.2  定义方法</h3><p>和静态变量一样，在类内只进行声明（不分配空间），在.cpp里才定义。（完成内存分配并赋初值）</p>
<blockquote>
<p>（回顾：static成员数据要在cpp里声明，在.h里定义；而const类型要在初始化列表里初始化或者就地初始化）</p>
</blockquote>
<p>写成const static和static const没有区别。</p>
<p>有两个例外：int和enum（枚举型）类型可以就地初始化。（但也不推荐这么写）故而，静态数据成员必须在类外定义，但是常量静态数据成员中int和enum（枚举型）类型可以就地初始化。</p>
<p>故而判断题：常量静态的成员变量只能在类外进行初始化。是错的，这不是“你可以在类内写，但是不推荐”这意思，而是强调了两个特例。</p>
<h3 id="2-5-3-访问权限"><a href="#2-5-3-访问权限" class="headerlink" title="2.5.3  访问权限"></a>2.5.3  访问权限</h3><p>常量静态变量和静态变量一样，满足访问权限的任意函数均可访问，但由于const的修饰都不能修改。</p>
<h2 id="2-6-常量静态函数不存在"><a href="#2-6-常量静态函数不存在" class="headerlink" title="2.6  常量静态函数不存在"></a>2.6  常量静态函数不存在</h2><p>常量成员函数依赖于具体的对象，不能修改对象的数据成员。静态成员函数不依赖于对象，它属于整个类，只能调用静态成员。故而对于函数而言，常量和静态是矛盾的。</p>
<h2 id="2-7-重载匹配性"><a href="#2-7-重载匹配性" class="headerlink" title="2.7  重载匹配性"></a>2.7  重载匹配性</h2><p><img src="https://s2.loli.net/2022/01/11/vFdsRK7MBulipCO.png" alt="https://s2.loli.net/2022/01/11/vFdsRK7MBulipCO.png"></p>
<p>常量成员函数和非常量成员函数构成重载时，传入两函数的参数中this指针的类型不同。常量成员函数的传入指针类型是const Num<em>，而非常量成员函数的传入指针类型是Num</em>，所以非常量对象会优先匹配非常量成员函数，而不是进行类型转换，将this 转换为const this再使用。</p>
<h1 id="三、构造与析构"><a href="#三、构造与析构" class="headerlink" title="三、构造与析构"></a>三、构造与析构</h1><h2 id="3-1-常量对象的构造与析构"><a href="#3-1-常量对象的构造与析构" class="headerlink" title="3.1  常量对象的构造与析构"></a>3.1  常量对象的构造与析构</h2><p>常量对象和非常量对象基本相同。<br>常量全局对象：在main()函数调用之前进行初始化，在main()函数执行完return，程序结束时，对象被析构。<br>常量局部对象：在程序执行到该局部对象的代码时被初始化。在局部对象生命周期结束、即所在作用域结束后被析构。</p>
<h2 id="3-2-静态对象的构造与析构"><a href="#3-2-静态对象的构造与析构" class="headerlink" title="3.2  静态对象的构造与析构"></a>3.2  静态对象的构造与析构</h2><p>静态全局对象的构造与析构时机和普通全局对象相同。（即：在main()调用前初始化，在main（）执行完return后被析构）</p>
<p>静态局部对象在程序执行到该静态局部对象的代码时被初始化，但是离开作用域不析构。第二次执行到该对象代码时，不再初始化，直接使用上一次的对象。（这里和静态局部变量非常相似）</p>
<p>在main()函数结束后被析构。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(i&gt;=n)</span><br><span class="line">			<span class="function"><span class="keyword">static</span> A <span class="title">static_obj</span><span class="params">(<span class="string">&quot;static&quot;</span>)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>比如这段代码，虽然看上去会给static_obj多次构造，但是由于其是静态局部对象，故而只会构造一次。之后每次利用上一次剩下部分。（相当于函数里内，第一次以后的对静态局部变量的构造失效）</p>
<h2 id="3-3-类静态对象构造与析构"><a href="#3-3-类静态对象构造与析构" class="headerlink" title="3.3  类静态对象构造与析构"></a>3.3  类静态对象构造与析构</h2><p>类A的对象a作为类B的静态变量。比如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span>&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> &#123;</span></span><br><span class="line">    <span class="keyword">static</span> A a; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>a的构造与析构表现和全局对象类似，即在main()函数调用之前进行初始化，在main()函数执行完return，程序结束时，对象被析构。a作为b的类对象，和B是否实例化无关。（这个和类里面的默认类型的静态变量,比如B里面的对象static int c;是一样的）</p>
<p><img src="https://s2.loli.net/2022/01/11/tg7ZEfJmuDk63eV.png" alt="https://s2.loli.net/2022/01/11/tg7ZEfJmuDk63eV.png"></p>
<p>这个例子值得注意的就是，fun函数体类的静态局部对象只有一次构造，并没有四次。</p>
<p>另外，<code>A B::a1(“static B::a1”);</code>是什么意思？<br>这里是在类外定义B的static数据成员a1，而前面的A则是在使用构造函数。这里必须指定是B::a1，不然<code>A a1(“static B::a1”);</code>则会定义一个全局变量，而不是构造B的static数据成员。</p>
<h2 id="3-4-参数对象构造与析构"><a href="#3-4-参数对象构造与析构" class="headerlink" title="3.4  参数对象构造与析构"></a>3.4  参数对象构造与析构</h2><h3 id="3-4-1-传递形参"><a href="#3-4-1-传递形参" class="headerlink" title="3.4.1  传递形参"></a>3.4.1  传递形参</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(A b)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;In fun: b.s=&quot;</span> &lt;&lt; b.s &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">fun</span>(a);</span><br></pre></td></tr></table></figure>
<p>在函数被调用时，b被构造，调用拷贝构造函数（见拷贝构造一节的PPT）进行初始化。默认情况下，对象b的属性值和a一致。在函数结束时，调用析构函数，b被析构。</p>
<p><img src="https://s2.loli.net/2022/01/11/Z147ePBAHWhI2c5.png" alt="https://s2.loli.net/2022/01/11/Z147ePBAHWhI2c5.png"></p>
<p>结合后续学习的拷贝构造和移动构造，我们当然可以确定形参会发生一次拷贝构造，但是为什么没有相应的输出呢？</p>
<p>因为，没有显式定义拷贝构造函数，系统调用了隐式生成的拷贝构造函数，这当然是没有输出的。形参的构造用的是拷贝构造函数，可是析构却是共用的一个析构函数。</p>
<h3 id="3-4-2-传递引用与指针"><a href="#3-4-2-传递引用与指针" class="headerlink" title="3.4.2  传递引用与指针"></a>3.4.2  传递引用与指针</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(A &amp;b)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;In fun: b.s=&quot;</span> &lt;&lt; b.s &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">fun</span>(a);</span><br></pre></td></tr></table></figure>
<p>在函数被调用时，b不需要被拷贝构造，因为b是a的引用。在函数结束时，也不需要调用析构函数，因为b只是一个引用，而不是A的对象。</p>
<h3 id="3-4-3-类成员含有指针"><a href="#3-4-3-类成员含有指针" class="headerlink" title="3.4.3  类成员含有指针"></a>3.4.3  类成员含有指针</h3><p>如果传入形参而不是引用或指针，由于拷贝构造不会将被拷贝者置空，故而形参和实参的指针指向了完全相同的地址。但是形参会在函数体结束后析构，将形参指向的空间释放掉。我的实参又会在主函数结束后析构，这时实参指向的空间将会被再次析构，反复析构，析构空的内存空间，从而报错。</p>
<p>这另一方面启发我们，含有指针的类，一般希望用移动构造而非拷贝构造。</p>
<h3 id="3-4-4-传入引用的优点"><a href="#3-4-4-传入引用的优点" class="headerlink" title="3.4.4  传入引用的优点"></a>3.4.4  传入引用的优点</h3><p>尽量使用对象引用作为参数，这样做还可以减少时间开销。（因为省去了拷贝构造形参的时间）</p>
<h1 id="四、对象的-new-和-delete"><a href="#四、对象的-new-和-delete" class="headerlink" title="四、对象的 new 和 delete"></a>四、对象的 new 和 delete</h1><h2 id="4-1-概述"><a href="#4-1-概述" class="headerlink" title="4.1  概述"></a>4.1  概述</h2><p>new：生成一个类对象（注意不是类静态对象），并返回地址。（调用默认构造函数，生成了100个A类对象） A <em>pA=new A[100]; （调用默认构造函数）A </em>pA=new A（100）（调用带参数的构造函数，构造了一个A类对象）</p>
<p>delete：删除该类对象，释放内存资源。（调用析构函数）</p>
<p><code>delete pA;</code>（释放生成的那个A类对象）；<code>delete [] pA;</code>（释放生成的那100个A类对象）</p>
<h2 id="4-2-图示"><a href="#4-2-图示" class="headerlink" title="4.2  图示"></a>4.2  图示</h2><p>对于大多数编译器，这个过程可以如下概述。   </p>
<p><img src="https://s2.loli.net/2022/01/11/IRrh3fpX9QvMS7W.png" alt="https://s2.loli.net/2022/01/11/IRrh3fpX9QvMS7W.png"></p>
<p><img src="https://s2.loli.net/2022/01/11/hSsgBUed3YrWAak.png" alt="https://s2.loli.net/2022/01/11/hSsgBUed3YrWAak.png"></p>
<p><img src="https://s2.loli.net/2022/01/11/fNFlxUQiBdMbKHa.png" alt="https://s2.loli.net/2022/01/11/fNFlxUQiBdMbKHa.png"></p>
<p><img src="https://s2.loli.net/2022/01/11/p7r5ERiJfT6t9dK.png" alt="https://s2.loli.net/2022/01/11/p7r5ERiJfT6t9dK.png"></p>
<p><img src="https://s2.loli.net/2022/01/11/AoqHudFcbUpXYrQ.png" alt="https://s2.loli.net/2022/01/11/AoqHudFcbUpXYrQ.png"></p>
<h2 id="4-3-匹配项"><a href="#4-3-匹配项" class="headerlink" title="4.3  匹配项"></a>4.3  匹配项</h2><h3 id="4-3-1-搭配使用"><a href="#4-3-1-搭配使用" class="headerlink" title="4.3.1  搭配使用"></a>4.3.1  搭配使用</h3><p>new和delete要配套使用；new 和 delete，new[] 和 delete[]。</p>
<h3 id="4-3-2-搭配不当"><a href="#4-3-2-搭配不当" class="headerlink" title="4.3.2  搭配不当"></a>4.3.2  搭配不当</h3><p>对于大多编译器，如果同时使用new[]和delete，会有什么后果？</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">A *pA = <span class="keyword">new</span> A[<span class="number">3</span>];</span><br><span class="line"><span class="keyword">delete</span> pA;</span><br></pre></td></tr></table></figure>
<p>该delete命令做了两件事：调用一次 pA 指向的对象的析构函数，释放pA地址的内存。因为，只调用了一次析构函数，故而如果类对象中有大量申请内存的操作，那么因为没有调用析构函数，这些内存无法被释放，造成内存泄漏。</p>
<p>此外，直接释放pA指向的内存空间，这个会造成严重的段错误，程序必然会崩溃。因为分配空间的起始地址是pA-4byte。（delete[] pA的释放地址自动转换为pA-4byte）。</p>
<p><img src="https://s2.loli.net/2022/01/11/JtHQEs9OX1jiCfc.png" alt="https://s2.loli.net/2022/01/11/JtHQEs9OX1jiCfc.png"></p>
<p>new是会调用类A的构造函数的。（过程：分配内存-初始化-返回指针）<br>注意到这里第四个，我实际上是构造了A的指针数组，构造了10个A*类型的指针，但是没调用构造函数。</p>
<h1 id="五、友元"><a href="#五、友元" class="headerlink" title="五、友元"></a>五、友元</h1><h2 id="5-1-定义与基本性质"><a href="#5-1-定义与基本性质" class="headerlink" title="5.1  定义与基本性质"></a>5.1  定义与基本性质</h2><p>A类声明B为友元类或者友元函数，则B具有访问A的private及protected成员的访问权限，即可以访问A的一切成员。</p>
<p>友元的声明只能在类内进行。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Test</span>(<span class="keyword">int</span> i) : <span class="built_in">id</span>(i) &#123; cout &lt;&lt; <span class="string">&quot;obj_&quot;</span> &lt;&lt; id &lt;&lt; <span class="string">&quot; created\n&quot;</span>; &#125; </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">friend</span> istream&amp; <span class="keyword">operator</span>&gt;&gt; (istream&amp; in, Test&amp; dst); </span><br><span class="line">    <span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span>&lt;&lt; (ostream&amp; out, <span class="keyword">const</span> Test&amp; src); </span><br><span class="line">&#125;;</span><br><span class="line">istream&amp; <span class="keyword">operator</span>&gt;&gt; (istream&amp; in, Test&amp; dst) &#123;</span><br><span class="line">    in &gt;&gt; dst.id;</span><br><span class="line">    <span class="keyword">return</span> in;</span><br><span class="line">&#125;</span><br><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt; (ostream&amp; out, <span class="keyword">const</span> Test&amp; src) &#123;</span><br><span class="line">    out &lt;&lt; src.id;</span><br><span class="line">    <span class="keyword">return</span> out;</span><br><span class="line">&#125;   <span class="comment">// 以上类中声明了Test类的两个友元函数 —— 全局流运算符重载函数，</span></span><br><span class="line">    <span class="comment">// 使这两个函数在实现时可以访问对象的私有成员（如int id）.  </span></span><br><span class="line"><span class="comment">//并且，这两个流运算符任然是全局函数</span></span><br><span class="line"><span class="comment">//注意，&gt;&gt;的两个参数都不能加const，而&lt;&lt;的ostream参数不能加const</span></span><br></pre></td></tr></table></figure>
<p>流运算符重载往往会声明为友元函数，因为经常需要输出私有成员数据。</p>
<p>被友元声明的函数一定不是当前类的成员函数，即使该函数的定义写在当前类内。（注意事项一定不是，而不是不一定是）当前类的成员函数也不需要友元修饰。（因为成员函数本身就可以访问所有数据成员）</p>
<h2 id="5-2-跨类友元"><a href="#5-2-跨类友元" class="headerlink" title="5.2  跨类友元"></a>5.2  跨类友元</h2><h3 id="5-2-1-定义"><a href="#5-2-1-定义" class="headerlink" title="5.2.1  定义"></a>5.2.1  定义</h3><p>可以声明别的类的成员函数，为当前类的友元。其他类的构造函数、析构函数也可以是友元。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Y</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> data; </span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">X::foo</span><span class="params">(Y)</span></span>; </span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="title">X::X</span><span class="params">(Y)</span>, X::~<span class="title">X</span><span class="params">()</span></span>; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>X的构造函数X::X()和析构函数X::~X()为Y的友元函数，则在它们的函数体内可直接访问/修改Y的私有成员。</p>
<h3 id="5-2-2-区域无关性"><a href="#5-2-2-区域无关性" class="headerlink" title="5.2.2  区域无关性"></a>5.2.2  区域无关性</h3><p>友元的声明与当前所在域是否为private或public无关。</p>
<p><img src="https://s2.loli.net/2022/01/11/GQfuOc2b5KD1eyl.png" alt="https://s2.loli.net/2022/01/11/GQfuOc2b5KD1eyl.png"></p>
<h3 id="5-2-3-不冲突性"><a href="#5-2-3-不冲突性" class="headerlink" title="5.2.3  不冲突性"></a>5.2.3  不冲突性</h3><p>一个普通函数可以是多个类的友元函数。</p>
<h2 id="5-3-友元类"><a href="#5-3-友元类" class="headerlink" title="5.3  友元类"></a>5.3  友元类</h2><p>可对class/struct/union进行友元声明，代表该类的所有成员函数均为友元函数。</p>
<p>对基础类型的友元声明会被忽略（因为没有实际价值）。编译器可能会发出警告，但不会认为是错误。</p>
<p><img src="https://s2.loli.net/2022/01/11/LJ51QTet64hOywo.png" alt="https://s2.loli.net/2022/01/11/LJ51QTet64hOywo.png"></p>
<p>两行的区别：friend Y必须先定义class Y，但是friend class X可以不用先定义class X。</p>
<h2 id="5-4-友元的注意事项"><a href="#5-4-友元的注意事项" class="headerlink" title="5.4  友元的注意事项"></a>5.4  友元的注意事项</h2><h3 id="5-4-1-非对称性"><a href="#5-4-1-非对称性" class="headerlink" title="5.4.1  非对称性"></a>5.4.1  非对称性</h3><p>类A中声明B是A的友元类，则B可以访问A的私有成员，但A不能访问B的私有成员。</p>
<h3 id="5-4-2-非传递性"><a href="#5-4-2-非传递性" class="headerlink" title="5.4.2  非传递性"></a>5.4.2  非传递性</h3><p>你的附庸的附庸不是你的附庸。</p>
<h3 id="5-4-3-不可继承"><a href="#5-4-3-不可继承" class="headerlink" title="5.4.3  不可继承"></a>5.4.3  不可继承</h3><h3 id="5-4-4-友元声明不能定义新的class"><a href="#5-4-4-友元声明不能定义新的class" class="headerlink" title="5.4.4  友元声明不能定义新的class"></a>5.4.4  友元声明不能定义新的class</h3><p><img src="https://s2.loli.net/2022/01/11/k9plcrx1AvFo6Vt.png" alt="https://s2.loli.net/2022/01/11/k9plcrx1AvFo6Vt.png"></p>
<p>左图是我先有了B才能定义B为A的友元。而右边企图在X类内定义Y为友元类，并给出Y的定义，这是不合法的。（不过friend class Y; 倒是可以，即使so far还没有定义Y）</p>
</article><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="addthis_inline_share_toolbox"></div><script src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-62b11572b25ab3ab" async="async"></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/01/12/Lecture/%E4%BB%8E%E5%89%8D%E7%9A%84%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/OOP/L3%20%E5%B0%81%E8%A3%85%E4%B8%8E%E6%8E%A5%E5%8F%A3/"><img class="prev-cover" src="https://raw.githubusercontent.com/zhaochenyang20/ivue_wallpaper/main/ivue_desktop/Photo by Egor Myznik (RtR2i-Fo6iI).jpg" onerror="onerror=null;src='https://raw.githubusercontent.com/zhaochenyang20/ivue_wallpaper/main/ivue_desktop/Photo by Oscar Rodrigo Hernandez Panczenko (P0GQ95huhBo).jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">oop笔记  L3  封装与接口</div></div></a></div><div class="next-post pull-right"><a href="/2022/01/12/Lecture/%E4%BB%8E%E5%89%8D%E7%9A%84%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/OOP/L6%20%E5%BC%95%E7%94%A8%E4%B8%8E%E5%A4%8D%E5%88%B6/"><img class="next-cover" src="https://raw.githubusercontent.com/zhaochenyang20/ivue_wallpaper/main/ivue_desktop/Photo by Samuel Ferrara (uOi3lg8fGl4).jpg" onerror="onerror=null;src='https://raw.githubusercontent.com/zhaochenyang20/ivue_wallpaper/main/ivue_desktop/Photo by Oscar Rodrigo Hernandez Panczenko (P0GQ95huhBo).jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">oop笔记  L6  引用与复制</div></div></a></div></nav><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="gitalk-container"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#L5-%E5%88%9B%E5%BB%BA%E4%B8%8E%E9%94%80%E6%AF%81%C2%B7%E4%BA%8C"><span class="toc-number">1.</span> <span class="toc-text">L5 创建与销毁·二</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%80%9F%E8%A7%88%E8%A1%A8%E6%A0%BC"><span class="toc-number">2.</span> <span class="toc-text">速览表格</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E5%8F%98%E9%87%8F%E4%B8%8E%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F"><span class="toc-number">3.</span> <span class="toc-text">一、变量与静态变量</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-1-%E5%9B%9B%E7%B1%BB%E5%8F%98%E9%87%8F%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">3.1.</span> <span class="toc-text">1.1  四类变量的区别</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-1-%E6%8C%89%E5%AD%98%E5%82%A8%E5%8C%BA%E5%9F%9F%E5%88%86"><span class="toc-number">3.1.1.</span> <span class="toc-text">1.1.1  按存储区域分</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-2-%E6%8C%89%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%88%86"><span class="toc-number">3.1.2.</span> <span class="toc-text">1.1.2  按作用域分</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-3-%E5%BD%A2%E5%8F%82%E5%8F%98%E9%87%8F"><span class="toc-number">3.1.3.</span> <span class="toc-text">1.1.3  形参变量</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-2-%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F"><span class="toc-number">3.2.</span> <span class="toc-text">1.2  静态变量</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-0-%E6%84%8F%E4%B9%89"><span class="toc-number">3.2.1.</span> <span class="toc-text">1.2.0  意义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-1-%E5%AE%9A%E4%B9%89"><span class="toc-number">3.2.2.</span> <span class="toc-text">1.2.1  定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-2-%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">3.2.3.</span> <span class="toc-text">1.2.2  初始化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-3-%E9%9D%99%E6%80%81%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F"><span class="toc-number">3.2.4.</span> <span class="toc-text">1.2.3  静态局部变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-4-%E9%9D%99%E6%80%81%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F"><span class="toc-number">3.2.5.</span> <span class="toc-text">1.2.4  静态全局变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-5-extern-%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="toc-number">3.2.6.</span> <span class="toc-text">1.2.5  extern 修饰符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-6-%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E4%B8%8E%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F"><span class="toc-number">3.2.7.</span> <span class="toc-text">1.2.6  全局变量与局部变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-7-%E5%86%85%E9%83%A8%E5%8F%AF%E9%93%BE%E6%8E%A5%E4%B8%8E%E5%A4%96%E9%83%A8%E5%8F%AF%E9%93%BE%E6%8E%A5"><span class="toc-number">3.2.8.</span> <span class="toc-text">1.2.7  内部可链接与外部可链接</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-3-static-%E6%95%B0%E6%8D%AE%E6%88%90%E5%91%98%EF%BC%88%E7%B1%BB%E5%8F%98%E9%87%8F%EF%BC%89"><span class="toc-number">3.3.</span> <span class="toc-text">1.3  static 数据成员（类变量）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-0-%E5%A3%B0%E6%98%8E%E3%80%81%E5%AE%9A%E4%B9%89%E3%80%81%E5%88%9D%E5%A7%8B%E5%8C%96%E3%80%81%E8%B5%8B%E5%80%BC"><span class="toc-number">3.3.1.</span> <span class="toc-text">1.3.0  声明、定义、初始化、赋值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-1-%E9%9D%99%E6%80%81%E6%95%B0%E6%8D%AE%E6%88%90%E5%91%98%E5%AE%9A%E4%B9%89%E4%B8%8E%E5%9F%BA%E6%9C%AC%E6%80%A7%E8%B4%A8"><span class="toc-number">3.3.2.</span> <span class="toc-text">1.3.1  静态数据成员定义与基本性质</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-2-%E4%BE%8B%E5%AD%90"><span class="toc-number">3.3.3.</span> <span class="toc-text">1.3.2  例子</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-4-static%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="toc-number">3.4.</span> <span class="toc-text">1.4  static成员函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4-1-%E5%AE%9A%E4%B9%89%E4%B8%8E%E5%9F%BA%E6%9C%AC%E6%80%A7%E8%B4%A8"><span class="toc-number">3.4.1.</span> <span class="toc-text">1.4.1  定义与基本性质</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E5%B8%B8%E9%87%8F%E6%95%B0%E6%8D%AE%E6%88%90%E5%91%98%E4%B8%8E%E5%87%BD%E6%95%B0"><span class="toc-number">4.</span> <span class="toc-text">二、常量数据成员与函数</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1-%E5%B8%B8%E9%87%8F"><span class="toc-number">4.1.</span> <span class="toc-text">2.1  常量</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-1-%E5%AE%9A%E4%B9%89"><span class="toc-number">4.1.1.</span> <span class="toc-text">2.1.1  定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-2-%E6%80%A7%E8%B4%A8"><span class="toc-number">4.1.2.</span> <span class="toc-text">2.1.2  性质</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-%E5%B8%B8%E9%87%8F%E6%95%B0%E6%8D%AE%E6%88%90%E5%91%98-const"><span class="toc-number">4.2.</span> <span class="toc-text">2.2  常量数据成员(const)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-1-%E5%AE%9A%E4%B9%89"><span class="toc-number">4.2.1.</span> <span class="toc-text">2.2.1  定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-2-%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">4.2.2.</span> <span class="toc-text">2.2.2  初始化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-3-%E5%AF%B9%E2%80%9C%E4%B8%8D%E8%83%BD%E8%B5%8B%E5%80%BC%E2%80%9D%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-number">4.2.3.</span> <span class="toc-text">2.2.3  对“不能赋值”的理解</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-3-%E5%B8%B8%E9%87%8F%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="toc-number">4.3.</span> <span class="toc-text">2.3  常量成员函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-1-%E5%AE%9A%E4%B9%89"><span class="toc-number">4.3.1.</span> <span class="toc-text">2.3.1  定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-2-%E6%84%8F%E4%B9%89"><span class="toc-number">4.3.2.</span> <span class="toc-text">2.3.2  意义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-3-%E5%86%99%E6%B3%95"><span class="toc-number">4.3.3.</span> <span class="toc-text">2.3.3  写法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-4-%E5%B8%B8%E9%87%8F%E5%AF%B9%E8%B1%A1"><span class="toc-number">4.4.</span> <span class="toc-text">2.4  常量对象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-5-%E5%B8%B8%E9%87%8F%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F"><span class="toc-number">4.5.</span> <span class="toc-text">2.5  常量静态变量</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5-1-%E5%AE%9A%E4%B9%89"><span class="toc-number">4.5.1.</span> <span class="toc-text">2.5.1  定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5-2-%E5%AE%9A%E4%B9%89%E6%96%B9%E6%B3%95"><span class="toc-number">4.5.2.</span> <span class="toc-text">2.5.2  定义方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5-3-%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90"><span class="toc-number">4.5.3.</span> <span class="toc-text">2.5.3  访问权限</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-6-%E5%B8%B8%E9%87%8F%E9%9D%99%E6%80%81%E5%87%BD%E6%95%B0%E4%B8%8D%E5%AD%98%E5%9C%A8"><span class="toc-number">4.6.</span> <span class="toc-text">2.6  常量静态函数不存在</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-7-%E9%87%8D%E8%BD%BD%E5%8C%B9%E9%85%8D%E6%80%A7"><span class="toc-number">4.7.</span> <span class="toc-text">2.7  重载匹配性</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E6%9E%84%E9%80%A0%E4%B8%8E%E6%9E%90%E6%9E%84"><span class="toc-number">5.</span> <span class="toc-text">三、构造与析构</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1-%E5%B8%B8%E9%87%8F%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%9E%84%E9%80%A0%E4%B8%8E%E6%9E%90%E6%9E%84"><span class="toc-number">5.1.</span> <span class="toc-text">3.1  常量对象的构造与析构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2-%E9%9D%99%E6%80%81%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%9E%84%E9%80%A0%E4%B8%8E%E6%9E%90%E6%9E%84"><span class="toc-number">5.2.</span> <span class="toc-text">3.2  静态对象的构造与析构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-3-%E7%B1%BB%E9%9D%99%E6%80%81%E5%AF%B9%E8%B1%A1%E6%9E%84%E9%80%A0%E4%B8%8E%E6%9E%90%E6%9E%84"><span class="toc-number">5.3.</span> <span class="toc-text">3.3  类静态对象构造与析构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-4-%E5%8F%82%E6%95%B0%E5%AF%B9%E8%B1%A1%E6%9E%84%E9%80%A0%E4%B8%8E%E6%9E%90%E6%9E%84"><span class="toc-number">5.4.</span> <span class="toc-text">3.4  参数对象构造与析构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-1-%E4%BC%A0%E9%80%92%E5%BD%A2%E5%8F%82"><span class="toc-number">5.4.1.</span> <span class="toc-text">3.4.1  传递形参</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-2-%E4%BC%A0%E9%80%92%E5%BC%95%E7%94%A8%E4%B8%8E%E6%8C%87%E9%92%88"><span class="toc-number">5.4.2.</span> <span class="toc-text">3.4.2  传递引用与指针</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-3-%E7%B1%BB%E6%88%90%E5%91%98%E5%90%AB%E6%9C%89%E6%8C%87%E9%92%88"><span class="toc-number">5.4.3.</span> <span class="toc-text">3.4.3  类成员含有指针</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-4-%E4%BC%A0%E5%85%A5%E5%BC%95%E7%94%A8%E7%9A%84%E4%BC%98%E7%82%B9"><span class="toc-number">5.4.4.</span> <span class="toc-text">3.4.4  传入引用的优点</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E5%AF%B9%E8%B1%A1%E7%9A%84-new-%E5%92%8C-delete"><span class="toc-number">6.</span> <span class="toc-text">四、对象的 new 和 delete</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#4-1-%E6%A6%82%E8%BF%B0"><span class="toc-number">6.1.</span> <span class="toc-text">4.1  概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-2-%E5%9B%BE%E7%A4%BA"><span class="toc-number">6.2.</span> <span class="toc-text">4.2  图示</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-3-%E5%8C%B9%E9%85%8D%E9%A1%B9"><span class="toc-number">6.3.</span> <span class="toc-text">4.3  匹配项</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-1-%E6%90%AD%E9%85%8D%E4%BD%BF%E7%94%A8"><span class="toc-number">6.3.1.</span> <span class="toc-text">4.3.1  搭配使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-2-%E6%90%AD%E9%85%8D%E4%B8%8D%E5%BD%93"><span class="toc-number">6.3.2.</span> <span class="toc-text">4.3.2  搭配不当</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E5%8F%8B%E5%85%83"><span class="toc-number">7.</span> <span class="toc-text">五、友元</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#5-1-%E5%AE%9A%E4%B9%89%E4%B8%8E%E5%9F%BA%E6%9C%AC%E6%80%A7%E8%B4%A8"><span class="toc-number">7.1.</span> <span class="toc-text">5.1  定义与基本性质</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-2-%E8%B7%A8%E7%B1%BB%E5%8F%8B%E5%85%83"><span class="toc-number">7.2.</span> <span class="toc-text">5.2  跨类友元</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-1-%E5%AE%9A%E4%B9%89"><span class="toc-number">7.2.1.</span> <span class="toc-text">5.2.1  定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-2-%E5%8C%BA%E5%9F%9F%E6%97%A0%E5%85%B3%E6%80%A7"><span class="toc-number">7.2.2.</span> <span class="toc-text">5.2.2  区域无关性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-3-%E4%B8%8D%E5%86%B2%E7%AA%81%E6%80%A7"><span class="toc-number">7.2.3.</span> <span class="toc-text">5.2.3  不冲突性</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-3-%E5%8F%8B%E5%85%83%E7%B1%BB"><span class="toc-number">7.3.</span> <span class="toc-text">5.3  友元类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-4-%E5%8F%8B%E5%85%83%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">7.4.</span> <span class="toc-text">5.4  友元的注意事项</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-4-1-%E9%9D%9E%E5%AF%B9%E7%A7%B0%E6%80%A7"><span class="toc-number">7.4.1.</span> <span class="toc-text">5.4.1  非对称性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-4-2-%E9%9D%9E%E4%BC%A0%E9%80%92%E6%80%A7"><span class="toc-number">7.4.2.</span> <span class="toc-text">5.4.2  非传递性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-4-3-%E4%B8%8D%E5%8F%AF%E7%BB%A7%E6%89%BF"><span class="toc-number">7.4.3.</span> <span class="toc-text">5.4.3  不可继承</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-4-4-%E5%8F%8B%E5%85%83%E5%A3%B0%E6%98%8E%E4%B8%8D%E8%83%BD%E5%AE%9A%E4%B9%89%E6%96%B0%E7%9A%84class"><span class="toc-number">7.4.4.</span> <span class="toc-text">5.4.4  友元声明不能定义新的class</span></a></li></ol></li></ol></li></ol></div></div></div></div></main><footer id="footer" style="background: ＃0096FF"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2022 By Eren Zhao</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div><script type="text/javascript" id="maid-script" src="https://unpkg.com/mermaid@undefined/dist/mermaid.min.js?v=undefined"></script><script>if (window.mermaid) {
  var options = JSON.parse(document.getElementById('maid-script').getAttribute('mermaidoptioins'));
  mermaid.initialize(options);
}</script></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="chat_btn" type="button" title="rightside.chat_btn"><i class="fas fa-sms"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">本地搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库正在艰难运行</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [ ['$','$'], ["\\(","\\)"]],
      tags: 'ams'
    },
    chtml: {
      scale: 1.2
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, ''],
        insertScript: [200, () => {
          document.querySelectorAll('mjx-container:not\([display]\)').forEach(node => {
            const target = node.parentNode
            if (target.nodeName.toLowerCase() === 'li') {
              target.parentNode.classList.add('has-jax')
            } else {
              target.classList.add('has-jax')
            }
          });
        }, '', false]
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typeset()
}</script><script>(() => {
  const $mermaidWrap = document.querySelectorAll('#article-container .mermaid-wrap')
  if ($mermaidWrap.length) {
    window.runMermaid = () => {
      window.loadMermaid = true
      const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

      Array.from($mermaidWrap).forEach((item, index) => {
        const mermaidSrc = item.firstElementChild
        const mermaidThemeConfig = '%%{init:{ \'theme\':\'' + theme + '\'}}%%\n'
        const mermaidID = 'mermaid-' + index
        const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent
        mermaid.mermaidAPI.render(mermaidID, mermaidDefinition, (svgCode) => {
          mermaidSrc.insertAdjacentHTML('afterend', svgCode)
        })
      })
    }

    const loadMermaid = () => {
      window.loadMermaid ? runMermaid() : getScript('https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js').then(runMermaid)
    }

    window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
  }
})()</script><script>function addGitalkSource () {
  const ele = document.createElement('link')
  ele.rel = 'stylesheet'
  ele.href= 'https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css'
  document.getElementsByTagName('head')[0].appendChild(ele)
}

function loadGitalk () {
  function initGitalk () {
    var gitalk = new Gitalk(Object.assign({
      clientID: '978121c7b834efdd76be',
      clientSecret: '59b40e8f39a1c33db5a2c891771086164b9575c4',
      repo: 'zhaochenyang20.github.io',
      owner: 'zhaochenyang20',
      admin: ['zhaochenyang20'],
      id: '311c58be11d939db7db243e1681691eb',
      updateCountCallback: commentCount
    },null))

    gitalk.render('gitalk-container')
  }

  if (typeof Gitalk === 'function') initGitalk()
  else {
    addGitalkSource()
    getScript('https://cdn.jsdelivr.net/npm/gitalk@latest/dist/gitalk.min.js').then(initGitalk)
  }
}

function commentCount(n){
  let isCommentCount = document.querySelector('#post-meta .gitalk-comment-count')
  if (isCommentCount) {
    isCommentCount.innerHTML= n
  }
}

if ('Gitalk' === 'Gitalk' || !true) {
  if (true) btf.loadComment(document.getElementById('gitalk-container'), loadGitalk)
  else loadGitalk()
} else {
  function loadOtherComment () {
    loadGitalk()
  }
}</script></div><canvas class="fireworks" mobile="true"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/fireworks.min.js"></script><script defer="defer" id="fluttering_ribbon" mobile="true" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-fluttering-ribbon.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = false;
POWERMODE.mobile = true;
document.body.addEventListener('input', POWERMODE);
</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/tororo.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":true},"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/"});</script></body></html>