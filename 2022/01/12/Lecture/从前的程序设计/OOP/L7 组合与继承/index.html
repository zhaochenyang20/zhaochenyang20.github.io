<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>oop笔记  L7  组合与继承 | 你一生的故事</title><meta name="keywords" content="跪系的普通学生"><meta name="author" content="Eren Zhao"><meta name="copyright" content="Eren Zhao"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="重写覆盖与函数重载，人生重开得了...">
<meta property="og:type" content="article">
<meta property="og:title" content="oop笔记  L7  组合与继承">
<meta property="og:url" content="http://example.com/2022/01/12/Lecture/%E4%BB%8E%E5%89%8D%E7%9A%84%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/OOP/L7%20%E7%BB%84%E5%90%88%E4%B8%8E%E7%BB%A7%E6%89%BF/index.html">
<meta property="og:site_name" content="你一生的故事">
<meta property="og:description" content="重写覆盖与函数重载，人生重开得了...">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://raw.githubusercontent.com/zhaochenyang20/ivue_wallpaper/main/ivue_desktop/Photo by Nikita Krassiouk (VQegrm9mbLU).jpg">
<meta property="article:published_time" content="2022-01-12T08:33:22.000Z">
<meta property="article:modified_time" content="2022-01-12T08:44:49.167Z">
<meta property="article:author" content="Eren Zhao">
<meta property="article:tag" content="跪系的普通学生">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://raw.githubusercontent.com/zhaochenyang20/ivue_wallpaper/main/ivue_desktop/Photo by Nikita Krassiouk (VQegrm9mbLU).jpg"><link rel="shortcut icon" href="/img/favicon.ico"><link rel="canonical" href="http://example.com/2022/01/12/Lecture/%E4%BB%8E%E5%89%8D%E7%9A%84%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/OOP/L7%20%E7%BB%84%E5%90%88%E4%B8%8E%E7%BB%A7%E6%89%BF/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"麻了，找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: Eren Zhao","link":"链接: ","source":"来源: 你一生的故事","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: true,
  islazyload: true,
  isAnchor: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'oop笔记  L7  组合与继承',
  isPost: true,
  isHome: false,
  isHighlightShrink: true,
  isToc: true,
  postUpdate: '2022-01-12 16:44:49'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          const now = new Date()
          const hour = now.getHours()
          const isNight = hour <= 6 || hour >= 18
          if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
          else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.0.0"><style>.darkmode--activated{--body-bg-color:#282828;--content-bg-color:#333;--card-bg-color:#555;--text-color:#ccc;--blockquote-color:#bbb;--link-color:#ccc;--link-hover-color:#eee;--brand-color:#ddd;--brand-hover-color:#ddd;--table-row-odd-bg-color:#282828;--table-row-hover-bg-color:#363636;--menu-item-bg-color:#555;--btn-default-bg:#222;--btn-default-color:#ccc;--btn-default-border-color:#555;--btn-default-hover-bg:#666;--btn-default-hover-color:#ccc;--btn-default-hover-border-color:#666;--highlight-background:#282b2e;--highlight-foreground:#a9b7c6;--highlight-gutter-background:#34393d;--highlight-gutter-foreground:#9ca9b6}.darkmode--activated img{opacity:.75}.darkmode--activated img:hover{opacity:.9}.darkmode--activated code{color:#69dbdc;background:0 0}button.darkmode-toggle{z-index:9999}.darkmode-ignore,img{display:flex!important}</style></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/avatar.jpeg" onerror="onerror=null;src='/img/friend.jpg'" alt="avatar"/></div><div class="site-data is-center"><div class="data-item"><a href="/archives/"><div class="headline">文章</div><div class="length-num">189</div></a></div><div class="data-item"><a href="/tags/"><div class="headline">标签</div><div class="length-num">53</div></a></div><div class="data-item"><a href="/categories/"><div class="headline">分类</div><div class="length-num">13</div></a></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://raw.githubusercontent.com/zhaochenyang20/ivue_wallpaper/main/ivue_desktop/Photo by Nikita Krassiouk (VQegrm9mbLU).jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">你一生的故事</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">oop笔记  L7  组合与继承</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-01-12T08:33:22.000Z" title="发表于 2022-01-12 16:33:22">2022-01-12</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-01-12T08:44:49.167Z" title="更新于 2022-01-12 16:44:49">2022-01-12</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/oop/">oop</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">9k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>37分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="oop笔记  L7  组合与继承"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="l7-组合与继承">L7 组合与继承</h1>
<blockquote>
<p>如果阅读时间不够充足，建议阅读课堂的扩展部分。</p>
<ul>
<li>1.1.3 public接口访问private数据</li>
<li>3.3 重写覆盖的总结</li>
</ul>
</blockquote>
<h1 id="一组合">一、组合</h1>
<h2 id="定义">1.1 定义</h2>
<p>如果对象a是对象b的一个组成部分，则称b为a的整体对象，a为b的部分对象。并把b和a之间的关系，称为“整体－部分”关系（也可称为“组合”或“has-a”关系）。</p>
<h2 id="两种实现方式">1.2 两种实现方式</h2>
<h3 id="公有成员">1.2.1 公有成员</h3>
<p>已有类的对象作为新类的公有数据成员，这样通过允许直接访问子对象而“提供”旧类接口。</p>
<h3 id="私有成员">1.2.2 私有成员</h3>
<p>已有类的对象作为新类的私有数据成员。新类可以调整旧类的对外接口，可以不使用旧类原有的接口（相当于对接口作了转换）</p>
<p>我们有如下命名两类组合方式：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  Wheel w;<span class="comment">//private组合</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  Engine e; <span class="comment">//public组合</span></span><br></pre></td></tr></table></figure>
<h3 id="public接口访问private数据">1.2.3 public接口访问private数据</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Wheel</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> _num;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;_num=n;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Engine</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">int</span> _num;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;_num=n;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  Wheel w;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  Engine e; <span class="comment">/// 公有成员，直接访问其接口</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">setWheel</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;w.<span class="built_in">set</span>(n);&#125; <span class="comment">/// 提供私有成员的访问接口</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  Car c;</span><br><span class="line">  c.e.<span class="built_in">set</span>(<span class="number">1</span>);</span><br><span class="line">  c.<span class="built_in">setWheel</span>(<span class="number">4</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Car由Engine和Wheel两部分组成。如果我的Wheel设为私有，那么我没法直接在类外（主函数里）访问w.set(n)，因为类外无法访问私有成员。私有成员的所有接口会在类外整体私有化，但是私有成员的public接口仍然可以被类内函数调用。可以设置public接口setwheel，setweel是个public的类内函数，可以访问类内private成员，从而我能够通过此接口访问到private数据成员wheel w的public接口，但是也无法直接访问private部分的private数据。同理，观察wheel类和Engine类的写法，其实也是这种给private对象添加public接口的思想。</p>
<p>将此例子进一步阐述：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Wheel</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> _num;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Wheel</span>(<span class="keyword">int</span> x)&#123;_num=x;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;_num=n;&#125;<span class="comment">//没有get函数是没法直接在Car类里访问到private成员的private的</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getwheelvalue</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> <span class="keyword">this</span>-&gt;_num;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Engine</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Engine</span>(<span class="keyword">int</span> y)&#123;_num=y;&#125;</span><br><span class="line">    <span class="keyword">int</span> _num;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;_num=n;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  Wheel w;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  Engine e; <span class="comment">/// 公有成员，直接访问其接口</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">setWheel</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;w.<span class="built_in">set</span>(n);&#125; <span class="comment">/// 提供私有成员的访问接口</span></span><br><span class="line">  <span class="built_in">Car</span>(<span class="keyword">int</span> x,<span class="keyword">int</span> y):<span class="built_in">w</span>(x),<span class="built_in">e</span>(y)&#123;&#125;;</span><br><span class="line">  <span class="comment">//Car(int x):Egine(x),Wheel(x)&#123;&#125;;</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;cout&lt;&lt;<span class="string">&quot;my Engine is &quot;</span>&lt;&lt;<span class="keyword">this</span>-&gt;e._num&lt;&lt;<span class="string">&quot; my Wheel is &quot;</span>&lt;&lt;<span class="keyword">this</span>-&gt;w.<span class="built_in">getwheelvalue</span>()&lt;&lt;endl;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="function">Car <span class="title">c</span><span class="params">(<span class="number">5</span>,<span class="number">3</span>)</span></span>;</span><br><span class="line">  c.<span class="built_in">print</span>();</span><br><span class="line">  c.e.<span class="built_in">set</span>(<span class="number">1</span>);</span><br><span class="line">    c.<span class="built_in">print</span>();</span><br><span class="line">  c.<span class="built_in">setWheel</span>(<span class="number">4</span>);</span><br><span class="line">    c.<span class="built_in">print</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">Output:</span><br><span class="line">my Engine is <span class="number">3</span> my Wheel is <span class="number">5</span></span><br><span class="line">my Engine is <span class="number">1</span> my Wheel is <span class="number">5</span></span><br><span class="line">my Engine is <span class="number">1</span> my Wheel is <span class="number">4</span></span><br></pre></td></tr></table></figure>
<p>第一，Wheel w是Car的私有成员，Car的public接口可以访问Car的private数据成员，故而可以访问w，但是无法访问私有数据成员的私有数据成员，故而无法直接在print中输出w._num，我们选择了再对Wheel设计私有数据成员的接口getwheelvalue来访问wheel的_num。</p>
<p>第二，对于Car的构造函数的初始化列表，当Car的数据成员是int x时，我们写的是x(i)，而不是int(i)。（否则，如果有多个int类的成员，初始化就无法进行了）所以这里写的也是w(x)，而不是Wheel(x)。这里其实也体现了基本数据和自定义类的类比关系。</p>
<p>第三，我们这里采用了初始化列表来构造Car，而不是采用函数体内赋值。因为C++11直接禁止了这类的函数体内赋值。</p>
<p>我们对此的理解：如果是函数体内赋值来构造Car，那么需要定义Wheel和Engine的默认构造函数（如果我们不定义带有参数的构造函数，系统会自动生成）除此之外，类似w=5这样的语句还需要隐式调用带有参数的构造函数生成Wheel（5）,然后调用隐式生成的移动赋值语句给w赋值。这个方式比起初始化列表效率低下太多。（如此禁止可能还有其他的因果关系）</p>
<p>这其实就是1.3.1的第一句话的理解。</p>
<h2 id="构造与析构">1.3 构造与析构</h2>
<h3 id="子对象参数构造">1.3.1 子对象参数构造</h3>
<p>子对象构造时若需要参数，则应在当前类的构造函数的初始化列表中进行。不能够通过先默认构造。然后再在函数体内赋值。</p>
<p>具体而言，C++11的规定是其他类的子对象必须要通过初始化列表来构造，如果不写在初始化列表里，那么就调用默认构造。</p>
<p>如果A类内组合有其他类B的对象，那么B的对象必须要通过初始化列表来构造，可以不写初始化列表，那么会调用B的默认构造函数。但是一定不能在A的构造函数体内进行构造，效率太低。</p>
<p>这个地方感觉会和我们的理解发生冲突，因为类当中经常会需要int数据成员。int是一个类，那难道int只能在初始化列表里赋值吗？</p>
<p>这个理解是错的。int不能算是一个类，它和char,long,double都只是基本的变量类型。组合指的是类和类之间，数据成员里的int，这不是组合。基本数据类型和自己写的类不是一个东西。而且对于短赋值语句，尽量能放初始化列表就不放函数体内，前者效率更高。</p>
<p>但是Vector是个封装好了的类，<code>#include &lt;vector&gt; using std::vector</code>就是把包含它的库搞到你的程序中。</p>
<h3 id="子对象默认构造">1.3.2 子对象默认构造</h3>
<p>若使用默认构造函数来构造子对象，则不用做任何处理。</p>
<h3 id="构造次序">1.3.3 构造次序</h3>
<p>先完成子对象构造，再完成父对象构造。</p>
<h3 id="析构次序">1.3.4 析构次序</h3>
<p>子对象构造的次序仅由在类中声明的次序所决定。</p>
<p>析构函数的次序与构造函数相反，也就是完全反着析构一次即可。</p>
<h3 id="例子">1.3.5 例子</h3>
<p>例1：构造与析构的执行顺序</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">S1</span> &#123;</span> <span class="comment">//Single1类别</span></span><br><span class="line">  <span class="keyword">int</span> ID;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">S1</span>(<span class="keyword">int</span> id) : <span class="built_in">ID</span>(id) &#123; cout &lt;&lt; <span class="string">&quot;S1(int)&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">  ~<span class="built_in">S1</span>() &#123; cout &lt;&lt; <span class="string">&quot;~S1()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">S2</span> &#123;</span><span class="comment">//Single2类别</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">S2</span>() &#123; cout &lt;&lt; <span class="string">&quot;S2()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">  ~<span class="built_in">S2</span>() &#123; cout &lt;&lt; <span class="string">&quot;~S2()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C3</span> &#123;</span><span class="comment">//Composite3类别</span></span><br><span class="line">  <span class="keyword">int</span> num;</span><br><span class="line">  S1 sub_obj1; <span class="comment">/// 构造函数带参数</span></span><br><span class="line">  S2 sub_obj2; <span class="comment">/// 构造函数不带参数</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">C3</span>() : <span class="built_in">num</span>(<span class="number">0</span>), <span class="built_in">sub_obj1</span>(<span class="number">123</span>) <span class="comment">/// 构造函数初始化列表中构造子对象</span></span><br><span class="line">        &#123; cout &lt;&lt; <span class="string">&quot;C3()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">  <span class="built_in">C3</span>(<span class="keyword">int</span> n) : <span class="built_in">num</span>(n), <span class="built_in">sub_obj1</span>(<span class="number">123</span>) </span><br><span class="line">        &#123; cout &lt;&lt; <span class="string">&quot;C3(int)&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">  <span class="built_in">C3</span>(<span class="keyword">int</span> n, <span class="keyword">int</span> k) : <span class="built_in">num</span>(n), <span class="built_in">sub_obj1</span>(k) </span><br><span class="line">        &#123; cout &lt;&lt; <span class="string">&quot;C3(int, int)&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">  ~<span class="built_in">C3</span>() &#123; cout &lt;&lt; <span class="string">&quot;~C3()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  C3 a, <span class="built_in">b</span>(<span class="number">1</span>), <span class="built_in">c</span>(<span class="number">2</span>), <span class="built_in">d</span>(<span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">S1</span>(<span class="keyword">int</span>)</span><br><span class="line"><span class="built_in">S2</span>()</span><br><span class="line"><span class="built_in">C3</span>()</span><br><span class="line"><span class="built_in">S1</span>(<span class="keyword">int</span>)</span><br><span class="line"><span class="built_in">S2</span>()</span><br><span class="line"><span class="built_in">C3</span>(<span class="keyword">int</span>)</span><br><span class="line"><span class="built_in">S1</span>(<span class="keyword">int</span>)</span><br><span class="line"><span class="built_in">S2</span>()</span><br><span class="line"><span class="built_in">C3</span>(<span class="keyword">int</span>)</span><br><span class="line"><span class="built_in">S1</span>(<span class="keyword">int</span>)</span><br><span class="line"><span class="built_in">S2</span>()</span><br><span class="line"><span class="built_in">C3</span>(<span class="keyword">int</span>, <span class="keyword">int</span>)</span><br><span class="line">~<span class="built_in">C3</span>()</span><br><span class="line">~<span class="built_in">S2</span>()</span><br><span class="line">~<span class="built_in">S1</span>()</span><br><span class="line">~<span class="built_in">C3</span>()</span><br><span class="line">~<span class="built_in">S2</span>()</span><br><span class="line">~<span class="built_in">S1</span>()</span><br><span class="line">~<span class="built_in">C3</span>()</span><br><span class="line">~<span class="built_in">S2</span>()</span><br><span class="line">~<span class="built_in">S1</span>()</span><br><span class="line">~<span class="built_in">C3</span>()</span><br><span class="line">~<span class="built_in">S2</span>()</span><br><span class="line">~<span class="built_in">S1</span>()</span><br></pre></td></tr></table></figure>
<p>输出结果，前面12行，每三行为一个单位，是一个构造。且先按照声明次序构造子对象sub_obj1，之后是sub_obj2，最后完成C3构造。</p>
<p>至于析构顺序，那就纯粹是把前12行向下对折。</p>
<p>例2：对象组合的拷贝与赋值（对课件上的例子进行优化，更清楚些）</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C1</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="built_in">C1</span>(<span class="keyword">int</span> n):<span class="built_in">i</span>(n)&#123;cout&lt;&lt;<span class="string">&quot;C1 with int: &quot;</span>&lt;&lt;n&lt;&lt;endl;&#125;</span><br><span class="line">    <span class="built_in">C1</span>(<span class="keyword">const</span> C1 &amp;other) <span class="comment">/// 显式定义拷贝构造函数</span></span><br><span class="line">        &#123;i=other.i; cout &lt;&lt; <span class="string">&quot;C1(const C1 &amp;other)&quot;</span> &lt;&lt; endl;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C2</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line">    <span class="built_in">C2</span>(<span class="keyword">int</span> n):<span class="built_in">j</span>(n)&#123;cout&lt;&lt;<span class="string">&quot;C2 with int: &quot;</span>&lt;&lt;n&lt;&lt;endl;&#125;</span><br><span class="line">    C2&amp; <span class="keyword">operator</span>= (<span class="keyword">const</span> C2&amp; right)&#123;<span class="comment">/// 显式定义赋值运算符</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span> != &amp;right)&#123;</span><br><span class="line">            j = right.j;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;operator=(const C2&amp;)&quot;</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C3</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    C1 c1;</span><br><span class="line">    C2 c2;</span><br><span class="line">    <span class="built_in">C3</span>():<span class="built_in">c1</span>(<span class="number">0</span>), <span class="built_in">c2</span>(<span class="number">0</span>)&#123;cout&lt;&lt;<span class="string">&quot;C3 without arg&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line">    <span class="built_in">C3</span>(<span class="keyword">int</span> i, <span class="keyword">int</span> j):<span class="built_in">c1</span>(i), <span class="built_in">c2</span>(j)&#123;cout&lt;&lt;<span class="string">&quot;C3 with i and j&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;cout &lt;&lt; <span class="string">&quot;c1.i = &quot;</span> &lt;&lt; c1.i &lt;&lt; <span class="string">&quot; c2.j = &quot;</span> &lt;&lt; c2.j &lt;&lt; endl;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">C3 <span class="title">a</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>)</span></span>;</span><br><span class="line">    <span class="function">C3 <span class="title">b</span><span class="params">(a)</span></span>;  <span class="comment">//C1执行显式定义的拷贝构造，C2执行隐式定义的拷贝构造</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;b: &quot;</span>;</span><br><span class="line">    b.<span class="built_in">print</span>();</span><br><span class="line">    C3 c;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;c: &quot;</span>;</span><br><span class="line">    c.<span class="built_in">print</span>();</span><br><span class="line">    c = a;  <span class="comment">//C1执行隐式定义的拷贝赋值，C2执行显式定义的拷贝赋值</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;c: &quot;</span>;</span><br><span class="line">    c.<span class="built_in">print</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">Output：</span><br><span class="line">C1 with <span class="keyword">int</span>: <span class="number">1</span></span><br><span class="line">C2 with <span class="keyword">int</span>: <span class="number">2</span></span><br><span class="line"><span class="function">C3 with i <span class="keyword">and</span> j</span></span><br><span class="line"><span class="function"><span class="title">C1</span><span class="params">(<span class="keyword">const</span> C1 &amp;other)</span></span></span><br><span class="line"><span class="function">b: c1.i =</span> <span class="number">1</span> c2.j = <span class="number">2</span></span><br><span class="line">C1 with <span class="keyword">int</span>: <span class="number">0</span></span><br><span class="line">C2 with <span class="keyword">int</span>: <span class="number">0</span></span><br><span class="line">C3 without arg</span><br><span class="line">c: c1.i = <span class="number">0</span> c2.j = <span class="number">0</span></span><br><span class="line"><span class="keyword">operator</span>=(<span class="keyword">const</span> C2&amp;)</span><br><span class="line">c: c1.i = <span class="number">1</span> c2.j = <span class="number">2</span></span><br></pre></td></tr></table></figure>
<p>例3：区分数据来源</p>
<p>错误的是：</p>
<figure>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2022/01/11/JLqScl8DQyCdGO3.png" alt="https://s2.loli.net/2022/01/11/JLqScl8DQyCdGO3.png" /><figcaption aria-hidden="true">https://s2.loli.net/2022/01/11/JLqScl8DQyCdGO3.png</figcaption>
</figure>
<p>注意，int data{2018};和int data=2018;这两个写法一致。这里B类的print函数输出的是B的data，而不是数据成员a的data。但是构造函数B(int i)a(i)是用2019在构造a，这一个小细节比较坑。</p>
<h1 id="二继承">二、继承</h1>
<h2 id="定义-1">2.1 定义</h2>
<p>一般－特殊”结构，也称“分类结构”，是由一组具有“一般－特殊”关系的类所组成的结构，C++使用继承来表达类间的“一般－特殊结构”。</p>
<p>A继承B，则： 属性和服务上：类A具有类B全部的属性和服务，而且具有自己特有的某些属性或服务。A为B的特殊类，B为A的一般类。</p>
<p>对象关系上：类A的全部对象都是类B的对象，而且类B中存在不属于类A的对象。A是B的特殊类，B是A的一般类。</p>
<h2 id="继承方式与语法">2.2 继承方式与语法</h2>
<p>被继承的已有类，被称为基类(base class)，也称“父类”、“一般类”。 通过继承得到的新类，被为派生类(derived class，也称“子类”、“扩展类”、“特殊类”。</p>
<p>常见的继承方式：public, private</p>
<p><code>class Derived : [private] Base &#123; .. &#125;;</code> 缺省继承方式为private继承。</p>
<p><code>class Derived : public Base &#123; ... &#125;;</code></p>
<p>protected 继承很少被使用</p>
<p><code>class Derived : protected Base &#123; ... &#125;;</code></p>
<p>注意，protect数据经过继承可以给子类访问，但是private数据经过继承不能给子类访问，且二者都不能类外访问。这里描述的是protect数据类型，而不是protect继承，protect继承很少用到。</p>
<h2 id="无法继承">2.3 无法继承</h2>
<p>构造函数：创建派生类对象时，必须调用派生类的构造函数。派生类构造函数调用基类的构造函数，以创建派生对象的基类部分。C++11新增了继承构造函数的机制（使用using），但默认不继承。</p>
<p>析构函数：释放对象时，先调用派生类析构函数，再调用基类析构函数。这个和组合相似。</p>
<p>赋值运算符：编译器不会继承基类的赋值运算符（参数为基类）。但会自动合成隐式定义的派生类的赋值运算符（参数为派生类），其功能为调用基类的赋值运算符。</p>
<p>友元函数：不是类成员，故而无法继承</p>
<p>例子：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;cout &lt;&lt; <span class="string">&quot;Base::f()&quot;</span> &lt;&lt; endl;&#125;</span><br><span class="line">    Base &amp; <span class="keyword">operator</span>= (<span class="keyword">const</span> Base &amp;right)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span> != &amp;right)&#123;</span><br><span class="line">            k = right.k;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;operator= (const Base &amp;right)&quot;</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derive</span>:</span> <span class="keyword">public</span> Base&#123;&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Derive d, d2;</span><br><span class="line">    cout &lt;&lt; d.k &lt;&lt; endl; <span class="comment">//Base数据成员被继承</span></span><br><span class="line">    d.<span class="built_in">f</span>(); <span class="comment">//Base::f()被继承</span></span><br><span class="line">    </span><br><span class="line">    Base e;</span><br><span class="line">    <span class="comment">//d = e; //编译错误，Base的赋值运算符不被继承</span></span><br><span class="line">    d = d2;  <span class="comment">//调用隐式定义的赋值运算符，派生类隐式合成的赋值运算符会调用基类的赋值运算符</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">Output：</span><br><span class="line"><span class="number">0</span></span><br><span class="line">Base::<span class="built_in">f</span>()</span><br><span class="line"><span class="keyword">operator</span>= (<span class="keyword">const</span> Base &amp;right)</span><br></pre></td></tr></table></figure>
<p>注意前文提及派生类会自动生成赋值运算符，参数为派生类。也就是仅仅在派生类对象间赋值，基类和派生类相互赋值在不定义类型转换的情况下是不允许的。</p>
<h2 id="构造与析构-1">2.4 构造与析构</h2>
<p>继承与组合在构造以及析构上的执行顺序类似。</p>
<p>基类中的数据成员，通过继承成为派生类对象的一部分，需要在构造派生类对象的过程中调用基类构造函数来正确初始化。</p>
<p>若没有显式调用，则编译器会自动调用基类的默认构造函数。</p>
<p>若想要显式调用，则只能在派生类构造函数的初始化成员列表中进行，既可以调用基类中不带参数的默认构造函数，也可以调用合适的带参数的其他构造函数。先执行基类的构造函数来初始化继承来的数据，再执行派生类的构造函数。</p>
<p>对象析构时，先执行派生类析构函数，再执行由编译器自动调用的基类的析构函数。</p>
<p>例1：隐式调用默认构造函数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Base</span>() : <span class="built_in">data</span>(<span class="number">0</span>) &#123; cout &lt;&lt; <span class="string">&quot;Base::Base(&quot;</span> &lt;&lt; data &lt;&lt; <span class="string">&quot;)\n&quot;</span>; &#125;</span><br><span class="line">            <span class="comment">/// 默认构造函数</span></span><br><span class="line">    <span class="built_in">Base</span>(<span class="keyword">int</span> i) : <span class="built_in">data</span>(i) &#123; cout &lt;&lt; <span class="string">&quot;Base::Base(&quot;</span> &lt;&lt; data &lt;&lt; <span class="string">&quot;)\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derive</span> :</span> <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Derive</span>() &#123; cout &lt;&lt; <span class="string">&quot;Derive::Derive()&quot;</span> &lt;&lt; endl; &#125; </span><br><span class="line">    <span class="comment">/// 无显式调用基类构造函数，则调用基类默认构造函数</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Derive obj; </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; <span class="comment">// g++ 1.cpp –o 1.out -std=c++11</span></span><br><span class="line">Output：</span><br><span class="line">Base::<span class="built_in">Base</span>(<span class="number">0</span>)</span><br><span class="line">Derive::<span class="built_in">Derive</span>()</span><br></pre></td></tr></table></figure>
<p>先完成了基类部分的构造，再完成了派生类部分的构造。</p>
<p>例2：显式调用了基类带参数的构造函数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Base</span>() : <span class="built_in">data</span>(<span class="number">0</span>) &#123; cout &lt;&lt; <span class="string">&quot;Base::Base(&quot;</span> &lt;&lt; data &lt;&lt; <span class="string">&quot;)\n&quot;</span>; &#125;</span><br><span class="line">            <span class="comment">/// 默认构造函数</span></span><br><span class="line">    <span class="built_in">Base</span>(<span class="keyword">int</span> i) : <span class="built_in">data</span>(i) &#123; cout &lt;&lt; <span class="string">&quot;Base::Base(&quot;</span> &lt;&lt; data &lt;&lt; <span class="string">&quot;)\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derive</span> :</span> <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Derive</span>(<span class="keyword">int</span> i) : <span class="built_in">Base</span>(i) &#123; cout &lt;&lt; “Derive::<span class="built_in">Derive</span>()” &lt;&lt; endl; &#125; </span><br><span class="line">    <span class="comment">/// 显式调用基类构造函数</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Derive <span class="title">obj</span><span class="params">(<span class="number">356</span>)</span></span>;    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; <span class="comment">// g++ 1.cpp –o 1.out -std=c++11</span></span><br></pre></td></tr></table></figure>
<p>显式调用了基类的带参数的构造函数只能在初始化列表中进行。</p>
<p>例4：启用using关键字</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Base</span>(<span class="keyword">int</span> i) : <span class="built_in">data</span>(i) &#123; cout &lt;&lt; <span class="string">&quot;Base::Base(&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;)\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derive</span> :</span> <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> Base::Base;       <span class="comment">///相当于 Derive(int i):Base(i)&#123;&#125;;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Derive <span class="title">obj</span><span class="params">(<span class="number">356</span>)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; <span class="comment">// g++ 1.cpp –o 1.out -std=c++11</span></span><br><span class="line">Output:</span><br><span class="line">Base::<span class="built_in">Base</span>(<span class="number">356</span>)</span><br></pre></td></tr></table></figure>
<p>在派生类中使用 <code>using Base::Base;</code> 来继承基类构造函数，相当于给派生类“定义”了相应参数的构造函数。如果基类里有多个不同参数的构造函数，using语句会分别构造对应的不同参数的构造函数。</p>
<p>例5：using一并启用</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Base</span>(<span class="keyword">int</span> i) : <span class="built_in">data</span>(i) &#123; cout &lt;&lt; <span class="string">&quot;Base::Base(&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;)\n&quot;</span>; &#125;</span><br><span class="line">    <span class="built_in">Base</span>(<span class="keyword">int</span> i, <span class="keyword">int</span> j) </span><br><span class="line">        &#123; cout &lt;&lt; <span class="string">&quot;Base::Base(&quot;</span> &lt;&lt; i &lt;&lt; “,<span class="string">&quot; &lt;&lt; j &lt;&lt; &quot;</span>)\n<span class="string">&quot;;&#125;</span></span><br><span class="line"><span class="string">&#125;;</span></span><br><span class="line"><span class="string">class Derive : public Base &#123;</span></span><br><span class="line"><span class="string">public:</span></span><br><span class="line"><span class="string">    using Base::Base;       ///相当于 Derive(int i):Base(i)&#123;&#125;;</span></span><br><span class="line"><span class="string">                     ///加上 Derive(int i, int j):Base(i，j)&#123;&#125;;</span></span><br><span class="line"><span class="string">&#125;;</span></span><br><span class="line"><span class="string">int main() &#123;</span></span><br><span class="line"><span class="string">    Derive obj1(356);</span></span><br><span class="line"><span class="string">    Derive obj2(356, 789);</span></span><br><span class="line"><span class="string">    return 0;</span></span><br><span class="line"><span class="string">&#125; // g++ 1.cpp –o 1.out -std=c++11</span></span><br><span class="line"><span class="string">Output：</span></span><br><span class="line"><span class="string">Base::Base(356)</span></span><br><span class="line"><span class="string">Base::Base(356,789)</span></span><br></pre></td></tr></table></figure>
<p>当基类存在多个构造函数时，使用using会给派生类自动构造多个相应的构造函数。注意这里是指一个基类有多个构造函数，而不是多重继承。</p>
<p>如果基类的某个构造函数被声明为私有成员函数，则不能在派生类中声明继承该构造函数。（在L4·创建与销毁·一的1.2.3节有叙述过结合委派构造函数将构造函数设置为私有成员函数的例子）</p>
<p>如果派生类使用了继承构造函数，编译器就不会再为派生类生成隐式定义的默认构造函数。</p>
<p>例6：通过using Base::Base来继承构造函数有限制，可能需要派生类在基类基础之外没有没有新的数据成员，但是派生类可以有新的方法：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Base</span>(<span class="keyword">int</span> i) : <span class="built_in">data</span>(i) &#123; cout &lt;&lt; <span class="string">&quot;Base::Base(&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;)\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derive</span> :</span> <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="comment">//int a=100；就地初始化</span></span><br><span class="line">    <span class="keyword">using</span> Base::Base;       <span class="comment">///相当于 Derive(int i):Base(i)&#123;&#125;;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Derive <span class="title">obj</span><span class="params">(<span class="number">356</span>)</span></span>;</span><br><span class="line">    cout&lt;&lt;obj.a&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; <span class="comment">// g++ 1.cpp –o 1.out -std=c++11</span></span><br></pre></td></tr></table></figure>
<p>当a不就地初始化时，通过using Base::Base;来的构造函数会使得a的值完全不确定，而就地初始化化后可以确定。</p>
<h2 id="两类继承方式的选择">2.5 两类继承方式的选择</h2>
<h3 id="public继承">2.5.1 public继承</h3>
<p>基类中公有成员仍能在派生类中保持公有。原接口可沿用，最常用。 is-a：基类对象能使用的地方，派生类对象也能使用。</p>
<h3 id="private继承">2.5.2 private继承</h3>
<p>is-implementing-in-terms-of(照此实现)：用基类接口实现派生类功能。移除了 is-a 关系。</p>
<p>通常不使用，用private组合替代。可用于隐藏/公开基类的部分接口。公开方法：using 关键字。</p>
<h2 id="成员访问权限">2.6 成员访问权限</h2>
<p>基类中的私有成员，不允许在派生类成员函数中访问，也不允许派生类的对象访问它们，仅允许基类的公开接口访问他们，但是基类的公开接口在不同的继承当中访问权限不同。（组合当中也是如此）</p>
<p>那么如何访问基类中的私有成员？</p>
<figure>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2022/01/11/n9mCbMNykwcExtz.png" alt="https://s2.loli.net/2022/01/11/n9mCbMNykwcExtz.png" /><figcaption aria-hidden="true">https://s2.loli.net/2022/01/11/n9mCbMNykwcExtz.png</figcaption>
</figure>
<p>情况一，public继承。派生类对象和派生类成员函数可以访问基类的公开接口从而访问基类私有成员。</p>
<figure>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2022/01/11/t7QaHINzCE6Vkl5.png" alt="https://s2.loli.net/2022/01/11/t7QaHINzCE6Vkl5.png" /><figcaption aria-hidden="true">https://s2.loli.net/2022/01/11/t7QaHINzCE6Vkl5.png</figcaption>
</figure>
<p>情况二，private继承。和private组合同理，在类外既无法直接访问基类的private成员，也无法访问基类的public成员。（因为继承之后被私有化了）</p>
<p>任何继承当中，基类的private成员都无法被派生类的共有接口访问，仅仅可以被基类的共有部分访问。private继承中，基类的public接口不能派生类对象直接访问，但是可以被派生类对象的的共有接口可以访问。</p>
<p>故而我们先设置基类的公有接口访问基类的私有成员，接着设计派生类的公有接口访问基类的公有接口，从而间接实现了访问基类的私有成员。</p>
<p>访问基类私有部分只能通过基类的public接口实现。private继承时，基类public接口仅可派生类成员函数访问，从而访问基类私有部分需要两次间接访问。而public继承时，基类public接口对派生类函数和类外函数都是开放的。可以派生类对象直接访问基类public接口，也可以派生类对象的成员函数访问基类public接口。</p>
<ul>
<li>基类中的公有成员</li>
</ul>
<p>允许在派生类成员函数中被访问。</p>
<p>若是使用public继承方式，则成为派生类公有成员，可以被派生类的对象访问，也可以被派生类成员函数访问。</p>
<p>若是使用private/protected继承方式，则成为派生类私有/保护成员，不能在类外直接访问。若想让某public成员数据在private/protected继承后能被派生类的对象访问，可在派生类public部分用关键字using声明它的名字。（.h文件里）或者按照上文设计派生类的共有接口访问基类的public成员，但是也无法直接访问派生类对象的基类的public成员。</p>
<p>所谓不能派生类的对象访问：这里是指直接在类外通过obj.data的方式访问，而不是说不可以通过派生类的成员函数来访问。</p>
<ul>
<li>基类中的保护成员</li>
</ul>
<p>保护成员允许在派生类成员函数中被访问，但不能被外部函数访问，也不允许对象直接访问。</p>
<p>例1：public直接继承基类共有接口</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">baseFunc</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;in Base::baseFunc()...&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derive1</span>:</span> <span class="keyword">public</span> Base &#123;&#125;; <span class="comment">// D1类的继承方式是public继承</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Derive1 obj1; </span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;calling obj1.baseFunc()...&quot;</span> &lt;&lt; endl;</span><br><span class="line">  obj1.<span class="built_in">baseFunc</span>(); <span class="comment">// 基类接口成为派生类接口的一部分，派生类对象可调用</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">Output：</span><br><span class="line">calling obj1.<span class="built_in">baseFunc</span>()...</span><br><span class="line"><span class="function">in <span class="title">Base::baseFunc</span><span class="params">()</span>...</span></span><br></pre></td></tr></table></figure>
<p>例2：private间接访问基类共有接口</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">baseFunc</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;in Base::baseFunc()...&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derive2</span>:</span> <span class="keyword">private</span> Base </span><br><span class="line">&#123;<span class="comment">/// 私有继承， is-implementing-in-terms-of：用基类接口实现派生类功能</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">deriveFunc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; “<span class="function">in <span class="title">Derive2::deriveFunc</span><span class="params">()</span>, </span></span><br><span class="line"><span class="function">                  calling <span class="title">Base::baseFunc</span><span class="params">()</span>...&quot; &lt;&lt; endl</span>;</span><br><span class="line">    <span class="built_in">baseFunc</span>(); <span class="comment">/// 私有继承时，基类接口在派生类成员函数中可以使用</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Derive2 obj2; </span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;calling obj2.deriveFunc()...&quot;</span> &lt;&lt; endl;</span><br><span class="line">  obj2.<span class="built_in">deriveFunc</span>(); </span><br><span class="line">  <span class="comment">//obj2.baseFunc(); ERROR: 不允许在类外直接访问基类接口</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>例3：private继承结合using启用基类共有接口</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">baseFunc</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;in Base::baseFunc()...&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derive3</span>:</span> <span class="keyword">private</span> Base &#123;<span class="comment">// B的私有继承</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">/// 私有继承时，在派生类public部分声明基类成员名字</span></span><br><span class="line">  <span class="keyword">using</span> Base::baseFunc; </span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Derive3 obj3;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;calling obj3.baseFunc()...&quot;</span> &lt;&lt; endl;</span><br><span class="line">  obj3.<span class="built_in">baseFunc</span>(); <span class="comment">//基类接口在派生类public部分声明，则派生类对象可调用</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>例4：保护成员的访问</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">int</span> a&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">  <span class="keyword">int</span> b&#123;<span class="number">0</span>&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derive</span> :</span> <span class="keyword">private</span> Base&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">getA</span><span class="params">()</span></span>&#123;cout&lt;&lt;a&lt;&lt;endl;&#125; <span class="comment">///编译错误，不可访问基类中私有成员</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">getB</span><span class="params">()</span></span>&#123;cout&lt;&lt;b&lt;&lt;endl;&#125; <span class="comment">///可以访问基类中保护成员</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  Derive d;</span><br><span class="line">  d.<span class="built_in">getB</span>();</span><br><span class="line">  <span class="comment">//cout&lt;&lt;d.b; ///编译错误，派生类对象不可访问基类中保护成员</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>小结：</p>
<ul>
<li>public继承</li>
</ul>
<p>基类的公有成员，保护成员，私有成员作为派生类的成员时，都保持原有的状态。</p>
<ul>
<li>private继承</li>
</ul>
<p>基类的公有成员，保护成员，私有成员作为派生类的成员时，都作为私有成员。</p>
<ul>
<li>protected继承</li>
</ul>
<p>基类的公有成员，保护成员作为派生类的成员时，都成为保护成员，基类的私有成员仍然是私有的。</p>
<figure>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2022/01/11/DgsWhda1cTPLMYX.png" alt="https://s2.loli.net/2022/01/11/DgsWhda1cTPLMYX.png" /><figcaption aria-hidden="true">https://s2.loli.net/2022/01/11/DgsWhda1cTPLMYX.png</figcaption>
</figure>
<h3 id="总结">总结：</h3>
<ul>
<li>先理清楚基类的public的访问权限：</li>
</ul>
<p>基类的public在private继承中成为private，仅允许派生类的成员函数访问，不允许派生类对象直接访问。 基类的public在protect继承中成为protect，仅允许派生类的成员函数访问，不允许派生类对象直接访问。 基类的public在public继承中还是public，可以在派生类成员函数中访问，也可以派生类对象直接访问。</p>
<ul>
<li>之后是基类的private的访问权限：</li>
</ul>
<p>基类的private，在三种继承方式中均是private，只能通过基类的public函数访问，不可以派生类对象直接访问。基类的public函数在三种继承方式中访问权限不同。public继承，则基类的public函数可以类外直接访问。Protect和private继承，基类的public函数只允许派生类函数访问。</p>
<ul>
<li>最后是基类的protect的访问权限：</li>
</ul>
<p>基类的protect很简单，三种继承都是必然允许派生类的成员函数访问，不允许对象直接访问。基类的protect在public与protect继承中还是protect，但在private继承后虽然是private属性，但也允许基类的public函数与派生类的public函数访问，不能对象直接访问。</p>
<ul>
<li>单独讨论protect继承：</li>
</ul>
<p>Protect继承会使得基类的public和protect成为protect，只能派生类成员函数访问。而private经过protect继承，还是只能基类的public函数访问，而基类的public成员函数只能派生类成员函数访问，派生类成员函数无法直接访问此时的基类private数据。</p>
<p>例题：</p>
<figure>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2022/01/11/5IB8R9QrqKLOgm6.png" alt="https://s2.loli.net/2022/01/11/5IB8R9QrqKLOgm6.png" /><figcaption aria-hidden="true">https://s2.loli.net/2022/01/11/5IB8R9QrqKLOgm6.png</figcaption>
</figure>
<p>protect对象不可类外访问，但是可以被继承类的成员函数访问。</p>
<h2 id="组合与继承的关系">2.7 组合与继承的关系</h2>
<p>优点：支持增量开发，引入新代码而不影响已有代码正确性。</p>
<p>相似点：实现代码重用。，将子对象引入新类，使用构造函数的初始化成员列表初始化。</p>
<p>不同点： 组合——嵌入一个对象以实现新类的功能，has-a 关系，无重写隐藏。 继承——沿用已存在的类提供的接口，is-a与is-implementing-in-terms-of，有重写隐藏。</p>
<h1 id="三重载与重写隐藏">三、重载与重写隐藏</h1>
<h2 id="定义-2">3.1 定义</h2>
<p>重载(overload)：</p>
<p>目的：提供同名函数的不同实现，属于静态多态。 函数名必须相同，函数参数必须不同，作用域相同（如位于同一个类中；或同名全局函数）。</p>
<p>重写隐藏(redefining)：</p>
<p>目的：在派生类中重新定义基类函数，实现派生类的特殊功能。 屏蔽了基类的所有其它同名函数。 函数名必须相同，函数参数可以不同。</p>
<p>组合不会发生重写隐藏，但是继承会。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Wheel</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">inflate</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;Wheel::inflate&quot;</span>&lt;&lt;endl;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;Wheel::start&quot;</span>&lt;&lt;endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Engine</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;Engine::start&quot;</span>&lt;&lt;endl;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  Engine engine;</span><br><span class="line">  Wheel wheel[<span class="number">4</span>];</span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;Car::start&quot;</span>&lt;&lt;endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  Car car;</span><br><span class="line">  car.wheel[<span class="number">0</span>].<span class="built_in">inflate</span>();   </span><br><span class="line">  car.engine.<span class="built_in">start</span>();</span><br><span class="line">  car.wheel[<span class="number">2</span>].<span class="built_in">start</span>();</span><br><span class="line">  car.<span class="built_in">start</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">Output：</span><br><span class="line">Wheel::inflate</span><br><span class="line">Engine::start</span><br><span class="line">Wheel::start</span><br><span class="line">Car::start</span><br></pre></td></tr></table></figure>
<p>在组合中，我们实现了对于每一类的同名函数调用。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pet</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>&#123;cout&lt;&lt;<span class="string">&quot;Pet eat&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">sleep</span><span class="params">()</span></span>&#123;cout&lt;&lt;<span class="string">&quot;Pet sleep&quot;</span>&lt;&lt;endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Duck</span> :</span> <span class="keyword">public</span> Pet&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>&#123;cout&lt;&lt;<span class="string">&quot;Duck eat&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  Duck duck;</span><br><span class="line">  duck.<span class="built_in">eat</span>();</span><br><span class="line">  duck.<span class="built_in">sleep</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">Output：</span><br><span class="line">Duck eat</span><br><span class="line">Pet sleep</span><br></pre></td></tr></table></figure>
<p>然而在继承中，很明显Pet类的eat函数被派生类重定义，无法被调用。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">T</span> &#123;</span>&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;B::f()\n&quot;</span>; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;Base::f(&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;)\n&quot;</span>; &#125; <span class="comment">/// 重载</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">double</span> d)</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;Base::f(&quot;</span> &lt;&lt; d &lt;&lt; <span class="string">&quot;)\n&quot;</span>; &#125; <span class="comment">///重载</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(T)</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;Base::f(T)\n&quot;</span>; &#125; <span class="comment">///重载</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derive</span> :</span> <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;Derive::f(&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;)\n&quot;</span>; &#125; <span class="comment">///重写隐藏</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Derive d;</span><br><span class="line">  d.<span class="built_in">f</span>(<span class="number">10</span>);</span><br><span class="line">  d.<span class="built_in">f</span>(<span class="number">4.9</span>);     <span class="comment">/// 编译警告。执行自动类型转换。</span></span><br><span class="line">  <span class="comment">//  d.f();        /// 被屏蔽，编译错误</span></span><br><span class="line">  <span class="comment">//  d.f(T()); /// 被屏蔽，编译错误</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在retexter_gcc编译器上无法警告，但是使用clang编译器的警告如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">1869255217</span>/source.cpp:<span class="number">18</span>:<span class="number">7</span>: warning: implicit conversion from <span class="string">&#x27;double&#x27;</span> to <span class="string">&#x27;int&#x27;</span> changes value from <span class="number">4.9</span> to <span class="number">4</span> [-Wliteral-conversion]</span><br><span class="line">  d.<span class="built_in">f</span>(<span class="number">4.9</span>);           </span><br><span class="line">    ~ ^~~</span><br><span class="line"><span class="number">1</span> warning generated.</span><br></pre></td></tr></table></figure>
<h2 id="using-一并使用">3.2 using 一并使用</h2>
<p>和对构造函数的继承一样，using可以一并启用所有被重写覆盖的同名函数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">T</span> &#123;</span>&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;Base::f()\n&quot;</span>; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;Base::f(&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;)\n&quot;</span>; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">double</span> d)</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;Base::f(&quot;</span> &lt;&lt; d &lt;&lt; <span class="string">&quot;)\n&quot;</span>; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(T)</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;Base::f(T)\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derive</span> :</span> <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">using</span> Base::f;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;Derive::f(&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;)\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Derive d;</span><br><span class="line">  d.<span class="built_in">f</span>(<span class="number">10</span>);</span><br><span class="line">  d.<span class="built_in">f</span>(<span class="number">4.9</span>);</span><br><span class="line">  d.<span class="built_in">f</span>();</span><br><span class="line">  d.<span class="built_in">f</span>(<span class="built_in">T</span>());</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">output：</span><br><span class="line">Derive::<span class="built_in">f</span>(<span class="number">10</span>)</span><br><span class="line">Base::<span class="built_in">f</span>(<span class="number">4.9</span>)</span><br><span class="line">Base::<span class="built_in">f</span>()</span><br><span class="line">Base::<span class="built_in">f</span>(T)</span><br></pre></td></tr></table></figure>
<p>并且注意到，Derive和Base都有void f(int i)函数，此处没有发生重定义，而是调用了派生类的void f(int i)。</p>
<p>另外一种在派生类中调用基类同名函数的方法是直接使用对应的类名。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;Base::print()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derive</span> :</span> <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;Derive::print()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(Base obj)</span> </span>&#123; obj.<span class="built_in">print</span>(); &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  Derive d;</span><br><span class="line">  d.Base::<span class="built_in">print</span>();    </span><br><span class="line">  <span class="built_in">fun</span>(d); </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">Output：</span><br><span class="line">Base::<span class="built_in">print</span>()</span><br><span class="line">Base::<span class="built_in">print</span>()</span><br></pre></td></tr></table></figure>
<p>此处调用d.Base::print();没有导致任何一个同名函数被覆盖。</p>
<h2 id="总结-1">3.3 总结</h2>
<p>所谓的重写隐藏（redefining）其实本质上是一种调用优先级问题。派生类默认优先调用自身的函数。如果不启用using关键字，那么除非使用类名，否则无法调用基类的函数，哪怕发生类型转换提示warning也要优先调用自身的函数。而启用了using关键字后，不使用命名空间时，仍然优先调用自身的函数。但是不同于没有启用using关键字的时候，此时如果无法直接调用自身的函数（比如需要类型转换），那么哪怕强制使用派生类的类名也会调用基类的函数。</p>
<p>此处启用using关键字：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">T</span> &#123;</span>&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;Base::f()\n&quot;</span>; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;Base::f(&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;)\n&quot;</span>; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">double</span> d)</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;Base::f(&quot;</span> &lt;&lt; d &lt;&lt; <span class="string">&quot;)\n&quot;</span>; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(T)</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;Base::f(T)\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derive</span> :</span> <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">using</span> Base::f;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;Derive::f(&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;)\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Derive d;</span><br><span class="line">  d.<span class="built_in">f</span>(<span class="number">10</span>);</span><br><span class="line">  d.Base::<span class="built_in">f</span>(<span class="number">10</span>);</span><br><span class="line">  d.<span class="built_in">f</span>(<span class="number">4.9</span>);</span><br><span class="line">  d.Derive::<span class="built_in">f</span>(<span class="number">4.9</span>);</span><br><span class="line">  d.<span class="built_in">f</span>();</span><br><span class="line">  d.<span class="built_in">f</span>(<span class="built_in">T</span>());</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">output：</span><br><span class="line">Derive::<span class="built_in">f</span>(<span class="number">10</span>)</span><br><span class="line">Base::<span class="built_in">f</span>(<span class="number">10</span>)</span><br><span class="line">Base::<span class="built_in">f</span>(<span class="number">4.9</span>)</span><br><span class="line">Base::<span class="built_in">f</span>(<span class="number">4.9</span>)</span><br><span class="line">Base::<span class="built_in">f</span>()</span><br><span class="line">Base::<span class="built_in">f</span>(T)</span><br></pre></td></tr></table></figure>
<p>此处不启用using关键字：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">T</span> &#123;</span>&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;Base::f()\n&quot;</span>; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;Base::f(&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;)\n&quot;</span>; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">double</span> d)</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;Base::f(&quot;</span> &lt;&lt; d &lt;&lt; <span class="string">&quot;)\n&quot;</span>; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(T)</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;Base::f(T)\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derive</span> :</span> <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;Derive::f(&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;)\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Derive d;</span><br><span class="line">  d.<span class="built_in">f</span>(<span class="number">10</span>);</span><br><span class="line">  d.Base::<span class="built_in">f</span>(<span class="number">10</span>);</span><br><span class="line">  d.<span class="built_in">f</span>(<span class="number">4.9</span>);</span><br><span class="line">  d.Base::<span class="built_in">f</span>(<span class="number">4.9</span>);</span><br><span class="line">  d.Base::<span class="built_in">f</span>();</span><br><span class="line">  d.Base::<span class="built_in">f</span>(<span class="built_in">T</span>());</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">Output：</span><br><span class="line">Derive::<span class="built_in">f</span>(<span class="number">10</span>)</span><br><span class="line">Base::<span class="built_in">f</span>(<span class="number">10</span>)</span><br><span class="line">Derive::<span class="built_in">f</span>(<span class="number">4</span>)</span><br><span class="line">Base::<span class="built_in">f</span>(<span class="number">4.9</span>)</span><br><span class="line">Base::<span class="built_in">f</span>()</span><br><span class="line">Base::<span class="built_in">f</span>(T)</span><br></pre></td></tr></table></figure>
<p>不启用using关键字时直接调用f()和f(T)是不合法的。</p>
<h2 id="using关键字作用总结">3.4 using关键字作用总结</h2>
<ol type="1">
<li>（在派生类中）继承基类所有构造函数、恢复被屏蔽的所有同名基类成员函数</li>
<li>指示命名空间using namespace std;</li>
<li>将另一个命名空间的成员引入当前命名空间 如：<code>using std::cout; cout &lt;&lt; endl;</code></li>
<li>定义类型别名，如：<code>using a = int;</code></li>
</ol>
<p>例题：</p>
<figure>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2022/01/11/3ksWr1YQbBpcMdL.png" alt="https://s2.loli.net/2022/01/11/3ksWr1YQbBpcMdL.png" /><figcaption aria-hidden="true">https://s2.loli.net/2022/01/11/3ksWr1YQbBpcMdL.png</figcaption>
</figure>
<p>D选项，注意到B中只using了A的构造函数，没有恢复A的f函数。</p>
<h1 id="四多重继承">四、多重继承</h1>
<h2 id="定义意义和潜在风险">4.1 定义、意义和潜在风险</h2>
<p>派生类同时继承多个基类</p>
<p>格式：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derive</span> :</span> <span class="keyword">public</span> MiddleA, <span class="keyword">public</span> MiddleB&#123;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>数据存储风险</p>
<p>如果派生类D继承的两个基类A,B，是同一基类Base的不同继承，则A,B中继承自Base的数据成员会在D有两份独立的副本，可能带来数据冗余。</p>
<p>二义性风险</p>
<p>如果派生类D继承的两个基类A,B，有同名成员函数或同名成员数据a，则访问D中a时，编译器无法判断要访问的哪一个基类成员。</p>
<p>二义性例子：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">int</span> a&#123;<span class="number">0</span>&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MiddleA</span> :</span> <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">addA</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;a=&quot;</span> &lt;&lt; ++a &lt;&lt; endl; &#125;;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">bar</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;A::bar&quot;</span> &lt;&lt; endl; &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MiddleB</span> :</span> <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">addB</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;a=&quot;</span> &lt;&lt; ++a &lt;&lt; endl; &#125;;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">bar</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;B::bar&quot;</span> &lt;&lt; endl; &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derive</span> :</span> <span class="keyword">public</span> MiddleA, <span class="keyword">public</span> MiddleB&#123;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Derive d;</span><br><span class="line">    d.<span class="built_in">bar</span>();</span><br><span class="line">&#125;</span><br><span class="line">output：</span><br><span class="line">main.cpp:<span class="number">22</span>:<span class="number">7</span>: error: member <span class="string">&#x27;bar&#x27;</span> found in multiple base classes of different types</span><br><span class="line">    d.<span class="built_in">bar</span>();</span><br><span class="line">      ^</span><br><span class="line">main.cpp:<span class="number">10</span>:<span class="number">8</span>: note: <span class="function">member found by ambiguous name lookup</span></span><br><span class="line"><span class="function">  <span class="keyword">void</span> <span class="title">bar</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;A::bar&quot;</span> &lt;&lt; endl; &#125;;</span><br><span class="line">       ^</span><br><span class="line">main.cpp:<span class="number">15</span>:<span class="number">8</span>: note: <span class="function">member found by ambiguous name lookup</span></span><br><span class="line"><span class="function">  <span class="keyword">void</span> <span class="title">bar</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;B::bar&quot;</span> &lt;&lt; endl; &#125;;</span><br><span class="line">       ^</span><br><span class="line"><span class="number">1</span> error generated.</span><br></pre></td></tr></table></figure>
<p>稍作修改</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">int</span> a&#123;<span class="number">0</span>&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MiddleA</span> :</span> <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">addA</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;a=&quot;</span> &lt;&lt; ++a &lt;&lt; endl; &#125;;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">abar</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;A::bar&quot;</span> &lt;&lt; endl; &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MiddleB</span> :</span> <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">addB</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;a=&quot;</span> &lt;&lt; ++a &lt;&lt; endl; &#125;;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">bbar</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;B::bar&quot;</span> &lt;&lt; endl; &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derive</span> :</span> <span class="keyword">public</span> MiddleA, <span class="keyword">public</span> MiddleB&#123;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Derive d;</span><br><span class="line">    d.<span class="built_in">abar</span>();</span><br><span class="line">    d.<span class="built_in">bbar</span>();</span><br><span class="line">&#125;</span><br><span class="line">output：</span><br><span class="line">A::bar</span><br><span class="line">B::bar</span><br></pre></td></tr></table></figure>
<p>例2：同名成员操作</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">#<span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">int</span> a&#123;<span class="number">0</span>&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MiddleA</span> :</span> <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">addA</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;a=&quot;</span> &lt;&lt; ++a &lt;&lt; endl; &#125;;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">bar</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;A::bar&quot;</span> &lt;&lt; endl; &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MiddleB</span> :</span> <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">addB</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;a=&quot;</span> &lt;&lt; ++a &lt;&lt; endl; &#125;;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">bar</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;B::bar&quot;</span> &lt;&lt; endl; &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derive</span> :</span> <span class="keyword">public</span> MiddleA, <span class="keyword">public</span> MiddleB&#123;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Derive d;</span><br><span class="line">  d.<span class="built_in">addA</span>(); <span class="comment">/// 输出 a=1。</span></span><br><span class="line">  d.<span class="built_in">addB</span>(); <span class="comment">/// 仍然输出 a=1。</span></span><br><span class="line">  d.<span class="built_in">addB</span>(); <span class="comment">/// 输出 a=2。</span></span><br><span class="line">  cout &lt;&lt; d.MiddleA::a &lt;&lt; endl; </span><br><span class="line"><span class="comment">/// 输出A中的成员a的值 1</span></span><br><span class="line"> cout &lt;&lt; d.MiddleB::a &lt;&lt; endl; </span><br><span class="line"><span class="comment">/// 输出B中的成员a的值 2</span></span><br><span class="line">  d.MiddleA::<span class="built_in">bar</span>(); </span><br><span class="line">  d.MiddleB::<span class="built_in">bar</span>(); </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">output：</span><br><span class="line">a=<span class="number">1</span></span><br><span class="line">a=<span class="number">1</span></span><br><span class="line">a=<span class="number">2</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line">A::bar</span><br><span class="line">B::bar</span><br></pre></td></tr></table></figure>
<p>注意到，多重继承的二义性并没有导致重复定义，编译器通过命名空间区分了二者不同的a与bar。但是不加命名空间，则无法区分。</p>
<h2 id="多重继承的析构顺序">4.2 多重继承的析构顺序</h2>
<p>结合之后提到的虚函数，多重继承也会配合多态会动态调用析构函数，先析构基类部分，再析构派生类部分。析构顺序也是和构造顺序反向，但是构造顺序是按照申明顺序来的。比如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WhatCanSpeak</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">virtual</span> ~<span class="built_in">WhatCanSpeak</span>() &#123;cout &lt;&lt; <span class="string">&quot;obj cannot speak&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">speak</span><span class="params">()</span> </span>= <span class="number">0</span>;  </span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> </span>= <span class="number">0</span>;  </span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WhatCanMotion</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">virtual</span> ~<span class="built_in">WhatCanMotion</span>() &#123;cout &lt;&lt; <span class="string">&quot;obj cannot move&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">motion</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> </span>= <span class="number">0</span>;  </span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&quot;what.h&quot;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Alien</span>:</span> <span class="keyword">public</span> WhatCanMotion,<span class="keyword">public</span> WhatCanSpeak</span><br><span class="line">&#123;   <span class="keyword">public</span>:</span><br><span class="line">std::string name;</span><br><span class="line"><span class="built_in">Alien</span>(std::string x):name&#123;x&#125;&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">speak</span><span class="params">()</span></span>&#123;std::cout&lt;&lt;name&lt;&lt;<span class="string">&quot; is speaking&quot;</span>&lt;&lt;std::endl;&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span></span>&#123;std::cout&lt;&lt;name&lt;&lt;<span class="string">&quot; stops&quot;</span>&lt;&lt;std::endl;&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">motion</span><span class="params">()</span></span>&#123;std::cout&lt;&lt;name&lt;&lt;<span class="string">&quot; is moving&quot;</span>&lt;&lt;std::endl;&#125;</span><br><span class="line">~<span class="built_in">Alien</span>()&#123;&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>对于Alien的析构是构造的反向。而构造是先构造WhatCanMotion，之后WhatCanSpeak，最后再是派生类部分，故而析构顺序是先派生类，之后WhatCanSpeak，最后WhatCanMotion。</p>
</article><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="addthis_inline_share_toolbox"></div><script src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-62b11572b25ab3ab" async="async"></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/01/12/Lecture/%E4%BB%8E%E5%89%8D%E7%9A%84%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/OOP/L1%E3%80%81L2%20%E7%BB%AA%E8%AE%BA%E4%B8%8E%E7%BC%96%E7%A8%8B%E7%8E%AF%E5%A2%83/"><img class="prev-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/zhaochenyang20/ivue_wallpaper/main/ivue_desktop/Photo by Jakob Owens (FKyHyNowp-4).jpg" onerror="onerror=null;src='https://wkphoto.cdn.bcebos.com/1f178a82b9014a9058a735deb9773912b31bee3c.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">oop笔记  L1、L2 绪论与编程环境</div></div></a></div><div class="next-post pull-right"><a href="/2022/01/12/Lecture/%E4%BB%8E%E5%89%8D%E7%9A%84%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/OOP/L9%20%E5%A4%9A%E6%80%81%E4%B8%8E%E6%A8%A1%E6%9D%BF/"><img class="next-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/zhaochenyang20/ivue_wallpaper/main/ivue_desktop/Photo by Pascal Debrunner (ELv8fvulR0g).jpg" onerror="onerror=null;src='https://wkphoto.cdn.bcebos.com/1f178a82b9014a9058a735deb9773912b31bee3c.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">oop笔记  L9  多态与模板</div></div></a></div></nav><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="gitalk-container"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#l7-%E7%BB%84%E5%90%88%E4%B8%8E%E7%BB%A7%E6%89%BF"><span class="toc-number">1.</span> <span class="toc-text">L7 组合与继承</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%80%E7%BB%84%E5%90%88"><span class="toc-number">2.</span> <span class="toc-text">一、组合</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89"><span class="toc-number">2.1.</span> <span class="toc-text">1.1 定义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%A4%E7%A7%8D%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F"><span class="toc-number">2.2.</span> <span class="toc-text">1.2 两种实现方式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%AC%E6%9C%89%E6%88%90%E5%91%98"><span class="toc-number">2.2.1.</span> <span class="toc-text">1.2.1 公有成员</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A7%81%E6%9C%89%E6%88%90%E5%91%98"><span class="toc-number">2.2.2.</span> <span class="toc-text">1.2.2 私有成员</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#public%E6%8E%A5%E5%8F%A3%E8%AE%BF%E9%97%AEprivate%E6%95%B0%E6%8D%AE"><span class="toc-number">2.2.3.</span> <span class="toc-text">1.2.3 public接口访问private数据</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E4%B8%8E%E6%9E%90%E6%9E%84"><span class="toc-number">2.3.</span> <span class="toc-text">1.3 构造与析构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%90%E5%AF%B9%E8%B1%A1%E5%8F%82%E6%95%B0%E6%9E%84%E9%80%A0"><span class="toc-number">2.3.1.</span> <span class="toc-text">1.3.1 子对象参数构造</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%90%E5%AF%B9%E8%B1%A1%E9%BB%98%E8%AE%A4%E6%9E%84%E9%80%A0"><span class="toc-number">2.3.2.</span> <span class="toc-text">1.3.2 子对象默认构造</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E6%AC%A1%E5%BA%8F"><span class="toc-number">2.3.3.</span> <span class="toc-text">1.3.3 构造次序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%90%E6%9E%84%E6%AC%A1%E5%BA%8F"><span class="toc-number">2.3.4.</span> <span class="toc-text">1.3.4 析构次序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BE%8B%E5%AD%90"><span class="toc-number">2.3.5.</span> <span class="toc-text">1.3.5 例子</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E7%BB%A7%E6%89%BF"><span class="toc-number">3.</span> <span class="toc-text">二、继承</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89-1"><span class="toc-number">3.1.</span> <span class="toc-text">2.1 定义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF%E6%96%B9%E5%BC%8F%E4%B8%8E%E8%AF%AD%E6%B3%95"><span class="toc-number">3.2.</span> <span class="toc-text">2.2 继承方式与语法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%97%A0%E6%B3%95%E7%BB%A7%E6%89%BF"><span class="toc-number">3.3.</span> <span class="toc-text">2.3 无法继承</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E4%B8%8E%E6%9E%90%E6%9E%84-1"><span class="toc-number">3.4.</span> <span class="toc-text">2.4 构造与析构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%A4%E7%B1%BB%E7%BB%A7%E6%89%BF%E6%96%B9%E5%BC%8F%E7%9A%84%E9%80%89%E6%8B%A9"><span class="toc-number">3.5.</span> <span class="toc-text">2.5 两类继承方式的选择</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#public%E7%BB%A7%E6%89%BF"><span class="toc-number">3.5.1.</span> <span class="toc-text">2.5.1 public继承</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#private%E7%BB%A7%E6%89%BF"><span class="toc-number">3.5.2.</span> <span class="toc-text">2.5.2 private继承</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%88%90%E5%91%98%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90"><span class="toc-number">3.6.</span> <span class="toc-text">2.6 成员访问权限</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">3.6.1.</span> <span class="toc-text">总结：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%84%E5%90%88%E4%B8%8E%E7%BB%A7%E6%89%BF%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">3.7.</span> <span class="toc-text">2.7 组合与继承的关系</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%89%E9%87%8D%E8%BD%BD%E4%B8%8E%E9%87%8D%E5%86%99%E9%9A%90%E8%97%8F"><span class="toc-number">4.</span> <span class="toc-text">三、重载与重写隐藏</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89-2"><span class="toc-number">4.1.</span> <span class="toc-text">3.1 定义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#using-%E4%B8%80%E5%B9%B6%E4%BD%BF%E7%94%A8"><span class="toc-number">4.2.</span> <span class="toc-text">3.2 using 一并使用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-1"><span class="toc-number">4.3.</span> <span class="toc-text">3.3 总结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#using%E5%85%B3%E9%94%AE%E5%AD%97%E4%BD%9C%E7%94%A8%E6%80%BB%E7%BB%93"><span class="toc-number">4.4.</span> <span class="toc-text">3.4 using关键字作用总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9B%9B%E5%A4%9A%E9%87%8D%E7%BB%A7%E6%89%BF"><span class="toc-number">5.</span> <span class="toc-text">四、多重继承</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%E6%84%8F%E4%B9%89%E5%92%8C%E6%BD%9C%E5%9C%A8%E9%A3%8E%E9%99%A9"><span class="toc-number">5.1.</span> <span class="toc-text">4.1 定义、意义和潜在风险</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E9%87%8D%E7%BB%A7%E6%89%BF%E7%9A%84%E6%9E%90%E6%9E%84%E9%A1%BA%E5%BA%8F"><span class="toc-number">5.2.</span> <span class="toc-text">4.2 多重继承的析构顺序</span></a></li></ol></li></ol></div></div></div></div></main><footer id="footer" style="background: ＃0096FF"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2022 By Eren Zhao</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div><script type="text/javascript" id="maid-script" src="https://unpkg.com/mermaid@undefined/dist/mermaid.min.js?v=undefined"></script><script>if (window.mermaid) {
  var options = JSON.parse(document.getElementById('maid-script').getAttribute('mermaidoptioins'));
  mermaid.initialize(options);
}</script></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="chat_btn" type="button" title="rightside.chat_btn"><i class="fas fa-sms"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">本地搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库正在艰难运行</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.js"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [ ['$','$'], ["\\(","\\)"]],
      tags: 'ams'
    },
    chtml: {
      scale: 1.2
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, ''],
        insertScript: [200, () => {
          document.querySelectorAll('mjx-container:not\([display]\)').forEach(node => {
            const target = node.parentNode
            if (target.nodeName.toLowerCase() === 'li') {
              target.parentNode.classList.add('has-jax')
            } else {
              target.classList.add('has-jax')
            }
          });
        }, '', false]
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typeset()
}</script><script>(() => {
  const $mermaidWrap = document.querySelectorAll('#article-container .mermaid-wrap')
  if ($mermaidWrap.length) {
    window.runMermaid = () => {
      window.loadMermaid = true
      const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

      Array.from($mermaidWrap).forEach((item, index) => {
        const mermaidSrc = item.firstElementChild
        const mermaidThemeConfig = '%%{init:{ \'theme\':\'' + theme + '\'}}%%\n'
        const mermaidID = 'mermaid-' + index
        const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent
        mermaid.mermaidAPI.render(mermaidID, mermaidDefinition, (svgCode) => {
          mermaidSrc.insertAdjacentHTML('afterend', svgCode)
        })
      })
    }

    const loadMermaid = () => {
      window.loadMermaid ? runMermaid() : getScript('https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js').then(runMermaid)
    }

    window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
  }
})()</script><script>function addGitalkSource () {
  const ele = document.createElement('link')
  ele.rel = 'stylesheet'
  ele.href= 'https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css'
  document.getElementsByTagName('head')[0].appendChild(ele)
}

function loadGitalk () {
  function initGitalk () {
    var gitalk = new Gitalk(Object.assign({
      clientID: '978121c7b834efdd76be',
      clientSecret: '59b40e8f39a1c33db5a2c891771086164b9575c4',
      repo: 'zhaochenyang20.github.io',
      owner: 'zhaochenyang20',
      admin: ['zhaochenyang20'],
      id: 'd3f8d784af19c9977f0695cade8ebf69',
      updateCountCallback: commentCount
    },null))

    gitalk.render('gitalk-container')
  }

  if (typeof Gitalk === 'function') initGitalk()
  else {
    addGitalkSource()
    getScript('https://cdn.jsdelivr.net/npm/gitalk@latest/dist/gitalk.min.js').then(initGitalk)
  }
}

function commentCount(n){
  let isCommentCount = document.querySelector('#post-meta .gitalk-comment-count')
  if (isCommentCount) {
    isCommentCount.innerHTML= n
  }
}

if ('Gitalk' === 'Gitalk' || !true) {
  if (true) btf.loadComment(document.getElementById('gitalk-container'), loadGitalk)
  else loadGitalk()
} else {
  function loadOtherComment () {
    loadGitalk()
  }
}</script></div><canvas class="fireworks" mobile="true"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/fireworks.min.js"></script><script defer="defer" id="fluttering_ribbon" mobile="true" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-fluttering-ribbon.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = false;
POWERMODE.mobile = true;
document.body.addEventListener('input', POWERMODE);
</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/tororo.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":true},"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/"});</script></body></html>