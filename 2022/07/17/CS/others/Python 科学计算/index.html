<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>基于 Numpy 的 Python 科学计算入门 | 你一生的故事</title><meta name="keywords" content="2022夏季,Python"><meta name="author" content="Eren Zhao"><meta name="copyright" content="Eren Zhao"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="我真是不敢相信以前我居然敢不学 Numpy 就搓 Torch....">
<meta property="og:type" content="article">
<meta property="og:title" content="基于 Numpy 的 Python 科学计算入门">
<meta property="og:url" content="http://example.com/2022/07/17/CS/others/Python%20%E7%A7%91%E5%AD%A6%E8%AE%A1%E7%AE%97/index.html">
<meta property="og:site_name" content="你一生的故事">
<meta property="og:description" content="我真是不敢相信以前我居然敢不学 Numpy 就搓 Torch....">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://raw.githubusercontent.com/zhaochenyang20/ivue_wallpaper/main/ivue_desktop/Photo by Jaromír Kavan (L1DksU0Mrd4).jpg">
<meta property="article:published_time" content="2022-07-17T10:18:24.000Z">
<meta property="article:modified_time" content="2022-07-17T10:23:22.165Z">
<meta property="article:author" content="Eren Zhao">
<meta property="article:tag" content="2022夏季">
<meta property="article:tag" content="Python">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://raw.githubusercontent.com/zhaochenyang20/ivue_wallpaper/main/ivue_desktop/Photo by Jaromír Kavan (L1DksU0Mrd4).jpg"><link rel="shortcut icon" href="/img/favicon.ico"><link rel="canonical" href="http://example.com/2022/07/17/CS/others/Python%20%E7%A7%91%E5%AD%A6%E8%AE%A1%E7%AE%97/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"麻了，找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: Eren Zhao","link":"链接: ","source":"来源: 你一生的故事","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: true,
  islazyload: true,
  isAnchor: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '基于 Numpy 的 Python 科学计算入门',
  isPost: true,
  isHome: false,
  isHighlightShrink: true,
  isToc: true,
  postUpdate: '2022-07-17 18:23:22'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          const now = new Date()
          const hour = now.getHours()
          const isNight = hour <= 6 || hour >= 18
          if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
          else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.0.0"><style>.darkmode--activated{--body-bg-color:#282828;--content-bg-color:#333;--card-bg-color:#555;--text-color:#ccc;--blockquote-color:#bbb;--link-color:#ccc;--link-hover-color:#eee;--brand-color:#ddd;--brand-hover-color:#ddd;--table-row-odd-bg-color:#282828;--table-row-hover-bg-color:#363636;--menu-item-bg-color:#555;--btn-default-bg:#222;--btn-default-color:#ccc;--btn-default-border-color:#555;--btn-default-hover-bg:#666;--btn-default-hover-color:#ccc;--btn-default-hover-border-color:#666;--highlight-background:#282b2e;--highlight-foreground:#a9b7c6;--highlight-gutter-background:#34393d;--highlight-gutter-foreground:#9ca9b6}.darkmode--activated img{opacity:.75}.darkmode--activated img:hover{opacity:.9}.darkmode--activated code{color:#69dbdc;background:0 0}button.darkmode-toggle{z-index:9999}.darkmode-ignore,img{display:flex!important}</style></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/avatar.jpeg" onerror="onerror=null;src='/img/friend.jpg'" alt="avatar"/></div><div class="site-data is-center"><div class="data-item"><a href="/archives/"><div class="headline">文章</div><div class="length-num">189</div></a></div><div class="data-item"><a href="/tags/"><div class="headline">标签</div><div class="length-num">53</div></a></div><div class="data-item"><a href="/categories/"><div class="headline">分类</div><div class="length-num">13</div></a></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://raw.githubusercontent.com/zhaochenyang20/ivue_wallpaper/main/ivue_desktop/Photo by Jaromír Kavan (L1DksU0Mrd4).jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">你一生的故事</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">基于 Numpy 的 Python 科学计算入门</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-07-17T10:18:24.000Z" title="发表于 2022-07-17 18:18:24">2022-07-17</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-07-17T10:23:22.165Z" title="更新于 2022-07-17 18:23:22">2022-07-17</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/CS/">CS</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">15.5k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>64分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="基于 Numpy 的 Python 科学计算入门"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="基于-numpy-的-python-科学计算入门">基于 Numpy 的 Python 科学计算入门</h1>
<div data-align="center">
<p><img width="1000" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://github.com/zhaochenyang20/zhaochenyang20.github.io/blob/master/img/profile_4.jpg?raw=true"/></p>
</div>
<div data-align="center">

</div>
<p><strong><a target="_blank" rel="noopener" href="https://zhaochenyang20.github.io/">Eren Zhao</a> THU CST Summer Tutorial 2022</strong></p>
<h2 id="intro-why-numpy">Intro: Why Numpy?</h2>
<p>本课将介绍通过 Python 有效导入、存储和操作内存数据的主要技巧。这个主题非常广泛, 因为数据集的来源与格式都十分丰富, 比如文档集合、图像集合、声音片段集合、数值数据集合, 等等。这些数据虽然存在明显的异构性, 但是将所有数据简单地看作数字数组非常有助于我们理解和处理数据。</p>
<p>例如, 可以将图像（尤其是数字图像）简单地看作二维数字数组, 这些数字数组代表各区 域的像素值; 声音片段可以看作时间和强度的一维数组; 文本也可以通过各种方式转换成 数值表示, 一种可能的转换是用二进制数表示特定单词或单词对出现的频率。不管数据是何种形式, 第一步都是将这些数据转换成数值数组形式的可分析数据。</p>
<p>正因如此, 有效地存储和操作数值数组是数据科学中绝对的基础过程。我们将详细介绍 NumPy。NumPy（Numerical Python 的简称）提供了高效存储和操作密集数据缓存的接口。在某些方面, NumPy 数组与 Python 内置的列表类型非常相似。但是随着数组在维度上变大, NumPy 数组提供了更加高效的存储和数据操作。NumPy 数组几乎是整个 Python 科学计算生态系统的核心。因此, 不管你对数据科学的哪个方面感兴趣, 花点时间学习如何有效地使用 NumPy 都是非常值得的。</p>
<p>如果你听从前言给出的建议安装了 Anaconda, 那么你已经安装好 NumPy, 并可以使用它了。如果你是个体验派, 则可以到 NumPy 网站（http://www.numpy.org/）按照其安装指导进行安装。安装好后, 你可以导入 NumPy 并再次核实你的 NumPy 版本:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line">np.__version__</span><br></pre></td></tr></table></figure>
<pre><code>&#39;1.22.3&#39;</code></pre>
<h1 id="内容重点">内容重点</h1>
<p>这份讲义是我<del>多年来</del>学习中用到的 numpy 的 API 的总结，不得不说非常得多，为此把它们整合为为了查阅的手册。我个人认为，以下内容是你需要清楚理解并且在学习和工作中经常提醒自己的，而其他内容都可以作为工具书来查阅：</p>
<ul>
<li>Numpy 和 Python 的效率区别</li>
<li>Numpy 广播机制的规则</li>
<li>Numpy Fancy Index</li>
<li>传统索引的视图问题</li>
</ul>
<p>其他的 API 基本是用惯了就记住了，而这三点是绝对的重点，也是我课程的讲课重点。其余自学都没有任何问题。</p>
<h2 id="python-数据类型">Python 数据类型</h2>
<p>要实现高效的数据驱动科学和计算，需要理解数据是如何被存储和操作的。本节将介绍在 Python 语言中数据数组是如何被处理的，并对比 NumPy 所做的改进。理解这个不同之处是理解本节其他内容的基础。</p>
<p>Python 的用户往往被其易用性所吸引，其中一个易用之处就在于动态输入。静态类型的语言（如 C 或 Java）往往需要每一个变量都明确地声明，而动态类型的语言（例如 Python）可以跳过这个特殊规定。例如在 C 语言中，你可能会按照如下方式指定一个特殊的操作：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* C代码 */</span></span><br><span class="line"><span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">100</span>; i++)&#123;</span><br><span class="line"> result += i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而在 Python 中，同等的操作可以按照如下方式实现：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Python代码</span></span><br><span class="line">result = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100</span>):</span><br><span class="line"> result += i</span><br></pre></td></tr></table></figure>
<p>注意这里最大的不同之处：在 C 语言中，每个变量的数据类型被明确地声明；而在 Python 中，类型是动态推断的。这意味着可以将任何类型的数据指定给任何变量： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Python代码</span></span><br><span class="line">x = <span class="number">4</span></span><br><span class="line">x = <span class="string">&quot;four&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<p>这里已经将 x 变量的内容由整型转变成了字符串，而同样的操作在 C 语言中将会导致（取决于编译器设置）编译错误或其他未知的后果：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* C代码 */</span></span><br><span class="line"><span class="keyword">int</span> x = <span class="number">4</span>;</span><br><span class="line">x = <span class="string">&quot;four&quot;</span>; <span class="comment">// 编译失败</span></span><br></pre></td></tr></table></figure>
<p>这种灵活性是使 Python 和其他动态类型的语言更易用的原因之一。理解这一特性如何工作是学习用 Python 有效且高效地分析数据的重要因素。但是这种类型灵活性也指出了一个事实：Python 变量不仅是它们的值，还包括了关于值的类型的一些额外信息，本节接下来的内容将进行更详细的介绍。</p>
<h3 id="python-整型不仅仅是一个整型">Python 整型不仅仅是一个整型</h3>
<p>标准的 Python 实现是用 C 语言编写的。这意味着每一个 Python 对象都是一个聪明的伪 C 语言结构体，该结构体不仅包含其值，还有其他信息。例如，当我们在 Python 中定义一个整型，例如 x = 10000 时，x 并不是一个“原生”整型，而是一个指针，指向一个 C 语言的复合结构体，结构体里包含了一些值。查看 Python 3.4 的源代码，可以发现整型（长整型）的定义，如下所示（C 语言的宏经过扩展之后）： <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">longobject</span> &#123;</span></span><br><span class="line"> <span class="keyword">long</span> ob_refcnt;</span><br><span class="line"> PyTypeObject *ob_type;</span><br><span class="line"> <span class="keyword">size_t</span> ob_size;</span><br><span class="line"> <span class="keyword">long</span> ob_digit[<span class="number">1</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure> Python 3.4 中的一个整型实际上包括 4 个部分。</p>
<ul>
<li>ob_refcnt 是一个引用计数，它帮助 Python 默默地处理内存的分配和回收。</li>
<li>ob_type 将变量的类型编码。</li>
<li>ob_size 指定接下来的数据成员的大小。</li>
<li>ob_digit 包含我们希望 Python 变量表示的实际整型值。</li>
</ul>
<p>这意味着与 C 语言这样的编译语言中的整型相比，在 Python 中存储一个整型会有一些开销。</p>
<div data-align="center">
<p><img width="500" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://zhaochenyang20.github.io/pic/embed/6_29_1.jpg"/></p>
</div>
<div data-align="center">
C 整型和 Python 整型的区别，这里 PyObject_HEAD 是结构体中包含引用计数、类型编码和其他部分。
</div>
<p>两者的差异在于，C 语言整型本质上是对应某个内存位置的标签，里面存储的字节会编码成整型。而 Python 的整型其实是一个指针，指向包含这个 Python 对象所有信息的某个内存位置，其中包括可以转换成整型的字节。由于 Python 的整型结构体里面还包含了大量额外的信息，所以 Python 可以自由、动态地编码。但是，Python 类型中的这些额外信息也会成为负担，在多个对象组合的结构体中尤其明显。</p>
<h3 id="python-列表不仅仅是一个列表">Python 列表不仅仅是一个列表</h3>
<p>设想如果使用一个包含很多 Python 对象的 Python 数据结构，会发生什么？ Python 中的标准可变多元素容器是列表。可以用如下方式创建一个整型值列表：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">1</span>]: L = <span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">10</span>))</span><br><span class="line"></span><br><span class="line">In [<span class="number">2</span>]: L</span><br><span class="line">Out[<span class="number">2</span>]: [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]</span><br></pre></td></tr></table></figure>
<p>或者创建一个字符串列表：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">4</span>]: L2 = [<span class="built_in">str</span>(each) <span class="keyword">for</span> each <span class="keyword">in</span> L]</span><br><span class="line"></span><br><span class="line">In [<span class="number">5</span>]: L2</span><br><span class="line">Out[<span class="number">5</span>]: [<span class="string">&#x27;0&#x27;</span>, <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;3&#x27;</span>, <span class="string">&#x27;4&#x27;</span>, <span class="string">&#x27;5&#x27;</span>, <span class="string">&#x27;6&#x27;</span>, <span class="string">&#x27;7&#x27;</span>, <span class="string">&#x27;8&#x27;</span>, <span class="string">&#x27;9&#x27;</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">6</span>]: <span class="built_in">type</span>(L2[<span class="number">0</span>])</span><br><span class="line">Out[<span class="number">6</span>]: <span class="built_in">str</span></span><br></pre></td></tr></table></figure>
<p>因为 Python 的动态类型特性，甚至可以创建一个异构的列表：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">7</span>]:  L3 = [<span class="literal">True</span>, <span class="string">&quot;2&quot;</span>, <span class="number">3.0</span>, <span class="number">4</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">8</span>]: [<span class="built_in">type</span>(item) <span class="keyword">for</span> item <span class="keyword">in</span> L3]</span><br><span class="line">Out[<span class="number">8</span>]: [<span class="built_in">bool</span>, <span class="built_in">str</span>, <span class="built_in">float</span>, <span class="built_in">int</span>]</span><br></pre></td></tr></table></figure>
<p>但是想拥有这种灵活性也是要付出一定代价的：为了获得这些灵活的类型，列表中的每一项必须包含各自的类型信息、引用计数和其他信息；也就是说，每一项都是一个完整的 Python 对象。来看一个特殊的例子，如果列表中的所有变量都是同一类型的，那么很多信息都会显得多余——将数据存储在固定类型的数组中应该会更高效。动态类型的列表和固定类型的（NumPy 式）数组间的区别如下图所示。</p>
<div data-align="center">
<p><img width="500" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://zhaochenyang20.github.io/pic/embed/6_29_2.jpg"/></p>
</div>
<div data-align="center">
numpy 列表和 Python 列表的区别。
</div>
<p>在实现层面，数组基本上包含一个指向连续数据块的指针。另一方面，Python 列表包含一个指向指针块的指针，这其中的每一个指针对应一个完整的 Python 对象（如前面看到的 Python 整型）。另外，列表的优势是灵活，因为每个列表元素是一个包含数据和类型信息的完整结构体，而且列表可以用任意类型的数据填充。固定类型的 NumPy 式数组缺乏这种灵活性，但是能更有效地存储和操作数据。</p>
<h2 id="为何-numpy-会更快">为何 numpy 会更快？</h2>
<p>Python 的默认实现（被称作 CPython）处理起某些操作时非常慢，一部分原因是该语言的动态性和解释性——数据类型灵活的特性决定了序列操作不能像 C 语言和 Fortran 语言一样被编译成有效的机器码。目前，有一些项目试图解决 Python 这一弱点，比较知名的包括：PyPy 项目（http://pypy.org/）。一个实时的 Python 编译实现；Cython 项目（http://cython.org），将 Python 代码转换成可编译的 C 代码；Numba 项目（http://numba.pydata.org/），将 Python 代码的片段转换成快速的 LLVM 字节码。以上这些项目都各有其优势和劣势，但是比较保守地说，这些方法中还没有一种能达到或超过标准 CPython 引擎的受欢迎程度。</p>
<p>我们具体来展示和理解下 CPython 的缓慢——</p>
<p>Python 的相对缓慢通常出现在很多小操作需要不断重复的时候，比如对数组的每个元素做循环操作时。假设有一个数组，我们想计算每个元素的倒数，一种直接的解决方法是：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">np.random.seed(<span class="number">0</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">compute_reciprocals</span>(<span class="params">values</span>):</span></span><br><span class="line">    output = np.empty(<span class="built_in">len</span>(values))</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(values)):</span><br><span class="line">        output[i] = <span class="number">1.0</span> / values[i]</span><br><span class="line">    <span class="keyword">return</span> output</span><br><span class="line">values = np.random.randint(<span class="number">1</span>, <span class="number">10</span>, size=<span class="number">5</span>)</span><br><span class="line">compute_reciprocals(values)</span><br></pre></td></tr></table></figure>
<pre><code>array([0.16666667, 1.        , 0.25      , 0.25      , 0.125     ])</code></pre>
<p>这种实现方式可能对于有 C 语言或 Java 背景的人来说非常自然，但是如果测试一个很大量的输入数据运行上述代码的时间，这一操作将非常耗时，并且是超出意料的慢！我们用 IPython 的 %timeit 魔法函数来测量：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">big_array_numpy = np.random.randint(<span class="number">1</span>, <span class="number">100</span>, size=<span class="number">1000000</span>)</span><br><span class="line">big_array_list = <span class="built_in">list</span>(big_array_numpy)</span><br><span class="line">%timeit compute_reciprocals(big_array_numpy)</span><br><span class="line">%timeit compute_reciprocals(big_array_list)</span><br></pre></td></tr></table></figure>
<pre><code>1.84 s ± 17.1 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)
1.82 s ± 34.4 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)</code></pre>
<p>完成百万次上述操作并存储结果花了几秒钟的时间！在手机都以 Giga-FLOPS（即每秒十亿次浮点运算，一个有趣的对比是当年阿姆斯特朗飞到月球所需要的算力基本等于一部智能手机的算力）为单位计算处理速度时，上面的处理结果所花费的时间确实是不合时宜的慢。事实上，这里的处理瓶颈并不是运算本身，而是 CPython 在每次循环时必须做数据类型的检查和函数的调度。每次进行倒数运算时，Python 首先检查对象的类型，并且动态查找可以使用该数据类型的正确函数。如果我们在编译代码时进行这样的操作，那么就能在代码执行之前知晓类型的声明，结果的计算也会更加有效率。</p>
<p>在上方的例子里，你可能看不出 numpy 的明显优势，但是毕竟这还是在显示地运行 for 循环，而 numpy 的快速主要体现在有着遍历性质的通用函数对 numpy 数组的巨幅加成上。</p>
<p>先扯到这里，我们开始正式入门。</p>
<h1 id="创建和生成">创建和生成</h1>
<p>本节主要介绍 array 的创建和生成。为什么会把这个放在最前面呢？主要有以下两个方面原因：</p>
<ul>
<li>在实际工作过程中，我们时不时需要验证或查看 array 相关的 API 或互操作。</li>
<li>有时候在使用 sklearn，matplotlib，PyTorch，Tensorflow 等工具时也需要一些简单的数据进行实验。</li>
</ul>
<p>所以，先学会如何快速拿到一个 array 是有很多益处的。本节我们主要介绍以下几种常用的创建方式：</p>
<ul>
<li>使用列表或元组</li>
<li>使用 arange</li>
<li>使用 linspace/logspace</li>
<li>使用 ones/zeros</li>
<li>使用 random</li>
<li>从文件读取</li>
</ul>
<p>其中，最常用的一般是 linspace/logspace 和 random，前者常常用在画坐标轴上，后者则用于生成「模拟数据」。举例来说，当我们需要画一个函数的图像时，X 往往使用 linspace 生成，然后使用函数公式求得 Y，再 plot；当我们需要构造一些输入（比如 X）或中间输入（比如 Embedding、hidden state）时，random 会异常方便。</p>
<h3 id="从-python-列表或元组创建">从 python 列表或元组创建</h3>
<p>⭐⭐</p>
<p>重点掌握传入 list 创建一个 array 即可：<code>np.array(list)</code></p>
<p>⚠️ 需要注意的是：「数据类型」。如果您足够仔细的话，可以发现下面第二组代码第 2 个数字是「小数」（注：Python 中 1. == 1.0），而 array 是要保证每个元素类型相同的，所以会帮您把 array 转为一个 float 的类型。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 一个 list</span></span><br><span class="line">np.array([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</span><br></pre></td></tr></table></figure>
<pre><code>array([1, 2, 3])</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 二维（多维类似）</span></span><br><span class="line"><span class="comment"># 注意，有一个小数</span></span><br><span class="line">np.array([[<span class="number">1</span>, <span class="number">2.</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]])</span><br></pre></td></tr></table></figure>
<pre><code>array([[1., 2., 3.],
       [4., 5., 6.]])</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 你也可以指定数据类型</span></span><br><span class="line">np.array([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], dtype=np.float16)</span><br></pre></td></tr></table></figure>
<pre><code>array([1., 2., 3.], dtype=float16)</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 如果指定了 dtype，输入的值都会被转为对应的类型，而且不会四舍五入</span></span><br><span class="line">lst = [</span><br><span class="line">    [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">    [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6.8</span>]</span><br><span class="line">]</span><br><span class="line">np.array(lst, dtype=np.int32)</span><br></pre></td></tr></table></figure>
<pre><code>array([[1, 2, 3],
       [4, 5, 6]], dtype=int32)</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 一个 tuple</span></span><br><span class="line">np.asarray((<span class="number">1.1</span>, <span class="number">2.2</span>))</span><br></pre></td></tr></table></figure>
<pre><code>array([1.1, 2.2])</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># tuple，一般用 list 就好，不需要使用 tuple</span></span><br><span class="line">np.array([(<span class="number">1.1</span>, <span class="number">2.2</span>, <span class="number">3.3</span>), (<span class="number">4.4</span>, <span class="number">5.5</span>, <span class="number">6.6</span>)])</span><br></pre></td></tr></table></figure>
<pre><code>array([[1.1, 2.2, 3.3],
       [4.4, 5.5, 6.6]])</code></pre>
<p>至于 asarray 和 array 的区别：</p>
<p>array 和 asarray 都可以将结构数据转化为 ndarray，但是主要区别就是当数据源是 ndarray 时，array 会 copy 出一个副本，占用新的内存，但 asarray 不会。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">arr1 = np.array([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line">arr2 = np.array(arr1)</span><br><span class="line">arr3 = np.asarray(arr1)</span><br><span class="line">arr2[<span class="number">1</span>] = <span class="number">10</span></span><br><span class="line"><span class="built_in">print</span>(arr1)</span><br><span class="line">arr3[<span class="number">1</span>] = <span class="number">10</span></span><br><span class="line"><span class="built_in">print</span>(arr1)</span><br></pre></td></tr></table></figure>
<pre><code>[1 2 3]
[ 1 10  3]</code></pre>
<h2 id="使用-arange-生成">使用 arange 生成</h2>
<p>⭐⭐</p>
<p>range 是 Python 内置的整数序列生成器，arange 是 numpy 的，效果类似，会生成一维的向量。我们偶尔会需要使用这种方式来构造 array，比如：</p>
<p>需要创建一个连续一维向量作为输入（比如编码位置时可以使用）需要观察筛选、抽样的结果时，有序的 array 一般更加容易观察</p>
<p>⚠️ 需要注意的是：在 reshape 时，目标的 shape 需要的元素数量一定要和原始的元素数量相等。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">np.arange(<span class="number">12</span>).reshape(<span class="number">3</span>, <span class="number">4</span>)</span><br></pre></td></tr></table></figure>
<pre><code>array([[ 0,  1,  2,  3],
       [ 4,  5,  6,  7],
       [ 8,  9, 10, 11]])</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 注意，是小数</span></span><br><span class="line">np.arange(<span class="number">12.0</span>).reshape(<span class="number">4</span>, <span class="number">3</span>)</span><br></pre></td></tr></table></figure>
<pre><code>array([[ 0.,  1.,  2.],
       [ 3.,  4.,  5.],
       [ 6.,  7.,  8.],
       [ 9., 10., 11.]])</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">np.arange(<span class="number">100</span>, <span class="number">124</span>, <span class="number">2</span>).reshape(<span class="number">3</span>, <span class="number">2</span>, <span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<pre><code>array([[[100, 102],
        [104, 106]],

       [[108, 110],
        [112, 114]],

       [[116, 118],
        [120, 122]]])</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># shape size 相乘要和生成的元素数量一致</span></span><br><span class="line">np.arange(<span class="number">100.</span>, <span class="number">124.</span>, <span class="number">2</span>).reshape(<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)</span><br></pre></td></tr></table></figure>
<pre><code>---------------------------------------------------------------------------

ValueError                                Traceback (most recent call last)

/Users/zhaochen20/Desktop/Python 科学计算.ipynb Cell 23 in &lt;cell line: 2&gt;()
      &lt;a href=&#39;vscode-notebook-cell:/Users/zhaochen20/Desktop/Python%20%E7%A7%91%E5%AD%A6%E8%AE%A1%E7%AE%97.ipynb#ch0000024?line=0&#39;&gt;1&lt;/a&gt; # shape size 相乘要和生成的元素数量一致
----&gt; &lt;a href=&#39;vscode-notebook-cell:/Users/zhaochen20/Desktop/Python%20%E7%A7%91%E5%AD%A6%E8%AE%A1%E7%AE%97.ipynb#ch0000024?line=1&#39;&gt;2&lt;/a&gt; np.arange(100., 124., 2).reshape(2,3,4)


ValueError: cannot reshape array of size 12 into shape (2,3,4)</code></pre>
<h3 id="使用-linspacelogspace-生成">使用 linspace/logspace 生成</h3>
<p>⭐⭐⭐</p>
<p>OK，这是我们遇到的第一个比较重要的 API，前者需要传入 3 个参数：开头，结尾，数量；后者需要额外传入一个 base，它默认是 10。</p>
<p>⚠️ 需要注意的是：第三个参数并<strong>不是</strong>步长。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 线性</span></span><br><span class="line"><span class="built_in">print</span>(np.linspace(<span class="number">0</span>, <span class="number">9</span>, <span class="number">10</span>).reshape(<span class="number">2</span>, <span class="number">5</span>, <span class="number">1</span>))</span><br><span class="line">np.linspace(<span class="number">0</span>, <span class="number">9</span>, <span class="number">10</span>).reshape(<span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>)</span><br></pre></td></tr></table></figure>
<pre><code>[[[0.]
  [1.]
  [2.]
  [3.]
  [4.]]

 [[5.]
  [6.]
  [7.]
  [8.]
  [9.]]]





array([[[0., 1., 2., 3., 4.],
        [5., 6., 7., 8., 9.]]])</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">np.linspace(<span class="number">0</span>, <span class="number">9</span>, <span class="number">6</span>).reshape(<span class="number">2</span>, <span class="number">3</span>)</span><br></pre></td></tr></table></figure>
<pre><code>array([[0. , 1.8, 3.6],
       [5.4, 7.2, 9. ]])</code></pre>
<p>接下来是 logspace，注意其意义就是按照<a target="_blank" rel="noopener" href="https://zhaochenyang20.github.io/2022/01/08/%E9%9A%8F%E7%AC%94/%E5%BF%83%E5%BF%83%E5%BF%B5%E5%BF%B5/%E9%9F%B3%E4%B9%90%E4%B8%AD%E7%9A%84%E6%95%B0%E7%90%86%E9%80%BB%E8%BE%91/">指数线性</a>来生成数据。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 指数 base 默认为 10</span></span><br><span class="line"><span class="built_in">print</span>(np.logspace(<span class="number">0</span>, <span class="number">9</span>, <span class="number">6</span>, base=np.e))</span><br><span class="line"><span class="built_in">print</span>(np.log(np.logspace(<span class="number">0</span>, <span class="number">9</span>, <span class="number">6</span>, base=np.e)))</span><br><span class="line"><span class="built_in">print</span>(np.logspace(<span class="number">0</span>, <span class="number">9</span>, <span class="number">6</span>, base=<span class="number">10</span>))</span><br><span class="line"><span class="built_in">print</span>(np.log10(np.logspace(<span class="number">0</span>, <span class="number">9</span>, <span class="number">6</span>, base=<span class="number">10</span>)))</span><br></pre></td></tr></table></figure>
<pre><code>[1.00000000e+00 6.04964746e+00 3.65982344e+01 2.21406416e+02
 1.33943076e+03 8.10308393e+03]
[0.  1.8 3.6 5.4 7.2 9. ]
[1.00000000e+00 6.30957344e+01 3.98107171e+03 2.51188643e+05
 1.58489319e+07 1.00000000e+09]
[0.  1.8 3.6 5.4 7.2 9. ]</code></pre>
<p>下面我们更进一步看一下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">N = <span class="number">20</span></span><br><span class="line">x = np.arange(N)</span><br><span class="line">y1 = np.linspace(<span class="number">0</span>, <span class="number">10</span>, N) * <span class="number">100</span></span><br><span class="line">y2 = np.logspace(<span class="number">0</span>, <span class="number">10</span>, N, base=<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">plt.plot(x, y2, <span class="string">&#x27;*&#x27;</span>);</span><br><span class="line">plt.plot(x, y1, <span class="string">&#x27;o&#x27;</span>);</span><br><span class="line"><span class="comment">#! 划线</span></span><br><span class="line">plt.plot(x, y2);</span><br><span class="line">plt.plot(x, y1);</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 检查每个元素是否为 True</span></span><br><span class="line"><span class="comment"># base 的 指数为 linspace 得到的就是 logspace</span></span><br><span class="line">N = <span class="number">20</span></span><br><span class="line">y2 = np.logspace(<span class="number">0</span>, <span class="number">10</span>, N, base=<span class="number">2</span>)</span><br><span class="line">np.alltrue(<span class="number">2</span> ** np.linspace(<span class="number">0</span>, <span class="number">10</span>, N)  == y2)</span><br></pre></td></tr></table></figure>
<pre><code>True</code></pre>
<blockquote>
<p>⚠️ 补充：关于 array 的条件判断</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 不能直接用 if 判断 array 是否符合某个条件</span></span><br><span class="line">arr = np.array([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line">cond1 = arr &gt; <span class="number">2</span></span><br><span class="line">cond1</span><br></pre></td></tr></table></figure>
<pre><code>array([False, False,  True])</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> cond1:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;forbid&quot;</span>)</span><br></pre></td></tr></table></figure>
<pre><code>---------------------------------------------------------------------------

ValueError                                Traceback (most recent call last)

/Users/zhaochen20/Desktop/Python 科学计算.ipynb Cell 34 in &lt;cell line: 1&gt;()
----&gt; &lt;a href=&#39;vscode-notebook-cell:/Users/zhaochen20/Desktop/Python%20%E7%A7%91%E5%AD%A6%E8%AE%A1%E7%AE%97.ipynb#ch0000036?line=0&#39;&gt;1&lt;/a&gt; if cond1:
      &lt;a href=&#39;vscode-notebook-cell:/Users/zhaochen20/Desktop/Python%20%E7%A7%91%E5%AD%A6%E8%AE%A1%E7%AE%97.ipynb#ch0000036?line=1&#39;&gt;2&lt;/a&gt;     print(&quot;forbid&quot;)


ValueError: The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 即便你全是 True 它也不行</span></span><br><span class="line">arr = np.array([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line">cond2 = arr &gt; <span class="number">0</span></span><br><span class="line"><span class="keyword">if</span> cond2:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;forbid&quot;</span>)</span><br></pre></td></tr></table></figure>
<pre><code>---------------------------------------------------------------------------

ValueError                                Traceback (most recent call last)

/Users/zhaochen20/Desktop/Python 科学计算.ipynb Cell 35 in &lt;cell line: 4&gt;()
      &lt;a href=&#39;vscode-notebook-cell:/Users/zhaochen20/Desktop/Python%20%E7%A7%91%E5%AD%A6%E8%AE%A1%E7%AE%97.ipynb#ch0000037?line=1&#39;&gt;2&lt;/a&gt; arr = np.array([1, 2, 3])
      &lt;a href=&#39;vscode-notebook-cell:/Users/zhaochen20/Desktop/Python%20%E7%A7%91%E5%AD%A6%E8%AE%A1%E7%AE%97.ipynb#ch0000037?line=2&#39;&gt;3&lt;/a&gt; cond2 = arr &gt; 0
----&gt; &lt;a href=&#39;vscode-notebook-cell:/Users/zhaochen20/Desktop/Python%20%E7%A7%91%E5%AD%A6%E8%AE%A1%E7%AE%97.ipynb#ch0000037?line=3&#39;&gt;4&lt;/a&gt; if cond2:
      &lt;a href=&#39;vscode-notebook-cell:/Users/zhaochen20/Desktop/Python%20%E7%A7%91%E5%AD%A6%E8%AE%A1%E7%AE%97.ipynb#ch0000037?line=4&#39;&gt;5&lt;/a&gt;     print(&quot;forbid&quot;)


ValueError: The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 只能用 any 或 all，这个很容易犯错，请务必注意。</span></span><br><span class="line"><span class="keyword">if</span> cond1.<span class="built_in">any</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;if any&quot;</span>)</span><br></pre></td></tr></table></figure>
<pre><code>if any</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> cond2.<span class="built_in">all</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;all conform&quot;</span>)</span><br></pre></td></tr></table></figure>
<pre><code>all conform</code></pre>
<h3 id="使用-oneszeros-创建">使用 ones/zeros 创建</h3>
<p>⭐</p>
<p>创建全 1/0 array 的快捷方式。需要注意的是 <code>np.zeros_like</code> 或 <code>np.ones_like</code>，二者可以快速生成给定 array 一样 shape 的 0 或 1 向量，这在需要 Mask 某些位置时可能会用到。</p>
<p>⚠️ 需要注意的是：创建出来的 array 默认是 float 类型。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">np.ones(<span class="number">3</span>)</span><br></pre></td></tr></table></figure>
<pre><code>array([1., 1., 1.])</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">np.ones((<span class="number">2</span>, <span class="number">3</span>))</span><br></pre></td></tr></table></figure>
<pre><code>array([[1., 1., 1.],
       [1., 1., 1.]])</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">np.zeros((<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>))</span><br></pre></td></tr></table></figure>
<pre><code>array([[[0., 0., 0., 0.],
        [0., 0., 0., 0.],
        [0., 0., 0., 0.]],

       [[0., 0., 0., 0.],
        [0., 0., 0., 0.],
        [0., 0., 0., 0.]]])</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 像给定向量那样的 0 向量（ones_like 是 1 向量）</span></span><br><span class="line"><span class="built_in">print</span>(np.zeros_like(np.ones((<span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>))))</span><br></pre></td></tr></table></figure>
<pre><code>[[[0. 0. 0.]
  [0. 0. 0.]
  [0. 0. 0.]]

 [[0. 0. 0.]
  [0. 0. 0.]
  [0. 0. 0.]]]</code></pre>
<h3 id="使用-random-生成">使用 random 生成</h3>
<p>⭐⭐⭐⭐⭐</p>
<p>如果要在这一节选一个最重要的 API，那一定是 <code>random</code> 无疑了，这里我们只介绍几个比较常用的「生产」数据相关的 API。它们经常用于随机生成训练或测试数据，神经网络初始化等。</p>
<p>⚠️ 需要注意的是：这里我们统一推荐使用新的 API 方式创建，即通过 <code>np.random.default_rng()</code> 先生成 <code>Generator</code>，然后再在此基础上生成各种分布的数据（记忆更加简便清晰）。不过我们依然会介绍就的 API 用法，因为很多代码中使用的还是旧的，您可以混个眼熟。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 0-1 连续均匀分布</span></span><br><span class="line">np.random.rand(<span class="number">2</span>, <span class="number">3</span>)</span><br></pre></td></tr></table></figure>
<pre><code>array([[0.54422614, 0.7771694 , 0.17419901],
       [0.70917992, 0.44169007, 0.24421882]])</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 单个数</span></span><br><span class="line">np.random.rand()</span><br></pre></td></tr></table></figure>
<pre><code>0.5064066705679392</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 0-1 连续均匀分布</span></span><br><span class="line">np.random.random((<span class="number">3</span>, <span class="number">2</span>))</span><br></pre></td></tr></table></figure>
<pre><code>array([[0.60052534, 0.62961777],
       [0.6097588 , 0.98259692],
       [0.81380663, 0.90393871]])</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 指定上下界的连续均匀分布</span></span><br><span class="line">np.random.uniform(-<span class="number">1</span>, <span class="number">1</span>, (<span class="number">2</span>, <span class="number">3</span>))</span><br></pre></td></tr></table></figure>
<pre><code>array([[-0.70988965,  0.61189297, -0.0014294 ],
       [ 0.16404608, -0.99240214, -0.26983641]])</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 上面两个的区别是 shape 的输入方式不同，无伤大雅了</span></span><br><span class="line"><span class="comment"># 不过从 1.17 版本后推荐这样使用（以后大家可以用新的方法）</span></span><br><span class="line"><span class="comment"># rng 是个 Generator，可用于生成各种分布</span></span><br><span class="line"><span class="comment">#! 42 是随机数种子，众所周知，计算机是完全不存在随机的，指定相同的随机数种子，我们会生成相同的随机结果</span></span><br><span class="line">rng = np.random.default_rng(<span class="number">42</span>)</span><br><span class="line">rng</span><br></pre></td></tr></table></figure>
<pre><code>Generator(PCG64) at 0x7F7908077580</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 推荐的连续均匀分布用法</span></span><br><span class="line">rng.random((<span class="number">2</span>, <span class="number">3</span>))</span><br></pre></td></tr></table></figure>
<pre><code>array([[0.77395605, 0.43887844, 0.85859792],
       [0.69736803, 0.09417735, 0.97562235]])</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 可以指定上下界，所以更加推荐这种用法</span></span><br><span class="line">rng.uniform(<span class="number">0</span>, <span class="number">1</span>, (<span class="number">2</span>, <span class="number">3</span>))</span><br></pre></td></tr></table></figure>
<pre><code>array([[0.7611397 , 0.78606431, 0.12811363],
       [0.45038594, 0.37079802, 0.92676499]])</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 随机整数（离散均匀分布），不超过给定的值（10）</span></span><br><span class="line"><span class="built_in">print</span>(np.random.randint(<span class="number">100</span>, size=(<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)))</span><br><span class="line">rng.integers(<span class="number">100</span>, size=(<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>))</span><br></pre></td></tr></table></figure>
<pre><code>[[[ 7 12 27 48]
  [58 98 27  1]
  [57 45  5 68]]

 [[28 19 15 42]
  [28 93  3 32]
  [58 89 94 32]]]





array([[[67, 77, 75, 19],
        [36, 46, 49,  4],
        [54, 15, 74, 68]],

       [[92, 74, 36, 96],
        [41, 32, 90, 37],
        [ 7, 46, 79, 18]]])</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 随机整数（离散均匀分布），指定上下界和 shape</span></span><br><span class="line">np.random.randint(<span class="number">0</span>, <span class="number">10</span>, (<span class="number">2</span>, <span class="number">3</span>))</span><br></pre></td></tr></table></figure>
<pre><code>array([[8, 4, 7],
       [4, 5, 3]])</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 上面推荐的方法，指定大小和上界</span></span><br><span class="line">rng.integers(<span class="number">10</span>, size=<span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<pre><code>array([4, 1])</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 上面推荐的方法，指定上下界</span></span><br><span class="line">rng.integers(<span class="number">0</span>, <span class="number">10</span>, (<span class="number">2</span>, <span class="number">3</span>))</span><br></pre></td></tr></table></figure>
<pre><code>array([[6, 4, 3],
       [2, 5, 6]])</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 标准正态分布</span></span><br><span class="line">np.random.randn(<span class="number">2</span>, <span class="number">4</span>)</span><br></pre></td></tr></table></figure>
<pre><code>array([[ 1.00598973, -2.32839773,  0.8845468 , -0.01272806],
       [ 0.49565494, -1.40539762,  1.79185433,  0.36375782]])</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 上面推荐的标准正态分布用法</span></span><br><span class="line">rng.standard_normal((<span class="number">2</span>, <span class="number">4</span>))</span><br></pre></td></tr></table></figure>
<pre><code>array([[ 0.74325417,  0.54315427, -0.66550971,  0.23216132],
       [ 0.11668581,  0.2186886 ,  0.87142878,  0.22359555]])</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 高斯分布</span></span><br><span class="line">np.random.normal(<span class="number">0</span>, <span class="number">1</span>, (<span class="number">3</span>, <span class="number">5</span>))</span><br></pre></td></tr></table></figure>
<pre><code>array([[-0.9099195 ,  0.40175023,  0.2742747 , -0.76010006,  0.33305447],
       [ 0.36653939,  0.40263391,  2.12750154,  0.45131352, -0.5574691 ],
       [-0.84153653, -0.09624566,  0.83520801,  0.02640151,  0.65957284]])</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 上面推荐的高斯分布用法</span></span><br><span class="line">rng.normal(<span class="number">0</span>, <span class="number">1</span>, (<span class="number">3</span>, <span class="number">5</span>))</span><br></pre></td></tr></table></figure>
<pre><code>array([[ 0.67891356,  0.06757907,  0.2891194 ,  0.63128823, -1.45715582],
       [-0.31967122, -0.47037265, -0.63887785, -0.27514225,  1.49494131],
       [-0.86583112,  0.96827835, -1.68286977, -0.33488503,  0.16275307]])</code></pre>
<p>总之，一般会用的就是2个分布：均匀分布和正态（高斯）分布。另外，<code>size</code> 可以指定 shape。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 离散均匀分布</span></span><br><span class="line">rng.integers(low=<span class="number">0</span>, high=<span class="number">10</span>, size=<span class="number">5</span>)</span><br></pre></td></tr></table></figure>
<pre><code>array([5, 5, 0, 5, 7])</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 正态（高斯）分布</span></span><br><span class="line">rng.normal(loc=<span class="number">0.0</span>, scale=<span class="number">1.0</span>, size=(<span class="number">2</span>, <span class="number">3</span>))</span><br></pre></td></tr></table></figure>
<pre><code>array([[-0.34872507, -0.46235179,  0.85797588],
       [-0.19130432, -1.27568632, -1.13328721]])</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 连续均匀分布</span></span><br><span class="line">rng.uniform(low=<span class="number">0</span>, high=<span class="number">10</span>, size=<span class="number">5</span>)</span><br></pre></td></tr></table></figure>
<pre><code>array([0.58302742, 2.81383892, 2.93593758, 6.61916515, 5.57032152])</code></pre>
<h3 id="从文件读取">从文件读取</h3>
<p>⭐⭐⭐⭐⭐</p>
<p>这小节主要用于加载实现存储好的权重参数或预处理好的数据集，有时候会比较方便，比如训练好的模型参数加载到内存里用来提供推理服务，或者耗时很久的预处理数据直接存起来，多次实验时不需要重新处理。</p>
<p>⚠️ 需要注意的是：存储时不需要写文件名后缀，会自动添加。 在<a target="_blank" rel="noopener" href="https://github.com/zhaochenyang20/IAI_2022">人智导</a>中可以优雅地使用，但是请自行学习 <code>allow_pickle</code> 参数，此处给出<a target="_blank" rel="noopener" href="https://github.com/zhaochenyang20/IAI_2022/blob/main/homework/input-method/src/pinyin.py">输入法大作业</a>里的一个例子： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dictionary = np.load(Path.cwd() / <span class="string">&quot;dictionary.npz&quot;</span>, allow_pickle=<span class="literal">True</span>)[<span class="string">&quot;dic&quot;</span>].item()</span><br><span class="line">one, two, three = [Counter(each[<span class="number">1</span>].item()) <span class="keyword">for</span> each <span class="keyword">in</span> np.load(Path.cwd() / <span class="string">&quot;full_set.npz&quot;</span>, allow_pickle=<span class="literal">True</span>).items()]</span><br></pre></td></tr></table></figure></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 直接将给定矩阵存为 a.npy</span></span><br><span class="line">np.save(<span class="string">&#x27;./a&#x27;</span>, np.array([[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]]))</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 可以将多个矩阵存在一起，名为 `b.npz`</span></span><br><span class="line">np.savez(<span class="string">&quot;./b&quot;</span>, a=np.arange(<span class="number">12</span>).reshape(<span class="number">3</span>, <span class="number">4</span>), 字典=np.arange(<span class="number">12.</span>).reshape(<span class="number">4</span>, <span class="number">3</span>))</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 和上一个一样，只是压缩了</span></span><br><span class="line">np.savez_compressed(<span class="string">&quot;./c&quot;</span>, a=np.arange(<span class="number">12</span>).reshape(<span class="number">3</span>, <span class="number">4</span>), c=np.arange(<span class="number">12.</span>).reshape(<span class="number">4</span>, <span class="number">3</span>))</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 加载单个 array</span></span><br><span class="line">np.load(<span class="string">&quot;./a.npy&quot;</span>)</span><br></pre></td></tr></table></figure>
<pre><code>array([[1, 2, 3],
       [4, 5, 6]])</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 加载多个，可以像字典那样取出对应的 array</span></span><br><span class="line">arr = np.load(<span class="string">&quot;./b.npz&quot;</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 可以直接使用 npz、npb 的名称进行加载</span></span><br><span class="line">arr[<span class="string">&quot;字典&quot;</span>]</span><br></pre></td></tr></table></figure>
<pre><code>array([[ 0.,  1.,  2.],
       [ 3.,  4.,  5.],
       [ 6.,  7.,  8.],
       [ 9., 10., 11.]])</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> key <span class="keyword">in</span> arr:</span><br><span class="line">    <span class="built_in">print</span>(key)</span><br></pre></td></tr></table></figure>
<pre><code>a
字典</code></pre>
<h2 id="统计和属性">统计和属性</h2>
<p>本节我们从 array 的基本统计属性入手，对刚刚创建的 array 进一步的了解。主要包括以下几个方面：</p>
<ul>
<li>尺寸相关</li>
<li>最大、最小、中位、分位值</li>
<li>平均、求和、标准差等</li>
</ul>
<p>都是描述性统计相关的指标，对于我们从整体了解一个 array 很有帮助。其中，用到最多的是尺寸相关的「<code>shape</code>」，最大、最小值，平均值、求和等。</p>
<p>本节的内容非常简单，您只需要特别关注（记住）两个重要的特性：</p>
<ul>
<li>按维度（指定 axis）求结果。一般 0 表示列 1 表示行，可以用「<strong>沿着行/列操作</strong>」这样理解，不确定时可以拿个例子试一下。</li>
<li>计算后保持维度（<code>keepdims=True</code>）</li>
</ul>
<p><strong>另外，为了便于操作，我们使用一个随机生成的 array 作为操作对象；同时，我们指定了 seed，这样每次运行，每个人看到的结果都是一样的。一般我们在训练模型时，往往需要指定 seed，这样才能在「同等条件」下进行调参。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#  先创建一个 Generator</span></span><br><span class="line">rng = np.random.default_rng(seed=<span class="number">42</span>)</span><br><span class="line"><span class="comment">#  再生成一个均匀分布</span></span><br><span class="line">arr = rng.uniform(<span class="number">0</span>, <span class="number">1</span>, (<span class="number">3</span>, <span class="number">4</span>))</span><br><span class="line">arr</span><br></pre></td></tr></table></figure>
<pre><code>array([[0.77395605, 0.43887844, 0.85859792, 0.69736803],
       [0.09417735, 0.97562235, 0.7611397 , 0.78606431],
       [0.12811363, 0.45038594, 0.37079802, 0.92676499]])</code></pre>
<h3 id="尺寸相关">尺寸相关</h3>
<p>⭐⭐</p>
<p>这一小节主要包括：维度、形状和数据量，其中形状 <code>shape</code> 我们用到的最多。</p>
<p>⚠️ 需要注意的是：size 不是 shape。而 ndim 表示有几个维度。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 维度，array 是二维的（两个维度）</span></span><br><span class="line">arr.ndim</span><br></pre></td></tr></table></figure>
<pre><code>2</code></pre>
<h4 id="np.shape"><code>np.shape</code></h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 形状，返回一个 Tuple</span></span><br><span class="line">arr.shape</span><br></pre></td></tr></table></figure>
<pre><code>(3, 4)</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 数据量</span></span><br><span class="line">arr.size</span><br></pre></td></tr></table></figure>
<pre><code>12</code></pre>
<h3 id="最值分位">最值分位</h3>
<p>⭐⭐⭐</p>
<p>这一小节主要包括：最大值、最小值、中位数、其他分位数，其中『<strong>最大值和最小值</strong>』我们平时用到的最多。</p>
<p>⚠️ 需要注意的是：分位数可以是 0-1 的任意小数（表示对应分位），而且分位数并不一定在原始的 array 中。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 所有元素中最大的</span></span><br><span class="line">arr.<span class="built_in">max</span>()</span><br></pre></td></tr></table></figure>
<pre><code>0.9756223516367559</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 按维度（列）最大值</span></span><br><span class="line">arr.<span class="built_in">max</span>(axis=<span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<pre><code>array([0.77395605, 0.97562235, 0.85859792, 0.92676499])</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 同理，按行</span></span><br><span class="line">arr.<span class="built_in">max</span>(axis=<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<pre><code>array([0.85859792, 0.97562235, 0.92676499])</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 是否保持原来的维度</span></span><br><span class="line"><span class="comment"># 这个需要特别注意下，很多深度学习模型中都需要保持原有的维度进行后续计算</span></span><br><span class="line"><span class="comment"># arr.min 的维度是 (3,1)，array 的 shape 是 (3,4)，按行，同时保持了行的维度</span></span><br><span class="line">arr.<span class="built_in">min</span>(axis=<span class="number">1</span>, keepdims=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>
<pre><code>array([[0.43887844],
       [0.09417735],
       [0.12811363]])</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 保持维度：（1，4），原始array是（3，4）</span></span><br><span class="line">arr.<span class="built_in">min</span>(axis=<span class="number">0</span>, keepdims=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>
<pre><code>array([[0.09417735, 0.43887844, 0.37079802, 0.69736803]])</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 一维了</span></span><br><span class="line">arr.<span class="built_in">min</span>(axis=<span class="number">0</span>, keepdims=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure>
<pre><code>array([0.09417735, 0.43887844, 0.37079802, 0.69736803])</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 中位数</span></span><br><span class="line"><span class="comment"># 其他用法和 max，min 是一样的</span></span><br><span class="line">np.median(arr)</span><br></pre></td></tr></table></figure>
<pre><code>0.7292538655248584</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 分位数，注意，分位数可以是 0-1 之间的任何数字（分位）</span></span><br><span class="line"><span class="comment"># 如果是 1/2 分位，那正好是中位数</span></span><br><span class="line">np.quantile(arr, q=<span class="number">1</span>/<span class="number">2</span>, axis=<span class="number">1</span>, keepdims=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>
<pre><code>array([[0.73566204],
       [0.773602  ],
       [0.41059198]])</code></pre>
<h3 id="平均求和标准差">平均求和标准差</h3>
<p>⭐⭐⭐</p>
<p>这一小节主要包括：平均值、累计求和、方差、标准差等进一步的统计指标。其中使用最多的是「平均值」。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 平均值</span></span><br><span class="line">np.average(arr)</span><br></pre></td></tr></table></figure>
<pre><code>0.6051555606435642</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 按维度平均（列）</span></span><br><span class="line">np.average(arr, axis=<span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<pre><code>array([0.33208234, 0.62162891, 0.66351188, 0.80339911])</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 另一个计算平均值的 API</span></span><br><span class="line"><span class="comment"># 它与 average 的主要区别是，np.average 可以指定权重，即可以用于计算加权平均</span></span><br><span class="line"><span class="comment"># 一般建议使用 average，忘掉 mean 吧！</span></span><br><span class="line">np.mean(arr, axis=<span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<pre><code>array([0.33208234, 0.62162891, 0.66351188, 0.80339911])</code></pre>
<h4 id="np.sum"><code>np.sum</code></h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 求和，不多说了，类似</span></span><br><span class="line">np.<span class="built_in">sum</span>(arr, axis=<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<pre><code>array([2.76880044, 2.61700371, 1.87606258])</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">np.<span class="built_in">sum</span>(arr, axis=<span class="number">1</span>, keepdims=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>
<pre><code>array([[2.76880044],
       [2.61700371],
       [1.87606258]])</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 按列累计求和</span></span><br><span class="line">np.cumsum(arr, axis=<span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<pre><code>array([[0.77395605, 0.43887844, 0.85859792, 0.69736803],
       [0.8681334 , 1.41450079, 1.61973762, 1.48343233],
       [0.99624703, 1.86488673, 1.99053565, 2.41019732]])</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 按行累计求和</span></span><br><span class="line">np.cumsum(arr, axis=<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<pre><code>array([[0.77395605, 1.21283449, 2.07143241, 2.76880044],
       [0.09417735, 1.0697997 , 1.8309394 , 2.61700371],
       [0.12811363, 0.57849957, 0.94929759, 1.87606258]])</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 标准差，用法类似</span></span><br><span class="line">np.std(arr)</span><br></pre></td></tr></table></figure>
<pre><code>0.28783096517727075</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 按列求标准差</span></span><br><span class="line">np.std(arr, axis=<span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<pre><code>array([0.3127589 , 0.25035525, 0.21076935, 0.09444968])</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 方差</span></span><br><span class="line">np.var(arr, axis=<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<pre><code>array([0.02464271, 0.1114405 , 0.0839356 ])</code></pre>
<h2 id="形状和转换">形状和转换</h2>
<p>array 大多数情况下都是以多维的形式出现的，一般对超过二维的多维 array 称为「张量」，二维矩阵，一维向量。因为多维度，所以自然而然地涉及到形状的改变和转换，可以算是张量最基础的「操作」了。</p>
<p>本节我们主要涉及以下三个方面：</p>
<ul>
<li>改变形状</li>
<li>反序</li>
<li>转置</li>
</ul>
<p>其中，改变形状和转置都非常常用，我们建议您熟练掌握。</p>
<h3 id="改变形状">改变形状</h3>
<p>⭐⭐⭐⭐⭐</p>
<p>这小节里面的 API 使用非常高频，尤其是扩展 1 维度的 <code>expand_dims</code> 和去除 1 维度的 <code>squeeze</code>，您未来会在很多神经网络架构中看到这俩货的身影。</p>
<p>⚠️ 需要注意的是：无论是扩展还是缩减，多或少的 shape 都是 1，<code>squeeze</code> 时如果指定维度，则该维度 shape 必须是 1。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 换个整数的随机 array</span></span><br><span class="line">rng = np.random.default_rng(seed=<span class="number">42</span>)</span><br><span class="line">arr = rng.integers(<span class="number">1</span>, <span class="number">100</span>, (<span class="number">3</span>, <span class="number">4</span>, <span class="number">2</span>))</span><br><span class="line"><span class="built_in">print</span>(arr)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;arr[0]&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(arr[<span class="number">0</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;arr[:, 0]&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(arr[:, <span class="number">0</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;arr[:, :, 0]&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(arr[:, :, <span class="number">0</span>])</span><br></pre></td></tr></table></figure>
<pre><code>[[[ 9 77]
  [65 44]
  [43 86]
  [ 9 70]]

 [[20 10]
  [53 97]
  [73 76]
  [72 78]]

 [[51 13]
  [84 45]
  [50 37]
  [19 92]]]
arr[0]
[[ 9 77]
 [65 44]
 [43 86]
 [ 9 70]]
arr[:, 0]
[[ 9 77]
 [20 10]
 [51 13]]
arr[:, :, 0]
[[ 9 65 43  9]
 [20 53 73 72]
 [51 84 50 19]]</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 有时候您可能需要将多维 array 打平</span></span><br><span class="line">arr = arr.ravel()</span><br><span class="line"><span class="built_in">print</span>(arr)</span><br><span class="line"><span class="built_in">print</span>(arr.shape)</span><br></pre></td></tr></table></figure>
<pre><code>[ 9 77 65 44 43 86  9 70 20 10 53 97 73 76 72 78 51 13 84 45 50 37 19 92]
(24,)</code></pre>
<h4 id="np.expand_dims"><code>np.expand_dims</code></h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#### 扩展 1 个维度，需要（必须）指定维度</span></span><br><span class="line"><span class="comment"># 其实就是多嵌套了一下</span></span><br><span class="line">arr = rng.integers(<span class="number">1</span>, <span class="number">100</span>, (<span class="number">3</span>, <span class="number">4</span>))</span><br><span class="line"><span class="built_in">print</span>(arr)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;----------------------------------------------------&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(arr[<span class="number">0</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;----------------------------------------------------&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(arr[:, <span class="number">0</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;----------------------------------------------------&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(arr.shape)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;----------------------------------------------------&quot;</span>)</span><br><span class="line">arr = np.expand_dims(arr, <span class="number">0</span>)</span><br><span class="line"><span class="built_in">print</span>(arr.shape)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;----------------------------------------------------&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(arr[<span class="number">0</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;----------------------------------------------------&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(arr[:, <span class="number">0</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;----------------------------------------------------&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(arr)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;----------------------------------------------------&quot;</span>)</span><br></pre></td></tr></table></figure>
<pre><code>[[92 74 37 96]
 [41 33 90 37]
 [ 8 47 79 19]]
----------------------------------------------------
[92 74 37 96]
----------------------------------------------------
[92 41  8]
----------------------------------------------------
(3, 4)
----------------------------------------------------
(1, 3, 4)
----------------------------------------------------
[[92 74 37 96]
 [41 33 90 37]
 [ 8 47 79 19]]
----------------------------------------------------
[[92 74 37 96]]
----------------------------------------------------
[[[92 74 37 96]
  [41 33 90 37]
  [ 8 47 79 19]]]
----------------------------------------------------</code></pre>
<h1 id="通用函数">通用函数</h1>
<p>到目前为止，我们讨论了 NumPy 的一些基础知识。在接下来的几小节中，我们将深入了解 NumPy 在 Python 数据科学世界中如此重要的原因。明确点说，NumPy 提供了一个简单灵活的接口来优化数据数组的计算。</p>
<p>NumPy 数组的计算有时非常快，有时也非常慢。使 NumPy 变快的关键是利用向量化操作，通常在 NumPy 的通用函数（ufunc）中实现。本节将介绍 NumPy 通用函数的重要性——它可以提高数组元素的重复计算的效率；然后，将会介绍很多 NumPy 包中常用且有用的数学通用函数。</p>
<p>我们再回顾下之前求倒数的例子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">np.random.seed(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">compute_reciprocals</span>(<span class="params">values</span>):</span></span><br><span class="line">    output = np.empty(<span class="built_in">len</span>(values))</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(values)):</span><br><span class="line">        output[i] = <span class="number">1.0</span> / values[i]</span><br><span class="line">    <span class="keyword">return</span> output</span><br><span class="line"></span><br><span class="line">values = np.random.randint(<span class="number">1</span>, <span class="number">10</span>, size=<span class="number">5</span>)</span><br><span class="line">compute_reciprocals(values)</span><br></pre></td></tr></table></figure>
<pre><code>array([0.16666667, 1.        , 0.25      , 0.25      , 0.125     ])</code></pre>
<p>NumPy 为很多类型的操作提供了非常方便的、静态类型的、可编译程序的接口，也被称作向量操作。你可以通过简单地对数组执行操作来实现，这里对数组的操作将会被用于数组中的每一个元素。这种向量方法被用于将循环推送至 NumPy 之下的编译层，这样会取得更快的执行效率。</p>
<p>比较如下结果：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(compute_reciprocals(values))</span><br><span class="line"><span class="built_in">print</span>(<span class="number">1.0</span> / values)</span><br></pre></td></tr></table></figure>
<pre><code>[0.16666667 1.         0.25       0.25       0.125     ]
[0.16666667 1.         0.25       0.25       0.125     ]</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">big_array = np.random.randint(<span class="number">1</span>, <span class="number">100</span>, size=<span class="number">1000000</span>)</span><br><span class="line">%timeit compute_reciprocals(big_array)</span><br><span class="line">%timeit (<span class="number">1.0</span> / big_array)</span><br></pre></td></tr></table></figure>
<pre><code>1.86 s ± 49.2 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)
694 µs ± 174 µs per loop (mean ± std. dev. of 7 runs, 1,000 loops each)</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">%time compute_reciprocals(big_array)</span><br><span class="line">%time (<span class="number">1.0</span> / big_array)</span><br></pre></td></tr></table></figure>
<pre><code>CPU times: user 1.83 s, sys: 11.7 ms, total: 1.85 s
Wall time: 1.85 s
CPU times: user 812 µs, sys: 145 µs, total: 957 µs
Wall time: 676 µs





array([0.1       , 0.01190476, 0.04545455, ..., 0.01428571, 0.01098901,
       0.01149425])</code></pre>
<p>NumPy 中的向量操作是通过通用函数实现的。通用函数的主要目的是对 NumPy 数组中的值执行更快的重复操作。它非常灵活，前面我们看过了标量和数组的运算，但是也可以对两个数组进行运算：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">np.arange(<span class="number">5</span>) / np.arange(<span class="number">1</span>, <span class="number">6</span>)</span><br></pre></td></tr></table></figure>
<pre><code>array([0.        , 0.5       , 0.66666667, 0.75      , 0.8       ])</code></pre>
<p>通用函数并不仅限于一维数组的运算，它们也可以进行多维数组的运算：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = np.arange(<span class="number">9</span>).reshape((<span class="number">3</span>, <span class="number">3</span>))</span><br><span class="line"><span class="number">2</span> ** x</span><br></pre></td></tr></table></figure>
<pre><code>array([[  1,   2,   4],
       [  8,  16,  32],
       [ 64, 128, 256]])</code></pre>
<p>通过通用函数用向量的方式进行计算几乎总比用 Python 循环实现的计算更加有效，尤其是当数组很大时。只要你看到 Python 脚本中有这样的循环，就应该考虑能否用向量方式替换这个循环。</p>
<p>给出一些例子，具体的请查阅相关资料：</p>
$$
<span class="math display">\[\begin{array}{lll}

\end{array}\]</span>
<p><span class="math display">\[
\]</span> <span class="math display">\[\begin{equation}

\begin{array}{lll}
\hline \text { 运算符 } &amp; \text { 对应的通用函数 } &amp; \text { 描述 } \\
\hline+ &amp; n p . a d d &amp; \text { 加法运算 }(\text { 即 } 1+1=2) \\
- &amp; n p . \text { subtract } &amp; \text { 减法运算 }(\text { 即 } 3-2=1) \\
- &amp; \text { np.negative } &amp; \text { 负数运算 }(\text { 即 }-2) \\

* &amp; \text { np.multiply } &amp; \text { 乘法运算 }(\text { 即 } 2 * 3=6) \\

/ &amp; \text { np.divide } &amp; \text { 除法运算 }(\text { 即 } 3 / 2=1.5) \\

/ / &amp; \text { np.floor}\text {divide } &amp; \text { 地板除法运算 (floor division，即 } 3 / / 2=1) \\

\text { ** } &amp; \text { np.power } &amp; \text { 指数运算 }(\text { 即 } 2 * * 3=8) \\

\% &amp; \text { np.mod } &amp; \text { 模 / 余数 }(\text { 即 } 9 \% 4=1) \\

\hline

\end{array}

\end{equation}\]</span> $$</p>
<p>专用的通用函数 除了以上介绍到的，NumPy 还提供了很多通用函数，包括双曲三角函数、比特位运算、比较运算符、弧度转化为角度的运算、取整和求余运算，等等。浏览 NumPy 的文档将会揭示很多有趣的功能。</p>
<p>还有一个更加专用，也更加晦涩的通用函数优异来源是子模块 scipy.special。如果你希望对你的数据进行一些更晦涩的数学计算，scipy.special 可能包含了你需要的计算函数。</p>
<p>这些函数能列一个长长的列表，下面的代码片段展示了一些可能在统计学中用到的函数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> scipy <span class="keyword">import</span> special</span><br><span class="line"><span class="comment"># Gamma函数（广义阶乘，generalized factorials）和相关函数</span></span><br><span class="line">x = [<span class="number">1</span>, <span class="number">5</span>, <span class="number">10</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;gamma(x) =&quot;</span>, special.gamma(x))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;ln|gamma(x)| =&quot;</span>, special.gammaln(x))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;beta(x, 2) =&quot;</span>, special.beta(x, <span class="number">2</span>))</span><br><span class="line"> <span class="comment"># 误差函数（高斯积分）</span></span><br><span class="line"> <span class="comment"># 它的实现和它的逆实现</span></span><br><span class="line">x = np.array([<span class="number">0</span>, <span class="number">0.3</span>, <span class="number">0.7</span>, <span class="number">1.0</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;erf(x) =&quot;</span>, special.erf(x))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;erfc(x) =&quot;</span>, special.erfc(x))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;erfinv(x) =&quot;</span>, special.erfinv(x))</span><br></pre></td></tr></table></figure>
<pre><code>gamma(x) = [1.0000e+00 2.4000e+01 3.6288e+05]
ln|gamma(x)| = [ 0.          3.17805383 12.80182748]
beta(x, 2) = [0.5        0.03333333 0.00909091]
erf(x) = [0.         0.32862676 0.67780119 0.84270079]
erfc(x) = [1.         0.67137324 0.32219881 0.15729921]
erfinv(x) = [0.         0.27246271 0.73286908        inf]</code></pre>
<p>NumPy 和 scipy.special 中提供了大量的通用函数，这些包的文档在网上就可以查到，搜索“gamma function python”即可。</p>
<h2 id="高级的通用函数特性">高级的通用函数特性</h2>
<ol type="1">
<li>指定输出</li>
</ol>
<p>在进行大量运算时，有时候指定一个用于存放运算结果的数组是非常有用的。不同于创建临时数组，你可以用这个特性将计算结果直接写入到你期望的存储位置。所有的通用函数都可以通过 out 参数来指定计算结果的存放位置：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = np.arange(<span class="number">5</span>)</span><br><span class="line">y = np.empty(<span class="number">5</span>)</span><br><span class="line">np.multiply(x, <span class="number">10</span>, out=y) </span><br><span class="line"><span class="built_in">print</span>(y)</span><br></pre></td></tr></table></figure>
<pre><code>[ 0. 10. 20. 30. 40.]</code></pre>
<p>这个特性也可以被用作数组视图，例如可以将计算结果写入指定数组的每隔一个元素的位置：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">y = np.zeros(<span class="number">10</span>)</span><br><span class="line">np.power(<span class="number">2</span>, x, out=y[::<span class="number">2</span>])</span><br><span class="line"><span class="built_in">print</span>(y)</span><br></pre></td></tr></table></figure>
<pre><code>[ 1.  0.  2.  0.  4.  0.  8.  0. 16.  0.]</code></pre>
<p>如果这里写的是 y[::2] = 2 ** x，那么结果将是创建一个临时数组，该数组存放的是2 ** x 的结果，并且接下来会将这些值复制到 y 数组中。对于上述例子中比较小的计算量来说，这两种方式的差别并不大。但是对于较大的数组，通过慎重使用 out 参数将能够有效节约内存。</p>
<p>2.聚合</p>
<p>二元通用函数有些非常有趣的聚合功能，这些聚合可以直接在对象上计算。例如，如果我们希望用一个特定的运算 reduce 一个数组，那么可以用任何通用函数的 reduce 方法。一个 reduce 方法会对给定的元素和操作重复执行，直至得到单个的结果。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = np.arange(<span class="number">1</span>, <span class="number">6</span>)</span><br><span class="line"><span class="built_in">print</span>(np.add.reduce(x))</span><br><span class="line"><span class="built_in">print</span>(np.add.accumulate(x))</span><br></pre></td></tr></table></figure>
<pre><code>15
[ 1  3  6 10 15]</code></pre>
<ol start="3" type="1">
<li>外积</li>
</ol>
<p>有点类似张亮积。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = np.arange(<span class="number">1</span>, <span class="number">6</span>)</span><br><span class="line">np.multiply.outer(x, x)</span><br></pre></td></tr></table></figure>
<pre><code>array([[ 1,  2,  3,  4,  5],
       [ 2,  4,  6,  8, 10],
       [ 3,  6,  9, 12, 15],
       [ 4,  8, 12, 16, 20],
       [ 5, 10, 15, 20, 25]])</code></pre>
<h2 id="广播机制">广播机制</h2>
<p>我们在前一节中介绍了 NumPy 如何通过通用函数的向量化操作来减少缓慢的 Python 循环，另外一种向量化操作的方法是利用 NumPy 的广播功能。广播可以简单理解为用于不同大小数组的二进制通用函数（加、减、乘等）的一组规则。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = np.array([<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>])</span><br><span class="line">b = np.array([<span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>])</span><br><span class="line">a + b</span><br></pre></td></tr></table></figure>
<pre><code>array([5, 6, 7])</code></pre>
<p>还可以自动扩充计算</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = np.arange(<span class="number">3</span>)</span><br><span class="line">b = np.arange(<span class="number">3</span>)[:, np.newaxis]</span><br><span class="line">a + b</span><br></pre></td></tr></table></figure>
<pre><code>array([[0, 1, 2],
       [1, 2, 3],
       [2, 3, 4]])</code></pre>
<h2 id="规则">规则！</h2>
<p>NumPy 的广播遵循一组严格的规则，设定这组规则是为了决定两个数组间的操作。</p>
<ul>
<li><p>规则 1：如果两个数组的维度数不相同，那么小维度数组的形状将会在最左边补 1</p></li>
<li><p>规则 2：如果两个数组的形状在任何一个维度上都不匹配，那么数组的形状会沿着维度为 1 的维度扩展以匹配另外一个数组的形状</p></li>
<li><p>规则 3：如果两个数组的形状在任何一个维度上都不匹配并且没有任何一个维度等于 1，那么会引发异常</p></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = np.arange(<span class="number">3</span>).reshape((<span class="number">3</span>, <span class="number">1</span>))</span><br><span class="line">b = np.arange(<span class="number">3</span>)</span><br><span class="line">a + b</span><br></pre></td></tr></table></figure>
<pre><code>array([[0, 1, 2],
       [1, 2, 3],
       [2, 3, 4]])</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">M = np.ones((<span class="number">3</span>, <span class="number">2</span>))</span><br><span class="line">a = np.arange(<span class="number">3</span>)</span><br><span class="line">M + a</span><br></pre></td></tr></table></figure>
<pre><code>---------------------------------------------------------------------------

ValueError                                Traceback (most recent call last)

/Users/zhaochen20/Desktop/Python 科学计算.ipynb Cell 126 in &lt;cell line: 3&gt;()
      &lt;a href=&#39;vscode-notebook-cell:/Users/zhaochen20/Desktop/Python%20%E7%A7%91%E5%AD%A6%E8%AE%A1%E7%AE%97.ipynb#ch0000140?line=0&#39;&gt;1&lt;/a&gt; M = np.ones((3, 2))
      &lt;a href=&#39;vscode-notebook-cell:/Users/zhaochen20/Desktop/Python%20%E7%A7%91%E5%AD%A6%E8%AE%A1%E7%AE%97.ipynb#ch0000140?line=1&#39;&gt;2&lt;/a&gt; a = np.arange(3)
----&gt; &lt;a href=&#39;vscode-notebook-cell:/Users/zhaochen20/Desktop/Python%20%E7%A7%91%E5%AD%A6%E8%AE%A1%E7%AE%97.ipynb#ch0000140?line=2&#39;&gt;3&lt;/a&gt; M + a


ValueError: operands could not be broadcast together with shapes (3,2) (3,) </code></pre>
<h2 id="广播的实际运用">广播的实际运用</h2>
<ol type="1">
<li>数组的归一化</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">X = np.random.random((<span class="number">10</span>, <span class="number">3</span>))</span><br><span class="line">Xmean = X.mean(axis=<span class="number">0</span>)</span><br><span class="line">X_centered = X - Xmean</span><br><span class="line">X_centered.mean(axis=<span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<pre><code>array([-9.99200722e-17,  3.33066907e-17,  0.00000000e+00])</code></pre>
<p>在机器精度范围内，该均值为 0。</p>
<ol start="2" type="1">
<li>绘制二维函数</li>
</ol>
<p>广播另外一个非常有用的地方在于，它能基于二维函数显示图像。比如我们希望定义一个函数 <span class="math inline">\(z = f (x, y)\)</span>，可以用广播沿着数值区间计算该函数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line">x = np.linspace(<span class="number">0</span>, <span class="number">5</span>, <span class="number">50</span>)</span><br><span class="line">y = np.linspace(<span class="number">0</span>, <span class="number">5</span>, <span class="number">50</span>)[:, np.newaxis]</span><br><span class="line">z = np.sin(x) ** <span class="number">10</span> + np.cos(<span class="number">10</span> + y * x) * np.cos(x)</span><br><span class="line">plt.imshow(z, extent=[<span class="number">0</span>, <span class="number">5</span>, <span class="number">0</span>, <span class="number">5</span>], cmap=<span class="string">&#x27;viridis&#x27;</span>)</span><br><span class="line">plt.colorbar()</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p>​<br />
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="output_140_0.png" alt="png" /> ​</p>
<h3 id="反序">反序</h3>
<p>⭐</p>
<p>也可以看作是一种对原数组的转换，用的不多，可以了解一下，为接下来的索引和切片做个热身。</p>
<p>如果给一个字符串或数组让您反序，您可能会想到很多种方法，比如：<code>reversed</code>，或者写一个方法，或者用 Python list 的索引功能，而这也是 <code>numpy</code> 中 array 反序的方式。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 字符串</span></span><br><span class="line">s = <span class="string">&quot;uevol&quot;</span></span><br><span class="line">s[::-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<pre><code>&#39;loveu&#39;</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 数组</span></span><br><span class="line">lst = [<span class="number">1</span>, <span class="string">&quot;1&quot;</span>, <span class="number">5.2</span>]</span><br><span class="line">lst[::-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<pre><code>[5.2, &#39;1&#39;, 1]</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">arr = np.random.randint(<span class="number">1</span>, <span class="number">100</span>, (<span class="number">3</span>, <span class="number">4</span>))</span><br><span class="line"><span class="built_in">print</span>(arr)</span><br></pre></td></tr></table></figure>
<pre><code>[[49 81 30 11]
 [54 17 22 45]
 [34  5 40  9]]</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 我们按上面的套路：默认列反序</span></span><br><span class="line">arr[::-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<pre><code>array([[34,  5, 40,  9],
       [54, 17, 22, 45],
       [49, 81, 30, 11]])</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 列不变行反序</span></span><br><span class="line">arr[::-<span class="number">1</span>, :]</span><br></pre></td></tr></table></figure>
<pre><code>array([[34,  5, 40,  9],
       [54, 17, 22, 45],
       [49, 81, 30, 11]])</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 在不同维度上操作：行不变列反序</span></span><br><span class="line">arr[:, ::-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<pre><code>array([[11, 30, 81, 49],
       [45, 22, 17, 54],
       [ 9, 40,  5, 34]])</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 行变列也变</span></span><br><span class="line">arr[::-<span class="number">1</span>, ::-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<pre><code>array([[ 9, 40,  5, 34],
       [45, 22, 17, 54],
       [11, 30, 81, 49]])</code></pre>
<h3 id="转置">转置</h3>
<p>⭐⭐⭐</p>
<p>转置是线性代数的基本操作，拿二维矩阵为例，通俗理解就是把它放倒，shape 反转，行变成列，列成为行。当然，对于多维也是类似的，需要里理解他们的数学意义，这里不做展开。我们建议您二维矩阵用 <code>arr.T</code>（会快很多），超过二维的张量可以用 <code>np.transpose</code>，会更加灵活些。</p>
<p>⚠️ 需要注意的是：一维数组转置还是自己。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 一维</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;----------------------------------------------------&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(np.array([[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]]))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;----------------------------------------------------&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(np.array([[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]]).shape)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;----------------------------------------------------&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(np.array([[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]]).T)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;----------------------------------------------------&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(np.array([[<span class="number">1</span>,<span class="number">2</span>, <span class="number">3</span>]]).T.shape)</span><br></pre></td></tr></table></figure>
<pre><code>[[1 2 3]]
(1, 3)
[[1]
 [2]
 [3]]
(3, 1)</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 简便用法，把所有维度顺序都给倒过来</span></span><br><span class="line">rng = np.random.default_rng(seed=<span class="number">42</span>)</span><br><span class="line">arr = rng.integers(<span class="number">1</span>, <span class="number">100</span>, (<span class="number">3</span>, <span class="number">4</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;----------------------------------------------------&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(arr)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;----------------------------------------------------&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(arr.shape)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;----------------------------------------------------&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(arr.T)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;----------------------------------------------------&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(arr.T.shape)</span><br></pre></td></tr></table></figure>
<pre><code>----------------------------------------------------
[[ 9 77 65 44]
 [43 86  9 70]
 [20 10 53 97]]
----------------------------------------------------
(3, 4)
----------------------------------------------------
[[ 9 43 20]
 [77 86 10]
 [65  9 53]
 [44 70 97]]
----------------------------------------------------
(4, 3)</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 将 shape=(1,1,3,4) 的转置后得到 shape=(4,3,1,1)</span></span><br><span class="line">arr.reshape(<span class="number">1</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>).T.shape</span><br></pre></td></tr></table></figure>
<pre><code>(4, 3, 1, 1)</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 同上</span></span><br><span class="line">arr.reshape(<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">1</span>).T.shape</span><br></pre></td></tr></table></figure>
<pre><code>(1, 3, 1, 2, 2, 1)</code></pre>
<h4 id="np.transpose"><code>np.transpose</code></h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 这种转置方式可以指定 axes</span></span><br><span class="line">np.transpose(arr)</span><br></pre></td></tr></table></figure>
<pre><code>array([[ 9, 43, 20],
       [77, 86, 10],
       [65,  9, 53],
       [44, 70, 97]])</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 不指定 axes 时和 .T 是一样的</span></span><br><span class="line">np.transpose(arr.reshape(<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">1</span>)).shape</span><br></pre></td></tr></table></figure>
<pre><code>(1, 3, 1, 2, 2, 1)</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 指定 axes，不过 axes 数量必须包含所有维度的序列</span></span><br><span class="line"><span class="comment"># 比如两个维度就是 (0, 1)，四个就是 (0, 1, 2, 3)</span></span><br><span class="line"><span class="comment"># 当然，顺序可以改变，比如下面就是只转置第 2 个和第 3 个维度</span></span><br><span class="line"><span class="comment"># 注意，只有超过 2 维时，这样才有意义</span></span><br><span class="line"><span class="comment"># 下面的结果中，中间2个维度被调换顺序了，顺序就在axes中指定的</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;----------------------------------------------------&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(arr.reshape(<span class="number">1</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;----------------------------------------------------&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(arr.reshape(<span class="number">1</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>).shape)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;----------------------------------------------------&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(np.transpose(arr.reshape(<span class="number">1</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>), (<span class="number">0</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>)))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;----------------------------------------------------&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(np.transpose(arr.reshape(<span class="number">1</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>), axes=(<span class="number">0</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>)).shape)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;----------------------------------------------------&quot;</span>)</span><br></pre></td></tr></table></figure>
<pre><code>----------------------------------------------------
[[[[ 9 77 65 44]
   [43 86  9 70]
   [20 10 53 97]]]]
----------------------------------------------------
(1, 1, 3, 4)
----------------------------------------------------
[[[[ 9 77 65 44]]

  [[43 86  9 70]]

  [[20 10 53 97]]]]
----------------------------------------------------
(1, 3, 1, 4)
----------------------------------------------------</code></pre>
<h2 id="分解和组合">分解和组合</h2>
<p>这节我们主要学习 array 的分解和组合，本节是所有章节中最重要的一节，通过本节内容，您可以充分了解 <code>numpy</code>（以及 Python 语言）的强大，这种操作上的优雅不能说后无来者，但至少前无古人了。</p>
<p>内容大致包括以下小节：</p>
<ul>
<li>切片和索引</li>
<li>拼接</li>
<li>重复</li>
<li>分拆</li>
</ul>
<p>其中，重中之重是「切片和索引」，它基础、它高频、它无处不在。我们强烈建议您熟练掌握，其他三个相对简单，只需要各记住一个 API 即可。</p>
<h3 id="切片和索引">切片和索引</h3>
<p>⭐⭐⭐⭐⭐</p>
<p>划重点！切片和索引是通过对已有 array 进行操作而得到想要的「部分」元素的行为过程。其核心动作可以概括为：按维度根据 <code>start:stop:step</code> 操作 array。</p>
<p>这部分内容的核心是把处理按维度分开，不处理的维度统一用 <code>:</code> 或 <code>...</code> 代替；在看操作时，也要首先关注「<code>,</code>」在哪里。要处理的维度和之前 <code>arange</code> <code>linspace</code> 等接口使用方法是一样的。</p>
<p>⚠️ 需要注意的是：引支持负数，即从后往前索引。</p>
<p>传统的索引前面其实有讲过不少，可以自行参考 list 的切片和索引。在传统的索引上，我需要重点强调下这个话题：</p>
<blockquote>
<p>关于数组切片有一点很重要非常有用，那就是数组切片返回的是数组数据的视图(也可以理解成引用)，而不是数值数据的副本。这一点也是 NumPy 数组切片和 Python 列表切片的不同之处。在 Python 列表中，切片是值的副本。具体可以查看下方例子：</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">rng = np.random.default_rng(seed=<span class="number">42</span>)</span><br><span class="line">x2 = rng.integers(<span class="number">10</span>, size=(<span class="number">3</span>, <span class="number">4</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;----------------------------------------------------&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(x2)</span><br><span class="line">x3 = x2[<span class="number">0</span>]</span><br><span class="line">x4 = x2[:, <span class="number">0</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;----------------------------------------------------&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;__slice__&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;----------------------------------------------------&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(x3)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;----------------------------------------------------&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(x4)</span><br><span class="line">x3[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;----------------------------------------------------&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;__change the line__&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;----------------------------------------------------&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(x2)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;----------------------------------------------------&quot;</span>)</span><br><span class="line">x4[<span class="number">2</span>] = <span class="number">10</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;__change the column__&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;----------------------------------------------------&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(x2)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;----------------------------------------------------&quot;</span>)</span><br></pre></td></tr></table></figure>
<pre><code>----------------------------------------------------
[[0 7 6 4]
 [4 8 0 6]
 [2 0 5 9]]
----------------------------------------------------
__slice__
----------------------------------------------------
[0 7 6 4]
----------------------------------------------------
[0 4 2]
----------------------------------------------------
__change the line__
----------------------------------------------------
[[1 7 6 4]
 [4 8 0 6]
 [2 0 5 9]]
----------------------------------------------------
__change the column__
----------------------------------------------------
[[ 1  7  6  4]
 [ 4  8  0  6]
 [10  0  5  9]]
----------------------------------------------------</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">lecturer_list = [<span class="string">&quot;c7w&quot;</span>, <span class="string">&quot;lambda&quot;</span>, <span class="string">&quot;Alan&quot;</span>, <span class="string">&quot;xsun2001&quot;</span>, <span class="string">&quot;ayf&quot;</span>]</span><br><span class="line">bachelordom_list = lecturer_list[:-<span class="number">2</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;----------------------------------------------------&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(bachelordom_list)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;----------------------------------------------------&quot;</span>)</span><br><span class="line">bachelordom_list[-<span class="number">1</span>] = <span class="string">&quot;Eren&quot;</span></span><br><span class="line"><span class="built_in">print</span>(bachelordom_list)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;----------------------------------------------------&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(lecturer_list)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;----------------------------------------------------&quot;</span>)</span><br></pre></td></tr></table></figure>
<pre><code>----------------------------------------------------
[&#39;c7w&#39;, &#39;lambda&#39;, &#39;Alan&#39;]
----------------------------------------------------
[&#39;c7w&#39;, &#39;lambda&#39;, &#39;Eren&#39;]
----------------------------------------------------
[&#39;c7w&#39;, &#39;lambda&#39;, &#39;Alan&#39;, &#39;xsun2001&#39;, &#39;ayf&#39;]
----------------------------------------------------</code></pre>
<h3 id="fancy-indexing">Fancy Indexing</h3>
<p>你应该知道如何利用简单的索引值（如 arr[0]）、切片（如 arr[:5]）获得并修改部分数组。在这一节中，我们将介绍另外一种数组索引，也称作花哨的索引（fancy indexing）。花哨的索引和前面那些简单的索引非常类似，但是传递的是索引数组，而不是单个标量。花哨的索引让我们能够快速获得并修改复杂的数组值的子数据集。</p>
<h4 id="操作布尔数组">操作布尔数组</h4>
<p>之前介绍了通用函数，并且特别关注了算术运算符。我们看到用 +、-、*、/ 和其他一些运算符实现了数组的逐元素操作。NumPy 还实现了如 &lt;（小于）和 &gt;（大于）的逐元素比较的通用函数。这些比较运算的结果是一个布尔数据类型的数组。一共有 6 种标准的比较操作：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = np.array([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>])</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x &lt; <span class="number">3</span>  <span class="comment"># less than</span></span><br></pre></td></tr></table></figure>
<pre><code>array([ True,  True, False, False, False])</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x &gt; <span class="number">3</span>  <span class="comment"># greater than</span></span><br></pre></td></tr></table></figure>
<pre><code>array([False, False, False,  True,  True])</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x &lt;= <span class="number">3</span>  <span class="comment"># less than or equal</span></span><br></pre></td></tr></table></figure>
<pre><code>array([ True,  True,  True, False, False])</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x &gt;= <span class="number">3</span>  <span class="comment"># greater than or equal</span></span><br></pre></td></tr></table></figure>
<pre><code>array([False, False,  True,  True,  True])</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x != <span class="number">3</span>  <span class="comment"># not equal</span></span><br></pre></td></tr></table></figure>
<pre><code>array([ True,  True, False,  True,  True])</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x == <span class="number">3</span>  <span class="comment"># equal</span></span><br></pre></td></tr></table></figure>
<pre><code>array([False, False,  True, False, False])</code></pre>
<p>和算术运算通用函数一样，这些比较运算通用函数也可以用于任意形状、大小的数组。给定一个布尔数组，你可以实现很多有用的操作。首先打印出二维数组 x：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">rng = np.random.RandomState(<span class="number">0</span>)</span><br><span class="line">x = rng.randint(<span class="number">10</span>, size=(<span class="number">3</span>, <span class="number">4</span>))</span><br><span class="line">x</span><br></pre></td></tr></table></figure>
<pre><code>array([[5, 0, 3, 3],
       [7, 9, 3, 5],
       [2, 4, 7, 6]])</code></pre>
<p>你当然可以直接对布尔数组进行聚合计算，这里不再赘述，然而我们讨论更强大的工具——</p>
<p>用布尔数组作为掩码，通过该掩码选择数据的子数据集。以前面小节用过的 x 数组为例，假设我们希望抽取出数组中所有小于 5 的元素：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x[x &lt; <span class="number">5</span>]</span><br></pre></td></tr></table></figure>
<pre><code>array([0, 3, 3, 3, 2, 4])</code></pre>
<p>现在返回的是一个一维数组，它包含了所有满足条件的值。换句话说，所有的这些值是掩码数组对应位置为 True 的值。</p>
<p>通过将布尔操作、掩码操作和聚合结合，可以快速查看数据集内的数据属性。</p>
<h4 id="探索花哨的索引">探索花哨的索引</h4>
<p>花哨的索引在概念上非常简单，它意味着传递一个索引数组来一次性获得多个数组元素。</p>
<p>例如以下数组：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">rand = np.random.RandomState(<span class="number">42</span>)</span><br><span class="line"></span><br><span class="line">x = rand.randint(<span class="number">100</span>, size=<span class="number">10</span>)</span><br><span class="line"><span class="built_in">print</span>(x)</span><br></pre></td></tr></table></figure>
<pre><code>[51 92 14 71 60 20 82 86 74 74]</code></pre>
<p>假设我们希望获得三个不同的元素，可以用以下方式实现：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[x[<span class="number">3</span>], x[<span class="number">7</span>], x[<span class="number">2</span>]]</span><br></pre></td></tr></table></figure>
<pre><code>[71, 86, 14]</code></pre>
<p>利用花哨的索引，结果的形状与索引数组的形状一致，而不是与被索引数组的形状一致：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ind = np.array([[<span class="number">3</span>, <span class="number">7</span>],</span><br><span class="line">                [<span class="number">4</span>, <span class="number">5</span>]])</span><br><span class="line">x[ind]</span><br></pre></td></tr></table></figure>
<pre><code>array([[71, 86],
       [60, 20]])</code></pre>
<p>花哨的索引也对多个维度适用。假设我们有以下数组：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">X = np.arange(<span class="number">12</span>).reshape((<span class="number">3</span>, <span class="number">4</span>))</span><br><span class="line">X</span><br></pre></td></tr></table></figure>
<pre><code>array([[ 0,  1,  2,  3],
       [ 4,  5,  6,  7],
       [ 8,  9, 10, 11]])</code></pre>
<p>和标准的索引方式一样，第一个索引指的是行，第二个索引指的是列：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">row = np.array([<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>])</span><br><span class="line">col = np.array([<span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>])</span><br><span class="line">X[row, col]</span><br></pre></td></tr></table></figure>
<pre><code>array([ 2,  5, 11])</code></pre>
<p>另外一种方法是通过传递索引的单个列表或数组来获得同样的结果：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ind = [<span class="number">3</span>, <span class="number">7</span>, <span class="number">4</span>]</span><br><span class="line">x[ind]</span><br></pre></td></tr></table></figure>
<pre><code>array([71, 86, 60])</code></pre>
<p>这里需要注意，结果的第一个值是 X[0, 2]，第二个值是 X[1, 1]，第三个值是 X[2, 3]在花哨的索引中，索引值的配对遵循介绍过的广播的规则。因此当我们将一个列向量和一个行向量组合在一个索引中时，会得到一个二维的结果：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">X[row[:, np.newaxis], col]</span><br></pre></td></tr></table></figure>
<pre><code>array([[ 2,  1,  3],
       [ 6,  5,  7],
       [10,  9, 11]])</code></pre>
<p>这里，每一行的值都与每一列的向量配对，正如我们看到的广播的算术运算：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">row[:, np.newaxis] * col</span><br></pre></td></tr></table></figure>
<pre><code>array([[0, 0, 0],
       [2, 1, 3],
       [4, 2, 6]])</code></pre>
<p>这里特别需要记住的是，花哨的索引返回的值反映的是广播后的索引数组的形状，而不是被索引的数组的形状。</p>
<h4 id="组合索引">组合索引</h4>
<p>花哨的索引可以和其他索引方案结合起来形成更强大的索引操作：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(X)</span><br></pre></td></tr></table></figure>
<pre><code>[[ 0  1  2  3]
 [ 4  5  6  7]
 [ 8  9 10 11]]</code></pre>
<p>可以将花哨的索引和简单的索引组合使用：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">X[<span class="number">2</span>, [<span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>]]</span><br></pre></td></tr></table></figure>
<pre><code>array([10,  8,  9])</code></pre>
<p>也可以将花哨的索引和切片组合使用：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">X[<span class="number">1</span>:, [<span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>]]</span><br></pre></td></tr></table></figure>
<pre><code>array([[ 6,  4,  5],
       [10,  8,  9]])</code></pre>
<p>更可以将花哨的索引和掩码组合使用：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">mask = np.array([<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>], dtype=<span class="built_in">bool</span>)</span><br><span class="line">X[row[:, np.newaxis], mask]</span><br></pre></td></tr></table></figure>
<pre><code>array([[ 0,  2],
       [ 4,  6],
       [ 8, 10]])</code></pre>
<p>索引选项的组合可以实现非常灵活的获取和修改数组元素的操作</p>
<h3 id="拼接">拼接</h3>
<p>⭐⭐⭐⭐</p>
<p>有时候我们需要对已有的几个 array 进行拼接以形成一个大的 array（常见的例子比如不同类型特征的拼接）。本小节严格来说只有两个 API：<code>np.concatenate</code> 和 <code>np.stack</code>，前者是拼接，后者是堆叠（会增加一个维度），都可以指定维度。记住，有它俩就够了。</p>
<p>⚠️ 需要注意的是：<code>hstack</code> 和 <code>vstack</code> 和 <code>stack</code> 没关系。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">rng = np.random.default_rng(<span class="number">42</span>)</span><br><span class="line"></span><br><span class="line">arr1 = rng.random((<span class="number">2</span>, <span class="number">3</span>))</span><br><span class="line">arr2 = rng.random((<span class="number">2</span>, <span class="number">3</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;----------------------------------------------------&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(arr1)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;----------------------------------------------------&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(arr2)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;----------------------------------------------------&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(arr1.shape)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;----------------------------------------------------&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(arr2.shape)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;----------------------------------------------------&quot;</span>)</span><br></pre></td></tr></table></figure>
<pre><code>----------------------------------------------------
[[0.77395605 0.43887844 0.85859792]
 [0.69736803 0.09417735 0.97562235]]
----------------------------------------------------
[[0.7611397  0.78606431 0.12811363]
 [0.45038594 0.37079802 0.92676499]]
----------------------------------------------------
(2, 3)
----------------------------------------------------
(2, 3)
----------------------------------------------------</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 默认沿axis=0（列）连接</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;----------------------------------------------------&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(np.concatenate((arr1, arr2)))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;----------------------------------------------------&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(np.concatenate((arr1, arr2)).shape)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;----------------------------------------------------&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(np.concatenate((arr1, arr2), axis=<span class="number">1</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;----------------------------------------------------&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(np.concatenate((arr1, arr2), axis=<span class="number">1</span>).shape)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;----------------------------------------------------&quot;</span>)</span><br></pre></td></tr></table></figure>
<pre><code>----------------------------------------------------
[[0.77395605 0.43887844 0.85859792]
 [0.69736803 0.09417735 0.97562235]
 [0.7611397  0.78606431 0.12811363]
 [0.45038594 0.37079802 0.92676499]]
----------------------------------------------------
(4, 3)
----------------------------------------------------
[[0.77395605 0.43887844 0.85859792 0.7611397  0.78606431 0.12811363]
 [0.69736803 0.09417735 0.97562235 0.45038594 0.37079802 0.92676499]]
----------------------------------------------------
(2, 6)
----------------------------------------------------</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 竖直按行顺序拼接</span></span><br><span class="line"><span class="comment"># 注意：vstack 虽然看起来是 stack，但其实它是 concatenate，建议您只使用 np.concatenate</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;----------------------------------------------------&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(np.hstack((arr1, arr2)).shape)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;----------------------------------------------------&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(np.vstack((arr1, arr2)).shape)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;----------------------------------------------------&quot;</span>)</span><br></pre></td></tr></table></figure>
<pre><code>----------------------------------------------------
(2, 6)
----------------------------------------------------
(4, 3)
----------------------------------------------------</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 堆叠，默认根据 axis=0 进行</span></span><br><span class="line">np.stack((arr1, arr2))</span><br></pre></td></tr></table></figure>
<pre><code>array([[[0.77395605, 0.43887844, 0.85859792],
        [0.69736803, 0.09417735, 0.97562235]],

       [[0.7611397 , 0.78606431, 0.12811363],
        [0.45038594, 0.37079802, 0.92676499]]])</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">_.shape</span><br></pre></td></tr></table></figure>
<pre><code>(2, 2, 3)</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 堆叠，根据 axis=2</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;----------------------------------------------------&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(np.stack((arr1, arr2), axis=<span class="number">1</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;----------------------------------------------------&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(np.stack((arr1, arr2), axis=<span class="number">1</span>).shape)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;----------------------------------------------------&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(np.stack((arr1, arr2), axis=<span class="number">2</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;----------------------------------------------------&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(np.stack((arr1, arr2), axis=<span class="number">2</span>).shape)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;----------------------------------------------------&quot;</span>)</span><br></pre></td></tr></table></figure>
<pre><code>----------------------------------------------------
[[[0.77395605 0.43887844 0.85859792]
  [0.7611397  0.78606431 0.12811363]]

 [[0.69736803 0.09417735 0.97562235]
  [0.45038594 0.37079802 0.92676499]]]
----------------------------------------------------
(2, 2, 3)
----------------------------------------------------
[[[0.77395605 0.7611397 ]
  [0.43887844 0.78606431]
  [0.85859792 0.12811363]]

 [[0.69736803 0.45038594]
  [0.09417735 0.37079802]
  [0.97562235 0.92676499]]]
----------------------------------------------------
(2, 3, 2)
----------------------------------------------------</code></pre>
<h3 id="重复">重复</h3>
<p>⭐⭐⭐</p>
<p>重复其实是另一种拼接方式，它也可以指定要重复的维度。在有些深度学习模型数据构建中非常有用（方便）。</p>
<p>⚠️ 需要注意的是：是一个维度一个维度依次重复，而不是整个 array 重复。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">rng = np.random.default_rng(<span class="number">42</span>)</span><br><span class="line">arr = rng.integers(<span class="number">0</span>, <span class="number">10</span>, (<span class="number">3</span>, <span class="number">4</span>))</span><br><span class="line">arr</span><br></pre></td></tr></table></figure>
<pre><code>array([[0, 7, 6, 4],
       [4, 8, 0, 6],
       [2, 0, 5, 9]])</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 在 axis=0（沿着列）上重复 2 次</span></span><br><span class="line">np.repeat(arr, <span class="number">2</span>, axis=<span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<pre><code>array([[0, 7, 6, 4],
       [0, 7, 6, 4],
       [4, 8, 0, 6],
       [4, 8, 0, 6],
       [2, 0, 5, 9],
       [2, 0, 5, 9]])</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 在 axis=1（沿着行）上重复 3 次</span></span><br><span class="line">np.repeat(arr, <span class="number">3</span>, axis=<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<pre><code>array([[0, 0, 0, 7, 7, 7, 6, 6, 6, 4, 4, 4],
       [4, 4, 4, 8, 8, 8, 0, 0, 0, 6, 6, 6],
       [2, 2, 2, 0, 0, 0, 5, 5, 5, 9, 9, 9]])</code></pre>
<h3 id="分拆">分拆</h3>
<p>⭐⭐⭐</p>
<p>有拼接堆叠自然就有拆分，注意这不是切片和索引，就是将 array 拆成想要的几份。用的不是特别多，API 只要记住 <code>np.split</code> 就行了，其他的都是快捷方式。</p>
<p>⚠️ 需要注意的是：分拆的 axis 是对该维度进行拆分。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">rng = np.random.default_rng(<span class="number">42</span>)</span><br><span class="line">arr = rng.integers(<span class="number">1</span>, <span class="number">100</span>, (<span class="number">6</span>, <span class="number">4</span>))</span><br><span class="line">arr</span><br></pre></td></tr></table></figure>
<pre><code>array([[ 9, 77, 65, 44],
       [43, 86,  9, 70],
       [20, 10, 53, 97],
       [73, 76, 72, 78],
       [51, 13, 84, 45],
       [50, 37, 19, 92]])</code></pre>
<h4 id="np.split"><code>np.split</code></h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 默认切分列（axis=0），切成 3 份</span></span><br><span class="line">np.split(arr, <span class="number">3</span>)</span><br></pre></td></tr></table></figure>
<pre><code>[array([[ 9, 77, 65, 44],
        [43, 86,  9, 70]]),
 array([[20, 10, 53, 97],
        [73, 76, 72, 78]]),
 array([[51, 13, 84, 45],
        [50, 37, 19, 92]])]</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># （axis=1）切分行</span></span><br><span class="line">np.split(arr, <span class="number">2</span>, axis=<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<pre><code>[array([[ 9, 77],
        [43, 86],
        [20, 10],
        [73, 76],
        [51, 13],
        [50, 37]]),
 array([[65, 44],
        [ 9, 70],
        [53, 97],
        [72, 78],
        [84, 45],
        [19, 92]])]</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 和上面的一个效果</span></span><br><span class="line">np.vsplit(arr, <span class="number">3</span>)</span><br></pre></td></tr></table></figure>
<pre><code>[array([[ 9, 77, 65, 44],
        [43, 86,  9, 70]]),
 array([[20, 10, 53, 97],
        [73, 76, 72, 78]]),
 array([[51, 13, 84, 45],
        [50, 37, 19, 92]])]</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 等价的用法</span></span><br><span class="line">np.hsplit(arr, <span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<pre><code>[array([[ 9, 77],
        [43, 86],
        [20, 10],
        [73, 76],
        [51, 13],
        [50, 37]]),
 array([[65, 44],
        [ 9, 70],
        [53, 97],
        [72, 78],
        [84, 45],
        [19, 92]])]</code></pre>
<h2 id="筛选和过滤">筛选和过滤</h2>
<p>这小节与索引和切片有点类似，但倾向于从「整体」中统一筛选出「符合条件」的内容，而索引和切片更多的是依照「某种方法」切出一块内容。本小节内容同样非常重要，可以算第二个最重要的小节。主要包括以下内容：</p>
<ul>
<li>条件筛选</li>
<li>提取（按条件）</li>
<li>抽样（按分布）</li>
<li>最大最小 index（特殊值）</li>
</ul>
<p>这几个内容都很重要，使用的也非常高频。条件筛选经常用于 Mask 或异常值处理，提取则常用于结果过滤，抽样常用在数据生成（比如负样本抽样），最大最小 index 则常见于机器学习模型预测结果判定中（根据最大概率所在的 index 决定结果属于哪一类）。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">rng = np.random.default_rng(<span class="number">42</span>)</span><br><span class="line">arr = rng.integers(<span class="number">1</span>, <span class="number">100</span>, (<span class="number">3</span>, <span class="number">4</span>))</span><br><span class="line">arr</span><br></pre></td></tr></table></figure>
<pre><code>array([[ 9, 77, 65, 44],
       [43, 86,  9, 70],
       [20, 10, 53, 97]])</code></pre>
<h3 id="条件筛选">条件筛选</h3>
<p>⭐⭐⭐</p>
<p>顾名思义，根据一定的条件对 array 进行筛选（标记）并后续处理。核心 API 是 <code>np.where</code>。</p>
<p>⚠️ 需要注意的是：where 分别返回各维度的 index，赋值的是「不满足」条件的。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 条件筛选，可以直接在整个 array 上使用条件</span></span><br><span class="line">arr &gt; <span class="number">50</span></span><br></pre></td></tr></table></figure>
<pre><code>array([[False,  True,  True, False],
       [False,  True, False,  True],
       [False, False,  True,  True]])</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 返回满足条件的索引，因为是两个维度，所以会返回两组结果</span></span><br><span class="line">np.where(arr &gt; <span class="number">50</span>)</span><br></pre></td></tr></table></figure>
<pre><code>(array([0, 0, 1, 1, 2, 2]), array([1, 2, 1, 3, 2, 3]))</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 不满足条件的赋值，将 &lt;=50 的替换为 -1</span></span><br><span class="line">np.where(arr &gt; <span class="number">50</span>, arr, -<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<pre><code>array([[-1, 77, 65, -1],
       [-1, 86, -1, 70],
       [-1, -1, 53, 97]])</code></pre>
<h3 id="提取">提取</h3>
<p>⭐</p>
<p>在 array 中提取指定条件的值。</p>
<p>⚠️ 需要注意的是：提取和唯一值返回的都是一维向量。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 提取指定条件的值</span></span><br><span class="line">np.extract(arr &gt; <span class="number">50</span>, arr)</span><br></pre></td></tr></table></figure>
<pre><code>array([77, 65, 86, 70, 53, 97])</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 唯一值，是另一种形式的提取</span></span><br><span class="line">np.unique(arr)</span><br></pre></td></tr></table></figure>
<pre><code>array([ 9, 10, 20, 43, 44, 53, 65, 70, 77, 86, 97])</code></pre>
<h3 id="抽样">抽样</h3>
<p>⭐⭐⭐⭐⭐</p>
<p>我们在跑模型时常常需要使用部分数据对整个过程快速验证，您当然可以使用 <code>np.random</code> 生成模拟数据。但有真实数据时，从真实数据中随机抽样会比较好。</p>
<p>⚠️ 需要注意的是：抽样的集合要求为一维向量（一般是数据的 index）。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">rng = np.random.default_rng(<span class="number">42</span>)</span><br><span class="line"><span class="comment"># 第一个参数是要抽样的集合，如果是一个整数，则表示从 0 到该值</span></span><br><span class="line"><span class="comment"># 第二个参数是样本大小</span></span><br><span class="line"><span class="comment"># 第三个参数表示结果是否可以重复</span></span><br><span class="line"><span class="comment"># 第四个参数表示出现的概率，长度和第一个参数一样</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 由于（0 1 2 3）中 2 和 3 的概率比较高，自然就选择了 2 和 3</span></span><br><span class="line">rng.choice(<span class="number">4</span>, <span class="number">2</span>, replace=<span class="literal">False</span>, p=[<span class="number">0.1</span>, <span class="number">0.2</span>, <span class="number">0.3</span>, <span class="number">0.4</span>])</span><br><span class="line">lst = [<span class="string">&quot;la&quot;</span>, <span class="string">&quot;vida&quot;</span>, <span class="string">&quot;sola&quot;</span>, <span class="string">&quot;vivras&quot;</span>]</span><br><span class="line">rng.choice(lst, <span class="number">4</span>, replace=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure>
<pre><code>array([&#39;vida&#39;, &#39;vivras&#39;, &#39;la&#39;, &#39;sola&#39;], dtype=&#39;&lt;U6&#39;)</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 旧的 API</span></span><br><span class="line"><span class="comment"># 如果是抽样语料的 index，更多的方法是这样：</span></span><br><span class="line">data_size = <span class="number">10000</span></span><br><span class="line">np.random.choice(data_size, <span class="number">50</span>, replace=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure>
<pre><code>array([3711, 5502, 4383, 8491, 8931, 3725, 5223, 2632, 4078, 3705, 5488,
       9326, 9338, 3762, 6538, 6579, 3238,   61, 7129, 7451, 6321, 3881,
       8517, 6892, 2657, 4858, 6629, 9335, 3288, 2620,   90, 8999, 4165,
       7333, 8764, 9840, 4517, 8409, 1938, 3730, 2372, 8088, 7804, 9017,
       6956, 6413,  147, 5721, 6089, 8900])</code></pre>
<h3 id="最值-index">最值 Index</h3>
<p>⭐⭐⭐⭐⭐</p>
<p>这小节主要是两个 API：<code>np.argmax(min)</code> 和 <code>np.argsort</code>，当然最常用的还是第一个，不用说，自然是可以（需要）指定 axis 的。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">rng = np.random.default_rng(<span class="number">42</span>)</span><br><span class="line">arr = rng.uniform(<span class="number">1</span>, <span class="number">100</span>, (<span class="number">3</span>, <span class="number">4</span>))</span><br><span class="line">arr</span><br></pre></td></tr></table></figure>
<pre><code>array([[77.62164881, 44.44896554, 86.00119407, 70.03943488],
       [10.32355744, 97.58661281, 76.3528305 , 78.82036622],
       [13.68324963, 45.58820785, 37.7090044 , 92.7497339 ]])</code></pre>
<h4 id="np.argmaxargmin"><code>np.argmax/argmin</code></h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 所有值中最大值的 Index，基本不这么用</span></span><br><span class="line">np.argmax(arr)</span><br></pre></td></tr></table></figure>
<pre><code>5</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 按列（axis=0）最大值的 Index</span></span><br><span class="line">np.argmax(arr, axis=<span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<pre><code>array([0, 1, 0, 2])</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 按行（axis=1）最小值的 Index</span></span><br><span class="line">np.argmin(arr, axis=<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<pre><code>array([1, 0, 0])</code></pre>
<h4 id="np.argsort"><code>np.argsort</code></h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 默认按行（axis=1）排序的索引</span></span><br><span class="line">np.argsort(arr)</span><br></pre></td></tr></table></figure>
<pre><code>array([[1, 3, 0, 2],
       [0, 2, 3, 1],
       [0, 2, 1, 3]])</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 数据按行（axis=1）排序的索引，同上</span></span><br><span class="line"><span class="built_in">print</span>(np.argsort(-arr, axis=<span class="number">1</span>))</span><br><span class="line"><span class="built_in">print</span>(np.argsort(arr, axis=<span class="number">1</span>))</span><br></pre></td></tr></table></figure>
<pre><code>[[2 0 3 1]
 [1 3 2 0]
 [3 1 2 0]]
[[1 3 0 2]
 [0 2 3 1]
 [0 2 1 3]]</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 数据按列（axis=0）排序索引</span></span><br><span class="line">np.argsort(arr, axis=<span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<pre><code>array([[1, 0, 2, 0],
       [2, 2, 1, 1],
       [0, 1, 0, 2]])</code></pre>
<h2 id="矩阵和运算">矩阵和运算</h2>
<p>这一节我们将聚焦矩阵和相关的运算，主要包括：</p>
<ul>
<li>算术（四则运算及其他基础算术）</li>
<li>广播</li>
<li>矩阵相关</li>
</ul>
<p>这些内容其实使用非常普遍，普遍到我们甚至都不会察觉到自己在使用，而且也非常简单。当然，高纬度的计算我们这里并不涉及，但逻辑是一致的，只是更加复杂。</p>
<h3 id="算术">算术</h3>
<p>⭐⭐⭐⭐</p>
<p>所有的算术函数均可直接运用于 array。</p>
<p>⚠️ 需要注意的是：<code>mod</code> 运算可以指定多个被除数。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">rng = np.random.default_rng(<span class="number">42</span>)</span><br><span class="line">arr = rng.integers(<span class="number">1</span>, <span class="number">20</span>, (<span class="number">3</span>, <span class="number">4</span>))</span><br><span class="line">arr</span><br></pre></td></tr></table></figure>
<pre><code>array([[ 2, 15, 13,  9],
       [ 9, 17,  2, 14],
       [ 4,  2, 11, 19]])</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># +-*/ 四则运算，就跟两个数字计算一样</span></span><br><span class="line">arr * <span class="number">2</span></span><br></pre></td></tr></table></figure>
<pre><code>array([[ 4, 30, 26, 18],
       [18, 34,  4, 28],
       [ 8,  4, 22, 38]])</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 平方也可以</span></span><br><span class="line">arr ** <span class="number">2</span></span><br></pre></td></tr></table></figure>
<pre><code>array([[  4, 225, 169,  81],
       [ 81, 289,   4, 196],
       [ 16,   4, 121, 361]])</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 开方</span></span><br><span class="line">np.sqrt(arr)</span><br></pre></td></tr></table></figure>
<pre><code>array([[1.41421356, 3.87298335, 3.60555128, 3.        ],
       [3.        , 4.12310563, 1.41421356, 3.74165739],
       [2.        , 1.41421356, 3.31662479, 4.35889894]])</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># log</span></span><br><span class="line">np.log(arr)</span><br></pre></td></tr></table></figure>
<pre><code>array([[0.69314718, 2.7080502 , 2.56494936, 2.19722458],
       [2.19722458, 2.83321334, 0.69314718, 2.63905733],
       [1.38629436, 0.69314718, 2.39789527, 2.94443898]])</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 超过5的都换成5</span></span><br><span class="line">np.minimum(arr, <span class="number">5</span>)</span><br></pre></td></tr></table></figure>
<pre><code>array([[2, 5, 5, 5],
       [5, 5, 2, 5],
       [4, 2, 5, 5]])</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 低于5的都换成5</span></span><br><span class="line">np.maximum(arr, <span class="number">5</span>)</span><br></pre></td></tr></table></figure>
<pre><code>array([[ 5, 15, 13,  9],
       [ 9, 17,  5, 14],
       [ 5,  5, 11, 19]])</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 四舍五入</span></span><br><span class="line">np.<span class="built_in">round</span>(np.sqrt(arr), <span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<pre><code>array([[1.41, 3.87, 3.61, 3.  ],
       [3.  , 4.12, 1.41, 3.74],
       [2.  , 1.41, 3.32, 4.36]])</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># floor/ceil</span></span><br><span class="line">np.floor(np.sqrt(arr))</span><br></pre></td></tr></table></figure>
<pre><code>array([[1., 3., 3., 3.],
       [3., 4., 1., 3.],
       [2., 1., 3., 4.]])</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">np.ceil(np.sqrt(arr))</span><br></pre></td></tr></table></figure>
<pre><code>array([[2., 4., 4., 3.],
       [3., 5., 2., 4.],
       [2., 2., 4., 5.]])</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># mod &lt;=&gt; x % 3</span></span><br><span class="line">np.mod(arr, <span class="number">3</span>)</span><br></pre></td></tr></table></figure>
<pre><code>array([[2, 0, 1, 0],
       [0, 2, 2, 2],
       [1, 2, 2, 1]])</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">arr - <span class="number">5</span></span><br></pre></td></tr></table></figure>
<pre><code>array([[-3, 10,  8,  4],
       [ 4, 12, -3,  9],
       [-1, -3,  6, 14]])</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 还可以使用多个被除数</span></span><br><span class="line">np.mod(arr, arr - <span class="number">5</span>)</span><br></pre></td></tr></table></figure>
<pre><code>array([[-1,  5,  5,  1],
       [ 1,  5, -1,  5],
       [ 0, -1,  5,  5]])</code></pre>
<h3 id="矩阵">矩阵</h3>
<p>⭐⭐⭐⭐⭐</p>
<p>这一小节主要介绍线性代数中矩阵的处理，我们会介绍几个矩阵相关常用的 API。</p>
<p>⚠️ 需要注意的是：<code>dot</code> 和 <code>matmul</code> 在高维度时表现不同。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">rng = np.random.default_rng(<span class="number">42</span>)</span><br><span class="line">a = rng.integers(<span class="number">1</span>, <span class="number">10</span>, (<span class="number">3</span>, <span class="number">2</span>))</span><br><span class="line">b = rng.integers(<span class="number">1</span>, <span class="number">10</span>, (<span class="number">2</span>, <span class="number">4</span>))</span><br><span class="line">c = rng.integers(<span class="number">1</span>, <span class="number">10</span>, (<span class="number">3</span>, <span class="number">3</span>))</span><br><span class="line">a, b, c</span><br></pre></td></tr></table></figure>
<pre><code>(array([[1, 7],
        [6, 4],
        [4, 8]]),
 array([[1, 7, 2, 1],
        [5, 9, 7, 7]]),
 array([[7, 8, 5],
        [2, 8, 5],
        [5, 4, 2]]))</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># array 乘法</span></span><br><span class="line"><span class="comment"># 矩阵乘法</span></span><br><span class="line">np.dot(a, b)</span><br></pre></td></tr></table></figure>
<pre><code>array([[ 36,  70,  51,  50],
       [ 26,  78,  40,  34],
       [ 44, 100,  64,  60]])</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 我们看下高维度下 dot 和 matmul 的区别</span></span><br><span class="line"><span class="comment"># ijk, lkm -&gt; ijlm</span></span><br><span class="line">rng = np.random.default_rng(<span class="number">42</span>)</span><br><span class="line">a = rng.integers(<span class="number">1</span>, <span class="number">10</span>, (<span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>))</span><br><span class="line">b = rng.integers(<span class="number">1</span>, <span class="number">10</span>, (<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;-----------------------------------------------------&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;-----------------------------------------------------&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(b)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;-----------------------------------------------------&quot;</span>)</span><br><span class="line">c = np.dot(a, b)</span><br><span class="line">d = np.matmul(a, b)</span><br><span class="line"><span class="built_in">print</span>(c, c.shape)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;-----------------------------------------------------&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(d, d.shape)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;-----------------------------------------------------&quot;</span>)</span><br></pre></td></tr></table></figure>
<pre><code>-----------------------------------------------------
[[[1 7 6]
  [4 4 8]
  [1 7 2]]

 [[1 5 9]
  [7 7 7]
  [8 5 2]]]
-----------------------------------------------------
[[[8 5 5 4]
  [2 9 8 6]
  [4 8 5 4]]

 [[5 3 1 5]
  [8 1 8 8]
  [3 6 2 7]]]
-----------------------------------------------------
[[[[ 46 116  91  70]
   [ 79  46  69 103]]

  [[ 72 120  92  72]
   [ 76  64  52 108]]

  [[ 30  84  71  54]
   [ 67  22  61  75]]]</code></pre>
<p>​<br />
​ [[[ 54 122 90 70] ​ [ 72 62 59 108]] ​<br />
[[ 98 154 126 98] [112 70 77 140]]</p>
<pre><code>  [[ 82 101  90  70]
   [ 86  41  52  94]]]] (2, 3, 2, 4)
-----------------------------------------------------
[[[ 46 116  91  70]
  [ 72 120  92  72]
  [ 30  84  71  54]]

 [[ 72  62  59 108]
  [112  70  77 140]
  [ 86  41  52  94]]] (2, 3, 4)
-----------------------------------------------------</code></pre>
</article><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/2022%E5%A4%8F%E5%AD%A3/">2022夏季</a><a class="post-meta__tags" href="/tags/Python/">Python</a></div><div class="post_share"><div class="addthis_inline_share_toolbox"></div><script src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-62b11572b25ab3ab" async="async"></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/07/17/CS/others/Python%20%E8%BF%9B%E9%98%B6%E8%AF%9D%E9%A2%98/"><img class="prev-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/zhaochenyang20/ivue_wallpaper/main/ivue_desktop/Photo by Chris Henry (ZaT1RghkxsE).jpg" onerror="onerror=null;src='https://wkphoto.cdn.bcebos.com/1f178a82b9014a9058a735deb9773912b31bee3c.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Python 进阶话题</div></div></a></div><div class="next-post pull-right"><a href="/2022/07/01/%E9%9A%8F%E7%AC%94/%E6%B8%85%E5%8D%8E%E5%9B%AD%E6%97%A5%E8%AE%B0/%E6%B8%85%E5%8D%8E%E5%9B%AD%E6%97%A5%E8%AE%B0--%E7%AC%AC%E5%85%AD%E9%83%A8/"><img class="next-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://zhaochenyang20.github.io/pic/embed/6_8_3.jpg" onerror="onerror=null;src='https://wkphoto.cdn.bcebos.com/1f178a82b9014a9058a735deb9773912b31bee3c.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">清华园日记——第六部</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2022/07/17/CS/others/Python%20%E8%BF%9B%E9%98%B6%E8%AF%9D%E9%A2%98/" title="Python 进阶话题"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/zhaochenyang20/ivue_wallpaper/main/ivue_desktop/Photo by Chris Henry (ZaT1RghkxsE).jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-07-17</div><div class="title">Python 进阶话题</div></div></a></div><div><a href="/2022/07/31/%E9%9A%8F%E7%AC%94/%E6%B8%85%E5%8D%8E%E5%9B%AD%E6%97%A5%E8%AE%B0/%E6%B8%85%E5%8D%8E%E5%9B%AD%E6%97%A5%E8%AE%B0--%E7%AC%AC%E4%B8%83%E9%83%A8/" title="清华园日记·柒——临别项脊轩"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/zhaochenyang20/ivue_wallpaper/main/ivue_desktop/Photo%20by%20Lorenzo%20Spoleti%20(yxKHOTkAins).jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-07-31</div><div class="title">清华园日记·柒——临别项脊轩</div></div></a></div><div><a href="/2022/08/15/%E9%9A%8F%E7%AC%94/%E5%BF%83%E5%BF%83%E5%BF%B5%E5%BF%B5/%E5%A4%A7%E4%B8%89%E5%AD%A6%E5%B9%B4%E5%B1%95%E6%9C%9B/" title="大三学年展望"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/zhaochenyang20/ivue_wallpaper/main/ivue_desktop/Photo by Shot by Cerqueira (uFdsMOjWX58).jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-08-15</div><div class="title">大三学年展望</div></div></a></div><div><a href="/2022/04/24/%E9%9A%8F%E7%AC%94/%E5%BF%83%E5%BF%83%E5%BF%B5%E5%BF%B5/%E5%A4%A7%E4%BA%8C%E5%AD%A6%E5%B9%B4%E6%80%BB%E7%BB%93/" title="大二学年总结"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.imgdb.cn/item/620540f92ab3f51d91b65009.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-04-24</div><div class="title">大二学年总结</div></div></a></div><div><a href="/2022/08/03/%E9%9A%8F%E7%AC%94/%E5%BF%83%E5%BF%83%E5%BF%B5%E5%BF%B5/%E5%9B%BD%E8%80%BB/" title="国耻"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/zhaochenyang20/ivue_wallpaper/main/ivue_desktop/Photo%20by%20Michael%20Niessl%20(KraoHdRYrRE).jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-08-03</div><div class="title">国耻</div></div></a></div><div><a href="/2022/06/22/%E9%9A%8F%E7%AC%94/%E5%BF%83%E5%BF%83%E5%BF%B5%E5%BF%B5/%E7%AD%94%E7%96%91%E5%9D%8A%E6%8A%80%E6%9C%AF%E7%BB%84%E6%94%B9%E9%9D%A9%E6%96%B9%E6%A1%88/" title="答疑坊小程序开发组改革"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.imgdb.cn/item/61ed142a2ab3f51d911d2a57.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-06-22</div><div class="title">答疑坊小程序开发组改革</div></div></a></div><div><a href="/2022/07/23/%E9%9A%8F%E7%AC%94/%E5%BF%83%E5%BF%83%E5%BF%B5%E5%BF%B5/talk_with_dg/" title="交流琐记——邓俊辉老师（二）"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.imgdb.cn/item/61eccc602ab3f51d91d70cc6.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-07-23</div><div class="title">交流琐记——邓俊辉老师（二）</div></div></a></div><div><a href="/2022/01/23/%E9%9A%8F%E7%AC%94/%E5%BF%83%E5%BF%83%E5%BF%B5%E5%BF%B5/Call%20Me%20A%20Fool/" title="你将孤单而度过一生"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.imgdb.cn/item/620540f92ab3f51d91b65009.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-01-23</div><div class="title">你将孤单而度过一生</div></div></a></div><div><a href="/2022/07/25/Lecture/English/TOEFL_life_savior/" title="托福抢救计划"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.imgdb.cn/item/61eccb4d2ab3f51d91d616f7.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-07-25</div><div class="title">托福抢救计划</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="gitalk-container"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E-numpy-%E7%9A%84-python-%E7%A7%91%E5%AD%A6%E8%AE%A1%E7%AE%97%E5%85%A5%E9%97%A8"><span class="toc-number">1.</span> <span class="toc-text">基于 Numpy 的 Python 科学计算入门</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#intro-why-numpy"><span class="toc-number">1.1.</span> <span class="toc-text">Intro: Why Numpy?</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%86%85%E5%AE%B9%E9%87%8D%E7%82%B9"><span class="toc-number">2.</span> <span class="toc-text">内容重点</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#python-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">2.1.</span> <span class="toc-text">Python 数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#python-%E6%95%B4%E5%9E%8B%E4%B8%8D%E4%BB%85%E4%BB%85%E6%98%AF%E4%B8%80%E4%B8%AA%E6%95%B4%E5%9E%8B"><span class="toc-number">2.1.1.</span> <span class="toc-text">Python 整型不仅仅是一个整型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#python-%E5%88%97%E8%A1%A8%E4%B8%8D%E4%BB%85%E4%BB%85%E6%98%AF%E4%B8%80%E4%B8%AA%E5%88%97%E8%A1%A8"><span class="toc-number">2.1.2.</span> <span class="toc-text">Python 列表不仅仅是一个列表</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BD%95-numpy-%E4%BC%9A%E6%9B%B4%E5%BF%AB"><span class="toc-number">2.2.</span> <span class="toc-text">为何 numpy 会更快？</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E5%92%8C%E7%94%9F%E6%88%90"><span class="toc-number">3.</span> <span class="toc-text">创建和生成</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%8E-python-%E5%88%97%E8%A1%A8%E6%88%96%E5%85%83%E7%BB%84%E5%88%9B%E5%BB%BA"><span class="toc-number">3.0.1.</span> <span class="toc-text">从 python 列表或元组创建</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-arange-%E7%94%9F%E6%88%90"><span class="toc-number">3.1.</span> <span class="toc-text">使用 arange 生成</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-linspacelogspace-%E7%94%9F%E6%88%90"><span class="toc-number">3.1.1.</span> <span class="toc-text">使用 linspace&#x2F;logspace 生成</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-oneszeros-%E5%88%9B%E5%BB%BA"><span class="toc-number">3.1.2.</span> <span class="toc-text">使用 ones&#x2F;zeros 创建</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-random-%E7%94%9F%E6%88%90"><span class="toc-number">3.1.3.</span> <span class="toc-text">使用 random 生成</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%8E%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96"><span class="toc-number">3.1.4.</span> <span class="toc-text">从文件读取</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%9F%E8%AE%A1%E5%92%8C%E5%B1%9E%E6%80%A7"><span class="toc-number">3.2.</span> <span class="toc-text">统计和属性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%BA%E5%AF%B8%E7%9B%B8%E5%85%B3"><span class="toc-number">3.2.1.</span> <span class="toc-text">尺寸相关</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#np.shape"><span class="toc-number">3.2.1.1.</span> <span class="toc-text">np.shape</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E5%80%BC%E5%88%86%E4%BD%8D"><span class="toc-number">3.2.2.</span> <span class="toc-text">最值分位</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%B3%E5%9D%87%E6%B1%82%E5%92%8C%E6%A0%87%E5%87%86%E5%B7%AE"><span class="toc-number">3.2.3.</span> <span class="toc-text">平均求和标准差</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#np.sum"><span class="toc-number">3.2.3.1.</span> <span class="toc-text">np.sum</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BD%A2%E7%8A%B6%E5%92%8C%E8%BD%AC%E6%8D%A2"><span class="toc-number">3.3.</span> <span class="toc-text">形状和转换</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%94%B9%E5%8F%98%E5%BD%A2%E7%8A%B6"><span class="toc-number">3.3.1.</span> <span class="toc-text">改变形状</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#np.expand_dims"><span class="toc-number">3.3.1.1.</span> <span class="toc-text">np.expand_dims</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%80%9A%E7%94%A8%E5%87%BD%E6%95%B0"><span class="toc-number">4.</span> <span class="toc-text">通用函数</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%AB%98%E7%BA%A7%E7%9A%84%E9%80%9A%E7%94%A8%E5%87%BD%E6%95%B0%E7%89%B9%E6%80%A7"><span class="toc-number">4.1.</span> <span class="toc-text">高级的通用函数特性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B9%BF%E6%92%AD%E6%9C%BA%E5%88%B6"><span class="toc-number">4.2.</span> <span class="toc-text">广播机制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A7%84%E5%88%99"><span class="toc-number">4.3.</span> <span class="toc-text">规则！</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B9%BF%E6%92%AD%E7%9A%84%E5%AE%9E%E9%99%85%E8%BF%90%E7%94%A8"><span class="toc-number">4.4.</span> <span class="toc-text">广播的实际运用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8D%E5%BA%8F"><span class="toc-number">4.4.1.</span> <span class="toc-text">反序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BD%AC%E7%BD%AE"><span class="toc-number">4.4.2.</span> <span class="toc-text">转置</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#np.transpose"><span class="toc-number">4.4.2.1.</span> <span class="toc-text">np.transpose</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E8%A7%A3%E5%92%8C%E7%BB%84%E5%90%88"><span class="toc-number">4.5.</span> <span class="toc-text">分解和组合</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%87%E7%89%87%E5%92%8C%E7%B4%A2%E5%BC%95"><span class="toc-number">4.5.1.</span> <span class="toc-text">切片和索引</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#fancy-indexing"><span class="toc-number">4.5.2.</span> <span class="toc-text">Fancy Indexing</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E5%B8%83%E5%B0%94%E6%95%B0%E7%BB%84"><span class="toc-number">4.5.2.1.</span> <span class="toc-text">操作布尔数组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8E%A2%E7%B4%A2%E8%8A%B1%E5%93%A8%E7%9A%84%E7%B4%A2%E5%BC%95"><span class="toc-number">4.5.2.2.</span> <span class="toc-text">探索花哨的索引</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%84%E5%90%88%E7%B4%A2%E5%BC%95"><span class="toc-number">4.5.2.3.</span> <span class="toc-text">组合索引</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8B%BC%E6%8E%A5"><span class="toc-number">4.5.3.</span> <span class="toc-text">拼接</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E5%A4%8D"><span class="toc-number">4.5.4.</span> <span class="toc-text">重复</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E6%8B%86"><span class="toc-number">4.5.5.</span> <span class="toc-text">分拆</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#np.split"><span class="toc-number">4.5.5.1.</span> <span class="toc-text">np.split</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AD%9B%E9%80%89%E5%92%8C%E8%BF%87%E6%BB%A4"><span class="toc-number">4.6.</span> <span class="toc-text">筛选和过滤</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%A1%E4%BB%B6%E7%AD%9B%E9%80%89"><span class="toc-number">4.6.1.</span> <span class="toc-text">条件筛选</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8F%90%E5%8F%96"><span class="toc-number">4.6.2.</span> <span class="toc-text">提取</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8A%BD%E6%A0%B7"><span class="toc-number">4.6.3.</span> <span class="toc-text">抽样</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E5%80%BC-index"><span class="toc-number">4.6.4.</span> <span class="toc-text">最值 Index</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#np.argmaxargmin"><span class="toc-number">4.6.4.1.</span> <span class="toc-text">np.argmax&#x2F;argmin</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#np.argsort"><span class="toc-number">4.6.4.2.</span> <span class="toc-text">np.argsort</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9F%A9%E9%98%B5%E5%92%8C%E8%BF%90%E7%AE%97"><span class="toc-number">4.7.</span> <span class="toc-text">矩阵和运算</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%97%E6%9C%AF"><span class="toc-number">4.7.1.</span> <span class="toc-text">算术</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9F%A9%E9%98%B5"><span class="toc-number">4.7.2.</span> <span class="toc-text">矩阵</span></a></li></ol></li></ol></li></ol></div></div></div></div></main><footer id="footer" style="background: ＃0096FF"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2022 By Eren Zhao</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div><script type="text/javascript" id="maid-script" src="https://unpkg.com/mermaid@undefined/dist/mermaid.min.js?v=undefined"></script><script>if (window.mermaid) {
  var options = JSON.parse(document.getElementById('maid-script').getAttribute('mermaidoptioins'));
  mermaid.initialize(options);
}</script></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="chat_btn" type="button" title="rightside.chat_btn"><i class="fas fa-sms"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">本地搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库正在艰难运行</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.js"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [ ['$','$'], ["\\(","\\)"]],
      tags: 'ams'
    },
    chtml: {
      scale: 1.2
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, ''],
        insertScript: [200, () => {
          document.querySelectorAll('mjx-container:not\([display]\)').forEach(node => {
            const target = node.parentNode
            if (target.nodeName.toLowerCase() === 'li') {
              target.parentNode.classList.add('has-jax')
            } else {
              target.classList.add('has-jax')
            }
          });
        }, '', false]
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typeset()
}</script><script>(() => {
  const $mermaidWrap = document.querySelectorAll('#article-container .mermaid-wrap')
  if ($mermaidWrap.length) {
    window.runMermaid = () => {
      window.loadMermaid = true
      const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

      Array.from($mermaidWrap).forEach((item, index) => {
        const mermaidSrc = item.firstElementChild
        const mermaidThemeConfig = '%%{init:{ \'theme\':\'' + theme + '\'}}%%\n'
        const mermaidID = 'mermaid-' + index
        const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent
        mermaid.mermaidAPI.render(mermaidID, mermaidDefinition, (svgCode) => {
          mermaidSrc.insertAdjacentHTML('afterend', svgCode)
        })
      })
    }

    const loadMermaid = () => {
      window.loadMermaid ? runMermaid() : getScript('https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js').then(runMermaid)
    }

    window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
  }
})()</script><script>function addGitalkSource () {
  const ele = document.createElement('link')
  ele.rel = 'stylesheet'
  ele.href= 'https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css'
  document.getElementsByTagName('head')[0].appendChild(ele)
}

function loadGitalk () {
  function initGitalk () {
    var gitalk = new Gitalk(Object.assign({
      clientID: '978121c7b834efdd76be',
      clientSecret: '59b40e8f39a1c33db5a2c891771086164b9575c4',
      repo: 'zhaochenyang20.github.io',
      owner: 'zhaochenyang20',
      admin: ['zhaochenyang20'],
      id: '8e7634db7fb45134bcc8258e43ad8c92',
      updateCountCallback: commentCount
    },null))

    gitalk.render('gitalk-container')
  }

  if (typeof Gitalk === 'function') initGitalk()
  else {
    addGitalkSource()
    getScript('https://cdn.jsdelivr.net/npm/gitalk@latest/dist/gitalk.min.js').then(initGitalk)
  }
}

function commentCount(n){
  let isCommentCount = document.querySelector('#post-meta .gitalk-comment-count')
  if (isCommentCount) {
    isCommentCount.innerHTML= n
  }
}

if ('Gitalk' === 'Gitalk' || !true) {
  if (true) btf.loadComment(document.getElementById('gitalk-container'), loadGitalk)
  else loadGitalk()
} else {
  function loadOtherComment () {
    loadGitalk()
  }
}</script></div><canvas class="fireworks" mobile="true"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/fireworks.min.js"></script><script defer="defer" id="fluttering_ribbon" mobile="true" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-fluttering-ribbon.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = false;
POWERMODE.mobile = true;
document.body.addEventListener('input', POWERMODE);
</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/tororo.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":true},"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/"});</script></body></html>